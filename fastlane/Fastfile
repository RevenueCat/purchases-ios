# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

default_platform(:ios)

files_with_version_number = [
  './RevenueCat.podspec',
  './Sources/Misc/SystemInfo.swift',
  './.jazzy.yaml',
  './.version',
  './scripts/docs/index.html',
  './Sources/Misc/SystemInfo.swift'
]
files_with_version_number_without_prerelease_modifiers = [
  './Sources/Info.plist',
  './Tests/BackendIntegrationTestApp/Info.plist',
  './Tests/BackendIntegrationTests/Info.plist',
  './Tests/UnitTests/Info.plist',
  './Tests/UnitTestsHostApp/Info.plist'
]
repo_name = 'purchases-ios'
changelog_latest_path = './CHANGELOG.latest.md'
changelog_path = './CHANGELOG.md'

platform :ios do
  before_all do
    setup_circle_ci
    update_fastlane
  end

  desc "Bump version, update swift header, edit changelog, and create pull request"
  lane :bump do |options|
    bump_version_update_changelog_create_pr(
      current_version: current_version_number,
      changelog_latest_path: changelog_latest_path,
      changelog_path: changelog_path,
      files_to_update: files_with_version_number,
      files_to_update_without_prerelease_modifiers: files_with_version_number_without_prerelease_modifiers,
      repo_name: repo_name,
      github_rate_limit: options[:github_rate_limit],
      editor: options[:editor],
      next_version: options[:next_version],
      automatic_release: options[:automatic_release]
    )
    compile_autogenerated_header_commit_and_push(options)
  end

  desc "Automatically bumps version, update swift header, edit changelog, and create pull request"
  lane :automatic_bump do |options|
    next_version, type_of_bump = determine_next_version_using_labels(
      repo_name: repo_name,
      github_rate_limit: options[:github_rate_limit]
    )
    options[:next_version] = next_version
    options[:automatic_release] = true
    if type_of_bump == :skip
      UI.message('Skipping automatic bump since the next version doesn\'t include public facing changes')
      next
    end
    if type_of_bump == :major
      UI.message('Skipping automatic bump since the next version is a major release')
      next
    end
    bump(options)
  end

  desc "Make github release"
  lane :github_release do |options|
    create_github_release(
      version: options[:version],
      repo_name: repo_name,
      github_api_token: ENV["GITHUB_TOKEN"],
      changelog_latest_path: changelog_latest_path,
      upload_assets: ['RevenueCat.framework.zip', 'RevenueCat.xcframework.zip']
    )
  end

  desc "Creates PR changing version to next minor adding a -SNAPSHOT suffix"
  lane :prepare_next_version do |options|
    create_next_snapshot_version(
      current_version: current_version_number,
      repo_name: repo_name,
      github_pr_token: ENV["GITHUB_PULL_REQUEST_API_TOKEN"],
      files_to_update: files_with_version_number,
      files_to_update_without_prerelease_modifiers: files_with_version_number_without_prerelease_modifiers
    )
  end


  desc "Setup development environment"
  lane :setup_dev do |options|
    begin
      sh("brew install swiftlint")
    rescue => exception
      UI.error("âŒ Please install homebrew and then re-run this lane: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"")
      raise exception
    end

    pre_commit_link = "../.git/hooks/pre-commit"
    if File.exist?(pre_commit_link) || File.symlink?(pre_commit_link)
      UI.message("pre-commit script already linked âœ…")
    else
      UI.message("Linking pre-commit script ðŸ”—")
      Dir.chdir ".." do
        sh("ln -s -f ../../scripts/pre-commit.sh .git/hooks/pre-commit")
      end
    end
  end

  desc "Runs all the iOS tests"
  lane :test_ios do |options|
    scan(
      step_name: "scan - iPhone",
      device: ENV['SCAN_DEVICE'] || "iPhone 12 (15.2)",
      scheme: "RevenueCat",
      prelaunch_simulator: true,
      output_types: 'junit',
      number_of_retries: 5,
      result_bundle: true,
      testplan: "CI-AllTests",
      output_directory: "fastlane/test_output/xctest/ios"
    )
  end

  desc "Runs all the tvOS tests"
  lane :test_tvos do |options|
    scan(
      step_name: "scan - Apple TV",
      device: ENV['SCAN_DEVICE'] || "Apple TV (15.2)",
      scheme: "RevenueCat",
      prelaunch_simulator: true,
      output_types: 'junit',
      number_of_retries: 5,
      result_bundle: true,
      testplan: "CI-AllTests",
      output_directory: "fastlane/test_output/xctest/tvos"
    )
  end

  desc "Release checks"
  lane :release_checks do |options|
    version_number = current_version_number
    check_no_git_tag_exists(version_number)
    check_pods
    carthage_archive
    export_xcframework
    check_no_github_release_exists(version_number)
  end

  desc "build tvOS, watchOS, macOS"
  lane :build_tv_watch_mac do |options|
    check_pods
    carthage(command: "build", no_skip_current: true, platform: "watchOS,tvOS,Mac", use_xcframeworks: true)
  end

  desc "macOS build"
  lane :build_mac do |options|
    check_pods
    carthage(command: "build", no_skip_current: true, platform: "Mac", use_xcframeworks: true)
  end

  desc "Run the carthage archive steps to prepare for carthage distribution"
  lane :carthage_archive do |options|
    carthage_archive
  end

  desc "archive"
  lane :archive do
    match(type: "appstore")
    gym(export_method: "app-store")
  end

  desc "archive all platforms"
  lane :archive_all_platforms do
    platforms = {
      'ios' => 'generic/platform=ios',
       'tvos' => 'generic/platform=tvos',
       'catalyst' => 'generic/platform=macOS,variant=Mac Catalyst'
    }

    platforms.each do |platform, destination|
      match(type: "appstore", platform: platform)
      gym(export_method: "app-store", destination: destination)
    end
  end

  desc "build Swift API tester"
  lane :build_swift_api_tester do
    xcodebuild(
      workspace: 'Tests/APITesters/APITesters.xcworkspace',
      scheme: 'SwiftAPITester',
      destination: 'generic/platform=iOS Simulator'
    )
  end

  desc "build ObjC API tester"
  lane :build_objc_api_tester do
    xcodebuild(
      workspace: 'Tests/APITesters/APITesters.xcworkspace',
      scheme: 'ObjCAPITester',
      destination: 'generic/platform=iOS Simulator'
    )
  end

  desc "replace API KEY for installation and integration tests"
  lane :replace_api_key_integration_tests do
    replace_text_in_files(
      previous_text: "REVENUECAT_API_KEY",
      new_text: ENV["REVENUECAT_API_KEY"],
      paths_of_files_to_update: [
        './Tests/BackendIntegrationTests/Constants.swift',
        './Tests/InstallationTests/CommonFiles/RCInstallationRunner.m'
      ]
    )

    replace_text_in_files(
      previous_text: "REVENUECAT_PROXY_URL",
      new_text: ENV["REVENUECAT_PROXY_URL"].to_s,
      paths_of_files_to_update: [
        './Tests/BackendIntegrationTests/Constants.swift',
        './Tests/InstallationTests/CommonFiles/RCInstallationRunner.m'
      ],
      allow_empty: true
    )
  end

  desc "Release to CocoaPods, create Carthage archive, export XCFramework, and create GitHub release"
  lane :release do |options|
    version_number = current_version_number
    push_pods
    carthage_archive
    export_xcframework
    github_release(version: version_number)
  end

  desc "Tag current branch with current version number"
  lane :tag_current_branch do |options|
    version_number = current_version_number
    check_no_git_tag_exists(version_number)

    add_git_tag(tag: version_number)
    push_git_tags(tag: version_number)
  end

  desc "Checks whether the RevenueCat-Swift.h is up to date"
  private_lane :check_autogenerated_header_up_to_date do |options|
    ensure_git_status_clean
    compile_autogenerated_header
    begin
      ensure_git_status_clean
    rescue => e
      UI.error("RevenueCat-Swift.h autogenerated file changed. Make sure it's up-to-date before releasing.")
    end
  end

  private_lane :compile_autogenerated_header_commit_and_push do |options|
    ensure_git_status_clean
    compile_autogenerated_header
    begin
      ensure_git_status_clean
    rescue => e
      commit_current_changes(commit_message: "Update RevenueCat-Swift.h for version #{current_version_number}")
      push_to_git_remote
    end
  end

  desc "Creates RevenueCat-Swift.h for a new release"
  lane :compile_autogenerated_header do |options|
    # See https://github.com/RevenueCat/purchases-ios/blob/main/Documentation.docc/V4_API_Migration_guide.md#objc--spm

    require 'fileutils'

    arch = "x86_64"

    Dir.mktmpdir {|dir|
      xcodebuild(
        project: 'RevenueCat.xcodeproj',
        scheme: 'RevenueCat',
        derivedDataPath: dir,
        configuration: 'release',
        arch: arch,
        build_settings: {
          'ONLY_ACTIVE_ARCH': 'YES'
        }
      )

      FileUtils.cp(
        "#{dir}/Build/Intermediates.noindex/RevenueCat.build/Release/RevenueCat.build/Objects-normal/#{arch}/RevenueCat-Swift.h",
        File.absolute_path("../Tests/InstallationTests/CommonFiles/RevenueCat-Swift.h")
      )
    }
  end

  desc "Export XCFramework"
  lane :export_xcframework do |options|
    output_directory = 'build/xcframeworks'
    platforms = [
        'iOS',
        'macOS',
        'maccatalyst',
        'tvOS',
        'watchOS'
      ]

    create_xcframework(
      destinations: platforms,
      scheme: 'RevenueCat',
      xcframework_output_directory: output_directory,
      # bitcode produces issues with Catalyst when validating builds,
      # with a message: "object not signed at all".
      enable_bitcode: false,
      include_debug_symbols: true
    )
    # sh runs from the Fastfile's location, but other commands run from the project root.
    output_directory_for_sh = "../#{output_directory}"

    xcframeworks_zip_path_for_sh = "../RevenueCat.xcframework.zip"
    sh("ditto", "-c", "-k", "--sequesterRsrc", "--keepParent",
      output_directory_for_sh,
      xcframeworks_zip_path_for_sh)

  end

  desc "Run BackendIntegrationTests"
  lane :backend_integration_tests do |options|
    replace_api_key_integration_tests
    scan(
      scheme: "BackendIntegrationTests",
      derived_data_path: "scan_derived_data",
      output_types: 'junit',
      number_of_retries: 3,
      result_bundle: true,
      testplan: "CI-BackendIntegration",
      output_directory: "fastlane/test_output/xctest/ios"
    )
  end

  desc "Update swift package commit"
  lane :update_swift_package_commit do
    project_file_locations = [
      './Tests/InstallationTests/SPMInstallation/SPMInstallation.xcodeproj/project.pbxproj',
      './Examples/MagicWeather/MagicWeather.xcodeproj/project.pbxproj'
    ]

    old_kind_line = "kind = branch;"
    new_kind_line = "kind = revision;"

    commit_hash = last_git_commit[:commit_hash]
    old_branch_line = "branch = main;"
    new_revision_line = "revision = #{commit_hash};"

    replace_text_in_files(
      previous_text: old_kind_line,
      new_text: new_kind_line,
      paths_of_files_to_update: project_file_locations
    )

    replace_text_in_files(
      previous_text: old_branch_line,
      new_text: new_revision_line,
      paths_of_files_to_update: project_file_locations
    )
  end

  desc "Preview docs"
  lane :preview_docs do
    ENV["INCLUDE_DOCC_PLUGIN"] = "true"
    Dir.chdir("..") do
      sh("swift",
         "package",
         "--disable-sandbox",
         "preview-documentation",
         "--target",
         "RevenueCat",
         "--transform-for-static-hosting")
    end
  end

  desc "Generate docs"
  lane :generate_docs do
    ENV["INCLUDE_DOCC_PLUGIN"] = "true"
    version_number = current_version_number
    docs_repo_base_url = ENV["DOCS_REPO_BASE_URL"]
    docs_repo_name = ENV["DOCS_REPO_NAME"]
    UI.user_error!("Missing environment variable: DOCS_REPO_BASE_URL") unless docs_repo_base_url
    UI.user_error!("Missing environment variable: DOCS_REPO_NAME") unless docs_repo_name

    docs_repo_url = File.join(docs_repo_base_url, docs_repo_name)
    hosting_base_path = File.join(docs_repo_name, version_number)

    Dir.mktmpdir do |docs_generation_folder|
      # swift package must be run from the dir that contains the Package.swift
      # output is generated in docs_generation_folder
      Dir.chdir("..") do
        sh("swift",
           "package",
           "--disable-sandbox",
           "--allow-writing-to-directory",
           docs_generation_folder,
           "generate-documentation",
           "--target",
           "RevenueCat",
           "--disable-indexing",
           "--output-path",
           docs_generation_folder,
           "--hosting-base-path",
           hosting_base_path,
           "--transform-for-static-hosting")
        docs_index_path = File.join(Dir.pwd, "scripts/docs/index.html")
        # clone docs repo
        Dir.mktmpdir do |docs_repo_clone_dir|
          Dir.chdir(docs_repo_clone_dir) do
            sh("git", "clone", docs_repo_url)
            Dir.chdir(docs_repo_name) do
              # copy docs generated in the previous step into the docs folder
              # and push the changes
              docs_destination_folder = "docs/#{version_number}"
              index_destination_path = "docs/index.html"
              FileUtils.cp_r docs_generation_folder, docs_destination_folder
              FileUtils.cp docs_index_path, index_destination_path

              # using sh instead of fastlane commands because fastlane would run
              # from the repo root
              sh("git", "add", docs_destination_folder)
              sh("git", "add", index_destination_path)
              sh("git", "commit", "-m", "Update documentation for #{version_number}")
              sh("git", "push")
            end
          end
        end
      end
    end
  end

  desc "Create or delete sandbox testers"
  lane :sandbox_testers do
    Spaceship::ConnectAPI.login(use_portal: false)

    UI.deprecated("Email pattern will be used when creating and deleting multiple testers")
    UI.deprecated("fastlane will increment a number before '@'")
    UI.deprecated("Example: testparty.v4@revenuecat.com will make: ")
    UI.deprecated("   testparty.v4.1@revenuecat.com")
    UI.deprecated("   testparty.v4.2@revenuecat.com")
    UI.deprecated("   testparty.v4.3@revenuecat.com")
    email_pattern = UI.input("Sanbox Tester Email pattern:")

    options = ["Create", "Delete"]
    option = UI.select("What do you want to do?", options)

    if option == options[0]
      sandbox_testers_create(email_pattern: email_pattern)
    elsif option == options[1]
      sandbox_testers_delete(email_pattern: email_pattern)
    end
  end

  private_lane :sandbox_testers_delete do |options|
    email_pattern = options[:email_pattern]

    email_prefix = email_pattern.split('@').first

    testers = Spaceship::ConnectAPI::SandboxTester.all.select do |tester|
      tester.email.start_with?(email_prefix)
    end

    UI.important("Found testers:")
    testers.each do |tester|
      UI.message(tester.email)
    end

    if UI.confirm("Do you want to delete these sandbox testers?")
      testers.each do |tester|
        UI.message("Deleting #{tester.email}...")
        tester.delete!
      end
    end
  end

  private_lane :sandbox_testers_create do |options|
    email_pattern = options[:email_pattern]

    number = UI.input("Number of testers:").to_i
    UI.user_error!("Number needs to be more than 0") if number <= 0
    UI.user_error!("Number needs to be less than 51") if number > 50

    password = UI.input("Sandbox Tester Password (ex: 'SuperSecret01'):")

    question = UI.input("Sandbox Tester Secret Question (ex: 'Secret'):")
    answer = UI.input("Sandbox Tester Secret Answer (ex: 'Answer'):")

    emails = (1..number).map do |i|
      email_pattern.gsub('@', ".#{i.to_s}@")
    end

    emails.each do |email|
      data = {
        first_name: "Tester",
        last_name: "FastlaneCreated",
        email: email,
        password: password,
        confirm_password: password,
        secret_question: question,
        secret_answer: answer,
        birth_date: "1990-01-01",
        app_store_territory: "USA"
      }
      UI.message("Creating #{email}...")
      Spaceship::ConnectAPI::SandboxTester.create(**data)
    end
  end

end

def push_pods
  pod_push(path: "RevenueCat.podspec", synchronous: true)
end

def check_no_git_tag_exists(version_number)
  if git_tag_exists(tag: version_number, remote: true, remote_name: 'origin')
    raise "git tag with version #{version_number} already exists!"
  end
end


def check_no_github_release_exists(version_number)
  found_release_number = get_github_release(url: "revenuecat/purchases-ios", version: version_number)
  raise "Release with version #{version_number} already exists!" unless found_release_number.nil?
end

def carthage_archive
  Dir.chdir("..") do
    # As of Carthage 0.38.0, we still can't archive xcframeworks directly.
    # there are also some issues which prevent us from archiving frameworks directly, since
    # carthage can't deal with architectures for simulators and for Apple Silicon correctly.
    # We use this script as a workaround until this is fixed.
    # https://github.com/Carthage/Carthage/releases/0.38.0
    sh("./scripts/carthage.sh", "build", "--no-skip-current")
    sh("./scripts/carthage.sh", "archive", "RevenueCat")
  end
end

lane :check_pods do
  pod_lib_lint(verbose: true, podspec:'RevenueCat.podspec')
end

def current_version_number
  File.read("../.version").strip
end
