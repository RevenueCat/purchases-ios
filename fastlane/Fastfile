# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

default_platform(:ios)

files_with_version_number = {
  './RevenueCat.podspec' => ['s.version          = "{x}"'],
  './Sources/Misc/SystemInfo.swift' => ['return "{x}"'],
  './.version' => ['{x}'],
  './scripts/docs/index.html' => ['purchases-ios-docs/{x}/documentation/revenuecat'],
  './scripts/docs/v4_api_migration_guide.html' => ['purchases-ios-docs/{x}/documentation/revenuecat/v4_api_migration_guide']
}
PLIST_VERSION_PATTERNS = ["<key>CFBundleShortVersionString</key>\n\t<string>{x}</string>",]
files_with_version_number_without_prerelease_modifiers = {
  './Sources/Info.plist' => PLIST_VERSION_PATTERNS,
  './Tests/BackendIntegrationTestApp/Info.plist' => PLIST_VERSION_PATTERNS,
  './Tests/BackendIntegrationTests/Info.plist' => PLIST_VERSION_PATTERNS,
  './Tests/UnitTests/Info.plist' => PLIST_VERSION_PATTERNS,
  './Tests/UnitTestsHostApp/Info.plist' => PLIST_VERSION_PATTERNS
}
repo_name = 'purchases-ios'
changelog_latest_path = './CHANGELOG.latest.md'
changelog_path = './CHANGELOG.md'

platform :ios do
  before_all do
    setup_circle_ci
    update_fastlane

    if ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID']
      app_store_connect_api_key # This will create a shared client that all the tools know how to use and will look for
    end
  end

  desc "Bump version, update swift header, edit changelog, and create pull request"
  lane :bump do |options|
    bump_version_update_changelog_create_pr(
      current_version: current_version_number,
      changelog_latest_path: changelog_latest_path,
      changelog_path: changelog_path,
      files_to_update: files_with_version_number,
      files_to_update_without_prerelease_modifiers: files_with_version_number_without_prerelease_modifiers,
      repo_name: repo_name,
      github_rate_limit: options[:github_rate_limit],
      editor: options[:editor],
      next_version: options[:next_version],
      automatic_release: options[:automatic_release]
    )
    compile_autogenerated_header_commit_and_push(options)
  end

  desc "Automatically bumps version, update swift header, edit changelog, and create pull request"
  lane :automatic_bump do |options|
    next_version, type_of_bump = determine_next_version_using_labels(
      repo_name: repo_name,
      github_rate_limit: options[:github_rate_limit]
    )
    options[:next_version] = next_version
    options[:automatic_release] = true
    if type_of_bump == :skip
      UI.message('Skipping automatic bump since the next version doesn\'t include public facing changes')
      next
    end
    if type_of_bump == :major
      UI.message('Skipping automatic bump since the next version is a major release')
      next
    end
    bump(options)
  end

  desc "Make github release"
  lane :github_release do |options|
    create_github_release(
      version: options[:version],
      repo_name: repo_name,
      github_api_token: ENV["GITHUB_TOKEN"],
      changelog_latest_path: changelog_latest_path,
      upload_assets: ['RevenueCat.framework.zip', 'RevenueCat.xcframework.zip']
    )
  end

  desc "Creates PR changing version to next minor adding a -SNAPSHOT suffix"
  lane :prepare_next_version do |options|
    create_next_snapshot_version(
      current_version: current_version_number,
      repo_name: repo_name,
      github_pr_token: ENV["GITHUB_PULL_REQUEST_API_TOKEN"],
      files_to_update: files_with_version_number,
      files_to_update_without_prerelease_modifiers: files_with_version_number_without_prerelease_modifiers
    )
  end


  desc "Setup development environment"
  lane :setup_dev do |options|
    begin
      sh("brew install swiftlint")
    rescue => exception
      UI.error("❌ Please install homebrew and then re-run this lane: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"")
      raise exception
    end

    pre_commit_link = "../.git/hooks/pre-commit"
    if File.exist?(pre_commit_link) || File.symlink?(pre_commit_link)
      UI.message("pre-commit script already linked ✅")
    else
      UI.message("Linking pre-commit script 🔗")
      Dir.chdir ".." do
        sh("ln -s -f ../../scripts/pre-commit.sh .git/hooks/pre-commit")
      end
    end
  end

  desc "Runs all the iOS tests"
  lane :test_ios do |options|
    generate_snapshots = ENV["CIRCLECI_TESTS_GENERATE_SNAPSHOTS"] == "true"

    scan(
      step_name: "scan - iPhone",
      device: ENV['SCAN_DEVICE'] || "iPhone 12 (15.2)",
      ensure_devices_found: true,
      scheme: "RevenueCat",
      prelaunch_simulator: true,
      output_types: 'junit',
      result_bundle: true,
      testplan: generate_snapshots ? "CI-Snapshots" : "CI-AllTests",
      configuration: 'Debug',
      output_directory: "fastlane/test_output/xctest/ios",
      number_of_retries: generate_snapshots ? 0 : 5,
      fail_build: !generate_snapshots
    )
  end

  desc "Runs all the tvOS tests"
  lane :test_tvos do |options|
    scan(
      step_name: "scan - Apple TV",
      device: ENV['SCAN_DEVICE'] || "Apple TV",
      ensure_devices_found: true,
      scheme: "RevenueCat",
      prelaunch_simulator: true,
      output_types: 'junit',
      number_of_retries: 5,
      result_bundle: true,
      testplan: "CI-AllTests",
      configuration: 'Debug',
      output_directory: "fastlane/test_output/xctest/tvos"
    )
  end

  desc "Runs all the watchOS tests"
  lane :test_watchos do |options|
    scan(
      step_name: "scan - watchOS",
      device: ENV['SCAN_DEVICE'] || "Apple Watch Series 8 (41mm)",
      ensure_devices_found: true,
      scheme: "RevenueCat",
      prelaunch_simulator: true,
      output_types: 'junit',
      number_of_retries: 5,
      result_bundle: true,
      # Host app isn't available on watchOS
      testplan: "CI-RevenueCat",
      configuration: 'Debug',
      output_directory: "fastlane/test_output/xctest/watchos"
    )
  end

  desc "Release checks"
  lane :release_checks do |options|
    version_number = current_version_number
    check_no_git_tag_exists(version_number)
    check_pods
    carthage_archive
    export_xcframework
    check_no_github_release_exists(version_number)
  end

  desc "build tvOS, watchOS, macOS"
  lane :build_tv_watch_mac do |options|
    check_pods
    carthage(command: "build", no_skip_current: true, platform: "watchOS,tvOS,Mac", use_xcframeworks: true)
  end

  desc "macOS build"
  lane :build_mac do |options|
    check_pods
    carthage(command: "build", no_skip_current: true, platform: "Mac", use_xcframeworks: true)
  end

  desc "visionOS build"
  lane :build_visionos do |options|
    xcodebuild(
      workspace: 'RevenueCat.xcworkspace',
      scheme: 'RevenueCat',
      destination: 'generic/platform=visionOS',
      configuration: 'release',
      xcargs: "CODE_SIGN_IDENTITY='' CODE_SIGNING_REQUIRED=NO"
    )
  end

  desc "Run the carthage archive steps to prepare for carthage distribution"
  lane :carthage_archive do |options|
    carthage_archive
  end

  desc "archive"
  lane :archive do
    match(type: "appstore", readonly: true)
    gym(export_method: "app-store")
  end

  desc "archive all platforms"
  lane :archive_all_platforms do
    platforms = {
      'ios' => 'generic/platform=ios',
      'tvos' => 'generic/platform=tvos',
      'catalyst' => 'generic/platform=macOS,variant=Mac Catalyst'
    }

    platforms.each do |platform, destination|
      match(type: "appstore", platform: platform, readonly: true)
      gym(export_method: "app-store", destination: destination)
    end
  end

  desc "build Swift API tester"
  lane :build_swift_api_tester do
    xcodebuild(
      workspace: 'RevenueCat.xcworkspace',
      scheme: 'SwiftAPITester',
      destination: 'generic/platform=iOS Simulator',
      configuration: 'release',
    )
  end

  desc "build ObjC API tester"
  lane :build_objc_api_tester do
    xcodebuild(
      workspace: 'RevenueCat.xcworkspace',
      scheme: 'ObjCAPITester',
      destination: 'generic/platform=iOS Simulator',
      configuration: 'release',
    )
  end

  desc "build CustomEntitlementComputation API tester"
  lane :build_custom_entitlement_computation_api_tester do
    xcodebuild(
      project: 'Tests/APITesters/CustomEntitlementComputationSwiftAPITester/CustomEntitlementComputationSwiftAPITester.xcodeproj',
      scheme: 'SwiftAPITester',
      destination: 'generic/platform=iOS',
      xcargs: "CODE_SIGN_IDENTITY='' CODE_SIGNING_REQUIRED=NO",
      configuration: 'release',
    )
  end

  desc "replace API KEY for installation and integration tests"
  lane :replace_api_key_integration_tests do
    replace_text_in_files(
      previous_text: "REVENUECAT_API_KEY",
      new_text: ENV["REVENUECAT_API_KEY"],
      paths_of_files_to_update: [
        './Tests/BackendIntegrationTests/Constants.swift',
        './Tests/InstallationTests/CommonFiles/RCInstallationRunner.m'
      ]
    )
    replace_text_in_files(
      previous_text: "REVENUECAT_LOAD_SHEDDER_API_KEY",
      new_text: ENV["REVENUECAT_LOAD_SHEDDER_API_KEY"],
      paths_of_files_to_update: [
        './Tests/BackendIntegrationTests/Constants.swift',
        './Tests/v3LoadShedderIntegration/v3LoadShedderIntegrationTests/V3LoadShedderIntegrationTests.swift'
      ]
    )
    replace_text_in_files(
      previous_text: "REVENUECAT_CUSTOM_ENTITLEMENT_COMPUTATION_API_KEY",
      new_text: ENV["REVENUECAT_CUSTOM_ENTITLEMENT_COMPUTATION_API_KEY"],
      paths_of_files_to_update: [
        './Tests/BackendIntegrationTests/Constants.swift',
        './Tests/InstallationTests/SPMCustomEntitlementComputationInstallation/InstallationTests.swift'
      ]
    )

    replace_text_in_files(
      previous_text: "REVENUECAT_PROXY_URL",
      new_text: ENV["REVENUECAT_PROXY_URL"].to_s,
      paths_of_files_to_update: [
        './Tests/BackendIntegrationTests/Constants.swift',
        './Tests/InstallationTests/CommonFiles/RCInstallationRunner.m',
        './Tests/InstallationTests/SPMCustomEntitlementComputationInstallation/InstallationTests.swift'
      ],
      allow_empty: true
    )
  end

  desc "Create Carthage archive, export XCFramework, and create GitHub release"
  lane :release do |options|
    version_number = current_version_number
    # making it its own lane until https://github.com/CocoaPods/CocoaPods/issues/11621 is fixed.
    # push_pods 
    carthage_archive
    export_xcframework
    github_release(version: version_number)
  end

  desc "Release to CocoaPods"
  lane :push_pods do |options|
    push_pods
  end

  desc "Tag current branch with current version number"
  lane :tag_current_branch do |options|
    version_number = current_version_number
    check_no_git_tag_exists(version_number)

    add_git_tag(tag: version_number)
    push_git_tags(tag: version_number)
  end

  desc "Checks whether the RevenueCat-Swift.h is up to date"
  private_lane :check_autogenerated_header_up_to_date do |options|
    ensure_git_status_clean
    compile_autogenerated_header
    begin
      ensure_git_status_clean
    rescue => e
      UI.error("RevenueCat-Swift.h autogenerated file changed. Make sure it's up-to-date before releasing.")
    end
  end

  private_lane :compile_autogenerated_header_commit_and_push do |options|
    ensure_git_status_clean
    compile_autogenerated_header
    begin
      ensure_git_status_clean
    rescue => e
      commit_current_changes(commit_message: "Update RevenueCat-Swift.h for version #{current_version_number}")
      push_to_git_remote
    end
  end

  desc "Trigger CircleCI job to generate snapshots"
  lane :generate_snapshots do 
    require 'rest-client'

    # Prompt branch
    default_branch = git_branch
    branch = UI.input("Branch (defaults to #{default_branch}): ")
    branch = default_branch if branch == ""

    # Get CircleCI token
    circle_token = ENV["CIRCLE_TOKEN"]
    UI.user_error! "Please set the CIRCLE_TOKEN environment variable" unless circle_token

    # Make request
    headers = {"Circle-Token": circle_token, "Content-Type": "application/json", "Accept": "application/json"}
    data = {parameters: {generate_snapshots: true}, branch: branch}
    url = "https://circleci.com/api/v2/project/github/RevenueCat/purchases-ios/pipeline"

    resp = RestClient.post url, data.to_json, headers

    # Print workflow url
    number = JSON.parse(resp.body)["number"]
    workflow_url = "https://app.circleci.com/pipelines/github/RevenueCat/purchases-ios/#{number}"

    UI.important "Workflow: #{workflow_url}"
  end

  desc "Creates a new PR after new snapshot files were generated"
  lane :create_snapshot_pr do |options|
    version = options[:version]
    base_branch = ENV["CIRCLE_BRANCH"]

    build_number = ENV["CIRCLE_BUILD_NUM"] 

    branch_name = "generated_snapshots/#{base_branch}-#{build_number}-#{version}"
    sh("git", "checkout", "-b", branch_name)

    sh("git", "add", "../Tests")
    file_count = sh("git diff --cached --numstat | wc -l").strip.to_i

    if file_count == 0
      UI.important("No files to be committed")
    else
      sh("git", "commit", "-m", "[skip ci] Generating new test snapshots")
      push_to_git_remote

      circle_user = ENV["CIRCLE_USERNAME"]
      branch_link = "https://github.com/RevenueCat/purchases-ios/tree/#{base_branch}"
      body = "Requested by @#{circle_user} for [#{base_branch}](#{branch_link})"

      create_pull_request(
        repo: "revenuecat/purchases-ios",
        title: "Generating new test snapshots for `#{base_branch}` - #{version}",
        body: body,
        base: base_branch,
        api_token: ENV["GITHUB_TOKEN"],
        head: branch_name,
        labels: ["test"]
      )
    end
  end

  desc "Creates RevenueCat-Swift.h for a new release"
  lane :compile_autogenerated_header do |options|
    # See https://github.com/RevenueCat/purchases-ios/blob/main/Documentation.docc/V4_API_Migration_guide.md#objc--spm

    require 'fileutils'

    arch = "x86_64"

    Dir.mktmpdir {|dir|
      xcodebuild(
        project: 'RevenueCat.xcodeproj',
        scheme: 'RevenueCat',
        derivedDataPath: dir,
        configuration: 'release',
        arch: arch,
        build_settings: {
          'ONLY_ACTIVE_ARCH': 'YES'
        }
      )

      FileUtils.cp(
        "#{dir}/Build/Intermediates.noindex/RevenueCat.build/Release/RevenueCat.build/Objects-normal/#{arch}/RevenueCat-Swift.h",
        File.absolute_path("../Tests/InstallationTests/CommonFiles/RevenueCat-Swift.h")
      )
    }
  end

  desc "Export XCFramework"
  lane :export_xcframework do |options|
    output_directory = 'build/xcframeworks'
    platforms = [
        'iOS',
        'macOS',
        'maccatalyst',
        'tvOS',
        'watchOS',
        # Fixme: add xrOS
      ]

    create_xcframework(
      destinations: platforms,
      scheme: 'RevenueCat',
      xcframework_output_directory: output_directory,
      # Bitcode is no longer required since Xcode 14.
      enable_bitcode: false,
      include_debug_symbols: true
    )
    
    # sh runs from the Fastfile's location, but other commands run from the project root.
    output_directory_for_sh = "../#{output_directory}"

    # Sign XCFramework for Xcode 15
    sign_xcframework(
      file: "#{output_directory_for_sh}/RevenueCat.xcframework"
    )

    xcframeworks_zip_path_for_sh = "../RevenueCat.xcframework.zip"
    sh("ditto", "-c", "-k", "--sequesterRsrc", "--keepParent",
      output_directory_for_sh,
      xcframeworks_zip_path_for_sh)

  end

  desc "Run BackendIntegrationTests"
  lane :backend_integration_tests do |options|
    replace_api_key_integration_tests
    scan(
      scheme: "BackendIntegrationTests",
      derived_data_path: "scan_derived_data",
      output_types: 'junit',
      output_style: 'raw',
      number_of_retries: 3,
      result_bundle: true,
      testplan: "CI-BackendIntegration",
      configuration: 'Debug',
      output_directory: "fastlane/test_output/xctest/ios"
    )
  end

  desc "Run LoadShedder tests"
  lane :v3_loadshedder_integration_tests do |options|
    replace_api_key_integration_tests
    scan(
      project: "./Tests/v3LoadShedderIntegration/v3LoadShedderIntegration.xcodeproj",
      scheme: "v3LoadShedderIntegration",
      derived_data_path: "scan_derived_data",
      output_types: 'junit',
      output_style: 'raw',
      result_bundle: true,
      configuration: 'Debug',
      output_directory: "fastlane/test_output/xctest/ios"
    )
  end
  

  desc "Update swift package commit"
  lane :update_swift_package_commit do
    project_file_locations = [
      './Tests/InstallationTests/SPMInstallation/SPMInstallation.xcodeproj/project.pbxproj',
      './Tests/InstallationTests/SPMCustomEntitlementComputationInstallation/SPMInstallation.xcodeproj/project.pbxproj',
      './Tests/InstallationTests/ReceiptParserInstallation/ReceiptParserInstallation.xcodeproj/project.pbxproj',
      './Tests/APITesters/CustomEntitlementComputationSwiftAPITester/CustomEntitlementComputationSwiftAPITester.xcodeproj/project.pbxproj',
      './Tests/TestingApps/PurchaseTesterSwiftUI/PurchaseTester.xcodeproj/project.pbxproj',
      './Examples/MagicWeather/MagicWeather.xcodeproj/project.pbxproj',
      './RevenueCat.xcodeproj/project.pbxproj'
    ]

    old_kind_line = "kind = branch;"
    new_kind_line = "kind = revision;"

    commit_hash = last_git_commit[:commit_hash]
    old_branch_line = "branch = main;"
    new_revision_line = "revision = #{commit_hash};"

    replace_text_in_files(
      previous_text: old_kind_line,
      new_text: new_kind_line,
      paths_of_files_to_update: project_file_locations
    )

    replace_text_in_files(
      previous_text: old_branch_line,
      new_text: new_revision_line,
      paths_of_files_to_update: project_file_locations
    )
  end

  private_lane :sign_xcframework do |options|
    match(
      readonly: true,
      git_url: ENV['CERTS_REPO_URL'],
      type: 'appstore',
      skip_provisioning_profiles: true,
      # This isn't important, we just need to fetch the certificate
      app_identifier: "com.revenuecat.CarthageIntegration"
    )

    sh(
      "codesign", 
      "--timestamp",
      "-v",
      "--sign", "Apple Distribution: RevenueCat, Inc. (8SXR2327BM)",
      options[:file]
    )
  end

  private_lane :build_symbols_for_docs do
    ios_version = ENV['DOCS_IOS_VERSION'] || "16.1"

    sh("swift",
       "build",
       "--target", "RevenueCat",
       # Build for iOS instead of the default macOS. This ensures that iOS-only symbols are included in the docs.
       "-Xswiftc", "-sdk", "-Xswiftc", sh("xcrun", "--sdk", "iphonesimulator", "--show-sdk-path").strip!,
       "-Xswiftc", "-target", "-Xswiftc", "x86_64-apple-ios#{ios_version}-simulator",
       "-Xswiftc", "-emit-symbol-graph",
       "-Xswiftc", "-emit-symbol-graph-dir",
       "-Xswiftc", ".build")
  end

  desc "Preview docs"
  lane :preview_docs do
    ios_version = ENV['DOCS_IOS_VERSION'] || "16.1"

    ENV["INCLUDE_DOCC_PLUGIN"] = "true"
    Dir.chdir("..") do
      build_symbols_for_docs

      sh("swift",
         "package",
         "--disable-sandbox",
         "preview-documentation",
         "--target",
         "RevenueCat",
         "--platform",
         "name=iOS,version=#{ios_version}",
         "--transform-for-static-hosting",
         "--enable-inherited-docs",
         "--additional-symbol-graph-dir", ".build")
    end
  end

  desc "Generate docs"
  lane :generate_docs do
    ENV["INCLUDE_DOCC_PLUGIN"] = "true"

    version_number = current_version_number
    docs_repo_base_url = ENV["DOCS_REPO_BASE_URL"]
    docs_repo_name = ENV["DOCS_REPO_NAME"]
    ios_version = ENV['DOCS_IOS_VERSION'] || "16.1"
    
    UI.user_error!("Missing environment variable: DOCS_REPO_BASE_URL") unless docs_repo_base_url
    UI.user_error!("Missing environment variable: DOCS_REPO_NAME") unless docs_repo_name

    docs_repo_url = File.join(docs_repo_base_url, docs_repo_name)
    hosting_base_path = File.join(docs_repo_name, version_number)

    Dir.mktmpdir do |docs_generation_folder|
      # swift package must be run from the dir that contains the Package.swift
      # output is generated in docs_generation_folder
      Dir.chdir("..") do
        build_symbols_for_docs

        sh("swift",
           "package",
           "--disable-sandbox",
           "--allow-writing-to-directory",
           docs_generation_folder,
           "generate-documentation",
           "--target",
           "RevenueCat",
           "--disable-indexing", # Produces a DocC archive that is best-suited for hosting online but incompatible with Xcode.
           "--platform",
           "name=iOS,version=#{ios_version}",
           "--output-path",
           docs_generation_folder,
           "--hosting-base-path",
           hosting_base_path,
           "--transform-for-static-hosting",
           "--enable-inherited-docs",
           "--additional-symbol-graph-dir", ".build")
           
        docs_index_path = File.join(Dir.pwd, "scripts/docs/index.html")
        docs_migration_guide_path = File.join(Dir.pwd, "scripts/docs/v4_api_migration_guide.html")
        # clone docs repo
        Dir.mktmpdir do |docs_repo_clone_dir|
          Dir.chdir(docs_repo_clone_dir) do
            sh("git", "clone", docs_repo_url)
            Dir.chdir(docs_repo_name) do
              # copy docs generated in the previous step into the docs folder
              # and push the changes
              docs_destination_folder = "docs/#{version_number}"
              index_destination_path = "docs/index.html"
              migration_guide_destination_path = "docs/v4_api_migration_guide.html"
              FileUtils.cp_r docs_generation_folder + "/.", docs_destination_folder
              FileUtils.cp docs_index_path, index_destination_path
              FileUtils.cp docs_migration_guide_path, migration_guide_destination_path

              # using sh instead of fastlane commands because fastlane would run
              # from the repo root
              sh("git", "add", docs_destination_folder)
              sh("git", "add", index_destination_path)
              sh("git", "add", migration_guide_destination_path)
              sh("git", "commit", "-m", "Update documentation for #{version_number}")
              sh("git", "push")
            end
          end
        end
      end
    end
  end

  desc "Build and deploy PurchaseTesterSwiftUI"
  lane :deploy_purchase_tester do
    latest_changelog = File.read("#{File.dirname(__FILE__)}/../#{changelog_latest_path}")
    changelog = "Release #{current_version_number}:\n\n#{latest_changelog}"

    def ios_build(changelog)
      increment_build_number(
        build_number: latest_testflight_build_number(platform: 'ios') + 1,
        xcodeproj: 'PurchaseTester.xcodeproj'
      )
  
      match(readonly: true)
      build_ios_app(
        workspace: "PurchaseTester.xcworkspace",
        scheme: "PurchaseTester",
        destination: "generic/platform=ios",
        xcodebuild_formatter: ''
      )
      upload_to_testflight(
        changelog: changelog
      )
    end

    def macos_build(changelog)
      increment_build_number(
        build_number: latest_testflight_build_number(platform: 'osx') + 1,
        xcodeproj: 'PurchaseTester.xcodeproj'
      )
  
      match(readonly: true, platform: "macos", additional_cert_types: "mac_installer_distribution")
      build_mac_app(
        workspace: "PurchaseTester.xcworkspace",
        scheme: "PurchaseTester",
        destination: 'generic/platform=macOS',
        xcodebuild_formatter: ''
      )
      upload_to_testflight(
        changelog: changelog,
        app_platform: 'osx'
      )
    end

    ios_build(changelog)
    macos_build(changelog)
  end

  desc "Create or delete sandbox testers"
  lane :sandbox_testers do
    Spaceship::ConnectAPI.login(use_portal: false)

    UI.deprecated("Email pattern will be used when creating and deleting multiple testers")
    UI.deprecated("fastlane will increment a number before '@'")
    UI.deprecated("Example: testparty.v4@revenuecat.com will make: ")
    UI.deprecated("   testparty.v4.1@revenuecat.com")
    UI.deprecated("   testparty.v4.2@revenuecat.com")
    UI.deprecated("   testparty.v4.3@revenuecat.com")
    email_pattern = UI.input("Sanbox Tester Email pattern:")

    options = ["Create", "Delete"]
    option = UI.select("What do you want to do?", options)

    if option == options[0]
      sandbox_testers_create(email_pattern: email_pattern)
    elsif option == options[1]
      sandbox_testers_delete(email_pattern: email_pattern)
    end
  end

  private_lane :sandbox_testers_delete do |options|
    email_pattern = options[:email_pattern]

    email_prefix = email_pattern.split('@').first

    testers = Spaceship::ConnectAPI::SandboxTester.all.select do |tester|
      tester.email.start_with?(email_prefix)
    end

    UI.important("Found testers:")
    testers.each do |tester|
      UI.message(tester.email)
    end

    if UI.confirm("Do you want to delete these sandbox testers?")
      testers.each do |tester|
        UI.message("Deleting #{tester.email}...")
        tester.delete!
      end
    end
  end

  private_lane :sandbox_testers_create do |options|
    email_pattern = options[:email_pattern]

    number = UI.input("Number of testers:").to_i
    UI.user_error!("Number needs to be more than 0") if number <= 0
    UI.user_error!("Number needs to be less than 51") if number > 50

    password = UI.input("Sandbox Tester Password (ex: 'SuperSecret01'):")

    question = UI.input("Sandbox Tester Secret Question (ex: 'Secret'):")
    answer = UI.input("Sandbox Tester Secret Answer (ex: 'Answer'):")

    emails = (1..number).map do |i|
      email_pattern.gsub('@', ".#{i.to_s}@")
    end

    emails.each do |email|
      data = {
        first_name: "Tester",
        last_name: "FastlaneCreated",
        email: email,
        password: password,
        confirm_password: password,
        secret_question: question,
        secret_answer: answer,
        birth_date: "1990-01-01",
        app_store_territory: "USA"
      }
      UI.message("Creating #{email}...")
      Spaceship::ConnectAPI::SandboxTester.create(**data)
    end
  end

end

def push_pods
  pod_push(path: "RevenueCat.podspec", synchronous: true)
end

def check_no_git_tag_exists(version_number)
  if git_tag_exists(tag: version_number, remote: true, remote_name: 'origin')
    raise "git tag with version #{version_number} already exists!"
  else
    UI.message("✅ git tag with version #{version_number} doesn't exist")
  end
end

def check_no_github_release_exists(version_number)
  found_release_number = get_github_release(url: "revenuecat/purchases-ios", version: version_number)
  raise "Release with version #{version_number} already exists!" unless found_release_number.nil?
end

def carthage_archive
  Dir.chdir("..") do
    # As of Carthage 0.38.0, we still can't archive xcframeworks directly.
    # there are also some issues which prevent us from archiving frameworks directly, since
    # carthage can't deal with architectures for simulators and for Apple Silicon correctly.
    # We use this script as a workaround until this is fixed.
    # https://github.com/Carthage/Carthage/releases/0.38.0
    sh("./scripts/carthage.sh", "build", "--no-skip-current")
    sh("./scripts/carthage.sh", "archive", "RevenueCat")
  end
end

lane :check_pods do
  pod_lib_lint(
    verbose: true,
    podspec:'RevenueCat.podspec', 
    # TODO: re-add watchOS when https://github.com/CocoaPods/CocoaPods/issues/11558 is fixed.
    platforms:"ios,osx,tvos",
    fail_fast: true
  )
end

def current_version_number
  File.read("#{File.dirname(__FILE__)}/../.version").strip
end
