// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2 effective-5.10 (swiftlang-6.2.0.19.9 clang-1700.3.19.1)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name RevenueCat
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2
import AdServices
import Combine
import CommonCrypto
import CoreText
import CryptoKit
import Foundation
@_exported import RevenueCat
import StoreKit
import Swift
import SwiftUI
import UIKit
import _Concurrency
import _StoreKit_SwiftUI
import _StringProcessing
import _SwiftConcurrencyShims
import os
@_hasMissingDesignatedInitializers @objc(RCOffering) final public class Offering : ObjectiveC.NSObject {
  public struct PaywallComponents {
    public let uiConfig: RevenueCat.UIConfig
    public let data: RevenueCat.PaywallComponentsData
    public init(uiConfig: RevenueCat.UIConfig, data: RevenueCat.PaywallComponentsData)
  }
  @objc final public let identifier: Swift.String
  @objc final public let serverDescription: Swift.String
  @objc final public var metadata: [Swift.String : Any] {
    @objc get
  }
  final public let paywall: RevenueCat.PaywallData?
  final public let paywallComponents: RevenueCat.Offering.PaywallComponents?
  final public var hasPaywall: Swift.Bool {
    get
  }
  @objc final public let availablePackages: [RevenueCat.Package]
  @objc final public let lifetime: RevenueCat.Package?
  @objc final public let annual: RevenueCat.Package?
  @objc final public let sixMonth: RevenueCat.Package?
  @objc final public let threeMonth: RevenueCat.Package?
  @objc final public let twoMonth: RevenueCat.Package?
  @objc final public let monthly: RevenueCat.Package?
  @objc final public let weekly: RevenueCat.Package?
  @objc final public let webCheckoutUrl: Foundation.URL?
  @objc override final public var description: Swift.String {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func package(identifier: Swift.String?) -> RevenueCat.Package?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public subscript(key: Swift.String) -> RevenueCat.Package? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc convenience public init(identifier: Swift.String, serverDescription: Swift.String, metadata: [Swift.String : Any] = [:], availablePackages: [RevenueCat.Package], webCheckoutUrl: Foundation.URL?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(identifier: Swift.String, serverDescription: Swift.String, metadata: [Swift.String : Any] = [:], paywall: RevenueCat.PaywallData? = nil, paywallComponents: RevenueCat.Offering.PaywallComponents? = nil, availablePackages: [RevenueCat.Package], webCheckoutUrl: Foundation.URL?)
  #endif
  @objc deinit
}
extension RevenueCat.Offering {
  final public func getMetadataValue<T>(for key: Swift.String, default: T) -> T
  #if compiler(>=5.3) && $NonescapableTypes
  final public func getMetadataValue<T>(for key: Swift.String) -> T? where T : Swift.Decodable
  #endif
}
extension RevenueCat.Offering : Swift.Identifiable {
  final public var id: Swift.String {
    get
  }
  public typealias ID = Swift.String
}
extension RevenueCat.Offering.PaywallComponents : Swift.Sendable {
}
extension RevenueCat.Offering : Swift.Sendable {
}
extension RevenueCat.PaywallComponent {
  final public class ImageComponent : RevenueCat.PaywallComponentBase {
    final public let visible: Swift.Bool?
    final public let source: RevenueCat.PaywallComponent.ThemeImageUrls
    final public let size: RevenueCat.PaywallComponent.Size
    final public let overrideSourceLid: RevenueCat.PaywallComponent.LocalizationKey?
    final public let fitMode: RevenueCat.PaywallComponent.FitMode
    final public let maskShape: RevenueCat.PaywallComponent.MaskShape?
    final public let colorOverlay: RevenueCat.PaywallComponent.ColorScheme?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialImageComponent>?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(visible: Swift.Bool? = nil, source: RevenueCat.PaywallComponent.ThemeImageUrls, size: RevenueCat.PaywallComponent.Size = .init(width: .fill, height: .fit), overrideSourceLid: RevenueCat.PaywallComponent.LocalizationKey? = nil, fitMode: RevenueCat.PaywallComponent.FitMode = .fit, maskShape: RevenueCat.PaywallComponent.MaskShape? = nil, colorOverlay: RevenueCat.PaywallComponent.ColorScheme? = nil, padding: RevenueCat.PaywallComponent.Padding? = nil, margin: RevenueCat.PaywallComponent.Padding? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil, overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialImageComponent>? = nil)
    #endif
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.ImageComponent, rhs: RevenueCat.PaywallComponent.ImageComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class PartialImageComponent : RevenueCat.PaywallPartialComponent {
    final public let visible: Swift.Bool?
    final public let source: RevenueCat.PaywallComponent.ThemeImageUrls?
    final public let size: RevenueCat.PaywallComponent.Size?
    final public let overrideSourceLid: RevenueCat.PaywallComponent.LocalizationKey?
    final public let maskShape: RevenueCat.PaywallComponent.MaskShape?
    final public let fitMode: RevenueCat.PaywallComponent.FitMode?
    final public let colorOverlay: RevenueCat.PaywallComponent.ColorScheme?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(visible: Swift.Bool? = true, source: RevenueCat.PaywallComponent.ThemeImageUrls? = nil, size: RevenueCat.PaywallComponent.Size? = nil, overrideSourceLid: RevenueCat.PaywallComponent.LocalizationKey? = nil, fitMode: RevenueCat.PaywallComponent.FitMode? = nil, maskShape: RevenueCat.PaywallComponent.MaskShape? = nil, colorOverlay: RevenueCat.PaywallComponent.ColorScheme? = nil, padding: RevenueCat.PaywallComponent.Padding? = nil, margin: RevenueCat.PaywallComponent.Padding? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil)
    #endif
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PartialImageComponent, rhs: RevenueCat.PaywallComponent.PartialImageComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
public enum ExitOfferType : Swift.String, Swift.Codable, Swift.Sendable {
  case dismiss
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum PaywallEvent {
  public typealias ID = Foundation.UUID
  public typealias SessionID = Foundation.UUID
  case impression(RevenueCat.PaywallEvent.CreationData, RevenueCat.PaywallEvent.Data)
  case cancel(RevenueCat.PaywallEvent.CreationData, RevenueCat.PaywallEvent.Data)
  case close(RevenueCat.PaywallEvent.CreationData, RevenueCat.PaywallEvent.Data)
  case exitOffer(RevenueCat.PaywallEvent.CreationData, RevenueCat.PaywallEvent.Data, RevenueCat.PaywallEvent.ExitOfferData)
  case purchaseInitiated(RevenueCat.PaywallEvent.CreationData, RevenueCat.PaywallEvent.Data)
  case purchaseError(RevenueCat.PaywallEvent.CreationData, RevenueCat.PaywallEvent.Data)
}
extension RevenueCat.PaywallEvent {
  public struct CreationData {
    public var id: RevenueCat.PaywallEvent.ID
    public var date: Foundation.Date
    public init(id: RevenueCat.PaywallEvent.ID = .init(), date: Foundation.Date = .init())
  }
}
extension RevenueCat.PaywallEvent {
  public struct Data {
    public var paywallIdentifier: Swift.String?
    public var offeringIdentifier: Swift.String
    public var paywallRevision: Swift.Int
    public var sessionIdentifier: RevenueCat.PaywallEvent.SessionID
    public var displayMode: RevenueCat.PaywallViewMode
    public var localeIdentifier: Swift.String
    public var darkMode: Swift.Bool
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    public init(offering: RevenueCat.Offering, paywallComponentsData: RevenueCat.PaywallComponentsData, sessionID: RevenueCat.PaywallEvent.SessionID, displayMode: RevenueCat.PaywallViewMode, locale: Foundation.Locale, darkMode: Swift.Bool)
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    public init(offering: RevenueCat.Offering, paywall: RevenueCat.PaywallData, sessionID: RevenueCat.PaywallEvent.SessionID, displayMode: RevenueCat.PaywallViewMode, locale: Foundation.Locale, darkMode: Swift.Bool)
  }
}
extension RevenueCat.PaywallEvent {
  public struct ExitOfferData {
    public var exitOfferType: RevenueCat.ExitOfferType
    public var exitOfferingIdentifier: Swift.String
    public init(exitOfferType: RevenueCat.ExitOfferType, exitOfferingIdentifier: Swift.String)
  }
}
extension RevenueCat.PaywallEvent {
  public var creationData: RevenueCat.PaywallEvent.CreationData {
    get
  }
  public var data: RevenueCat.PaywallEvent.Data {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var exitOfferData: RevenueCat.PaywallEvent.ExitOfferData? {
    get
  }
  #endif
}
extension RevenueCat.PaywallEvent.CreationData : Swift.Equatable, Swift.Codable, Swift.Sendable {
  public static func == (a: RevenueCat.PaywallEvent.CreationData, b: RevenueCat.PaywallEvent.CreationData) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallEvent.Data : Swift.Equatable, Swift.Codable, Swift.Sendable {
  public static func == (a: RevenueCat.PaywallEvent.Data, b: RevenueCat.PaywallEvent.Data) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallEvent.ExitOfferData : Swift.Equatable, Swift.Codable, Swift.Sendable {
  public static func == (a: RevenueCat.PaywallEvent.ExitOfferData, b: RevenueCat.PaywallEvent.ExitOfferData) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallEvent : Swift.Equatable, Swift.Codable, Swift.Sendable {
  public static func == (a: RevenueCat.PaywallEvent, b: RevenueCat.PaywallEvent) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
infix operator ??? : DefaultPrecedence
@objc(RCVirtualCurrencies) final public class VirtualCurrencies : ObjectiveC.NSObject, Swift.Codable {
  @objc final public let all: [Swift.String : RevenueCat.VirtualCurrency]
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public subscript(key: Swift.String) -> RevenueCat.VirtualCurrency? {
    @objc get
  }
  #endif
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.VirtualCurrencies : Swift.Sendable {
}
extension RevenueCat.VirtualCurrencies {
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  #endif
}
@_hasMissingDesignatedInitializers @objc(RCOfferings) final public class Offerings : ObjectiveC.NSObject {
  @objc final public let all: [Swift.String : RevenueCat.Offering]
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var current: RevenueCat.Offering? {
    @objc get
  }
  #endif
  @objc deinit
}
extension RevenueCat.Offerings : Swift.Sendable {
}
extension RevenueCat.Offerings {
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func offering(identifier: Swift.String?) -> RevenueCat.Offering?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public subscript(key: Swift.String) -> RevenueCat.Offering? {
    @objc get
  }
  #endif
  @objc override final public var description: Swift.String {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc(currentOfferingForPlacement:) final public func currentOffering(forPlacement placementIdentifier: Swift.String) -> RevenueCat.Offering?
  #endif
}
extension RevenueCat.Purchases {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  final public func beginRefundRequest(forProduct productID: Swift.String, completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  final public func beginRefundRequest(forEntitlement entitlementID: Swift.String, completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  final public func beginRefundRequestForActiveEntitlement(completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  #endif
  @available(iOS 16.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  final public func showStoreMessages(for types: Swift.Set<RevenueCat.StoreMessageType> = Set(StoreMessageType.allCases), completion: @escaping () -> Swift.Void)
}
@_hasMissingDesignatedInitializers @objc(RCStorefront) final public class Storefront : ObjectiveC.NSObject {
  @objc final public var countryCode: Swift.String {
    @objc get
  }
  @objc final public var identifier: Swift.String {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  #endif
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.Storefront : Swift.Sendable {
}
extension RevenueCat.Storefront {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, macCatalyst 13.1, *)
  public static var currentStorefront: RevenueCat.Storefront? {
    get async
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, macCatalyst 13.1, *)
  @available(swift, obsoleted: 0.0.1, renamed: "currentStorefront")
  @objc public static var sk1CurrentStorefront: RevenueCat.Storefront? {
    @objc get
  }
  #endif
}
extension RevenueCat.Storefront {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, macCatalyst 13.1, *)
  @objc final public var sk1Storefront: StoreKit.SKStorefront? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  final public var sk2Storefront: StoreKit.Storefront? {
    get
  }
  #endif
}
@_hasMissingDesignatedInitializers @objc(RCWinBackOffer) final public class WinBackOffer : ObjectiveC.NSObject, Swift.Sendable {
  @objc final public let discount: RevenueCat.StoreProductDiscount
  @objc deinit
}
@objc(RCVerificationResult) public enum VerificationResult : Swift.Int {
  case notRequested = 0
  case verified = 1
  case verifiedOnDevice = 3
  case failed = 2
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.VerificationResult : Swift.Sendable, Swift.Codable {
}
extension RevenueCat.VerificationResult {
  public var isVerified: Swift.Bool {
    get
  }
}
extension RevenueCat.VerificationResult : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers @objc(RCAttribution) final public class Attribution : ObjectiveC.NSObject {
  @objc deinit
}
@available(iOS 14.3, macOS 11.1, macCatalyst 14.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension RevenueCat.Attribution {
  @objc final public func enableAdServicesAttributionTokenCollection()
}
extension RevenueCat.Attribution {
  @objc final public func collectDeviceIdentifiers()
  @objc final public func setAttributes(_ attributes: [Swift.String : Swift.String])
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setEmail(_ email: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setPhoneNumber(_ phoneNumber: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setDisplayName(_ displayName: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setPushToken(_ pushToken: Foundation.Data?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setPushTokenString(_ pushToken: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setAdjustID(_ adjustID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setAppsflyerID(_ appsflyerID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setFBAnonymousID(_ fbAnonymousID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setMparticleID(_ mparticleID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setOnesignalID(_ onesignalID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setOnesignalUserID(_ onesignalUserID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setAirshipChannelID(_ airshipChannelID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setCleverTapID(_ cleverTapID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setAirbridgeDeviceID(_ airbridgeDeviceID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setKochavaDeviceID(_ kochavaDeviceID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setSolarEngineDistinctId(_ solarEngineDistinctId: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setSolarEngineAccountId(_ solarEngineAccountId: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setSolarEngineVisitorId(_ solarEngineVisitorId: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setMixpanelDistinctID(_ mixpanelDistinctID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setFirebaseAppInstanceID(_ firebaseAppInstanceID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setTenjinAnalyticsInstallationID(_ tenjinAnalyticsInstallationID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setPostHogUserID(_ postHogUserID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setAmplitudeUserID(_ amplitudeUserID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setAmplitudeDeviceID(_ amplitudeDeviceID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setMediaSource(_ mediaSource: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setCampaign(_ campaign: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setAdGroup(_ adGroup: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setAd(_ installAd: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setKeyword(_ keyword: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setCreative(_ creative: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func setAppsFlyerConversionData(_ data: [Swift.AnyHashable : Any]?)
  #endif
}
extension RevenueCat.Attribution : @unchecked Swift.Sendable {
}
extension RevenueCat.StoreProduct {
  @objc(RCStoreProductCategory) public enum ProductCategory : Swift.Int {
    case subscription
    case nonSubscription
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(RCStoreProductType) public enum ProductType : Swift.Int {
    case consumable
    case nonConsumable
    case nonRenewableSubscription
    case autoRenewableSubscription
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension RevenueCat.StoreProduct.ProductCategory : Swift.Sendable {
}
extension RevenueCat.StoreProduct.ProductType : Swift.Sendable {
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension _StoreKit_SwiftUI.StoreView {
  @_Concurrency.MainActor @preconcurrency public static func forOffering(_ offering: RevenueCat.Offering, prefersPromotionalIcon: Swift.Bool = false, @SwiftUICore.ViewBuilder icon: @escaping (StoreKit.Product) -> Icon, @SwiftUICore.ViewBuilder placeholderIcon: () -> PlaceholderIcon) -> some SwiftUICore.View
  
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension _StoreKit_SwiftUI.StoreView where Icon == SwiftUICore.EmptyView, PlaceholderIcon == SwiftUICore.EmptyView {
  @_Concurrency.MainActor @preconcurrency public static func forOffering(_ offering: RevenueCat.Offering, prefersPromotionalIcon: Swift.Bool = false) -> some SwiftUICore.View
  
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension _StoreKit_SwiftUI.SubscriptionStoreView {
  @_Concurrency.MainActor @preconcurrency public static func forOffering(_ offering: RevenueCat.Offering, @SwiftUICore.ViewBuilder marketingContent: () -> Content) -> some SwiftUICore.View
  
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension _StoreKit_SwiftUI.SubscriptionStoreView where Content == _StoreKit_SwiftUI.AutomaticSubscriptionStoreMarketingContent {
  @_Concurrency.MainActor @preconcurrency public static func forOffering(_ offering: RevenueCat.Offering) -> some SwiftUICore.View
  
}
@_hasMissingDesignatedInitializers @objc(RCWebPurchaseRedemption) final public class WebPurchaseRedemption : ObjectiveC.NSObject {
  @objc deinit
}
extension RevenueCat.Purchases {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, obsoleted: 1, renamed: "restorePurchases(completion:)")
  @available(tvOS, obsoleted: 1, renamed: "restorePurchases(completion:)")
  @available(watchOS, obsoleted: 1, renamed: "restorePurchases(completion:)")
  @available(macOS, obsoleted: 1, renamed: "restorePurchases(completion:)")
  @objc(restoreTransactionsWithCompletionBlock:) final public func restoreTransactions(completion: ((RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)? = nil)
  #endif
  @available(iOS, unavailable, introduced: 13.0, renamed: "restorePurchases()")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "restorePurchases()")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "restorePurchases()")
  @available(macOS, unavailable, introduced: 10.15, renamed: "restorePurchases()")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "restorePurchases()")
  final public func restoreTransactions() throws -> RevenueCat.CustomerInfo
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(tvOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(watchOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(macOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @objc final public func customerInfo(completion: @escaping (RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(tvOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(watchOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(macOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @objc(purchaserInfoWithCompletionBlock:) final public func purchaserInfo(completion: @escaping (RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)
  #endif
  @available(iOS, unavailable, introduced: 13.0, renamed: "customerInfo()")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "customerInfo()")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "customerInfo()")
  @available(macOS, unavailable, introduced: 10.15, renamed: "customerInfo()")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "customerInfo()")
  final public func purchaserInfo() throws -> RevenueCat.CustomerInfo
  @available(iOS, obsoleted: 1, renamed: "getProducts(_:completion:)")
  @available(tvOS, obsoleted: 1, renamed: "getProducts(_:completion:)")
  @available(watchOS, obsoleted: 1, renamed: "getProducts(_:completion:)")
  @available(macOS, obsoleted: 1, renamed: "getProducts(_:completion:)")
  @objc(productsWithIdentifiers:completionBlock:) final public func products(_ productIdentifiers: [Swift.String], completion: @escaping ([StoreKit.SKProduct]) -> Swift.Void)
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, obsoleted: 1, renamed: "getOfferings(completion:)")
  @available(tvOS, obsoleted: 1, renamed: "getOfferings(completion:)")
  @available(watchOS, obsoleted: 1, renamed: "getOfferings(completion:)")
  @available(macOS, obsoleted: 1, renamed: "getOfferings(completion:)")
  @objc(offeringsWithCompletionBlock:) final public func offerings(completion: @escaping (RevenueCat.Offerings?, (any Swift.Error)?) -> Swift.Void)
  #endif
  @available(iOS, obsoleted: 1, renamed: "purchase(package:completion:)")
  @available(tvOS, obsoleted: 1, renamed: "purchase(package:completion:)")
  @available(watchOS, obsoleted: 1, renamed: "purchase(package:completion:)")
  @available(macOS, obsoleted: 1, renamed: "purchase(package:completion:)")
  @objc(purchasePackage:withCompletionBlock:) final public func purchasePackage(_ package: RevenueCat.Package, _ completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(package:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(package:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(package:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(package:)")
  final public func purchasePackage(_ package: RevenueCat.Package) throws -> RevenueCat.PurchaseResultData
  @available(iOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(tvOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macOS, unavailable, introduced: 10.14.4, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:completion:)")
  @objc(purchasePackage:withDiscount:completionBlock:) final public func purchasePackage(_ package: RevenueCat.Package, discount: StoreKit.SKPaymentDiscount, _ completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(package:promotionalOffer:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  final public func purchasePackage(_ package: RevenueCat.Package, discount: StoreKit.SKPaymentDiscount) throws -> RevenueCat.PurchaseResultData
  @available(iOS, obsoleted: 1, renamed: "purchase(product:_:)")
  @available(tvOS, obsoleted: 1, renamed: "purchase(product:_:)")
  @available(watchOS, obsoleted: 1, renamed: "purchase(product:_:)")
  @available(macOS, obsoleted: 1, renamed: "purchase(product:_:)")
  @objc(purchaseProduct:withCompletionBlock:) final public func purchaseProduct(_ product: StoreKit.SKProduct, _ completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(product:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(product:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(product:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(product:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(product:)")
  final public func purchaseProduct(_ product: StoreKit.SKProduct) throws
  @available(iOS, unavailable, introduced: 12.2, renamed: "purchase(product:promotionalOffer:completion:)")
  @available(tvOS, unavailable, introduced: 12.2, renamed: "purchase(product:promotionalOffer:completion:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(product:promotionalOffer:completion:)")
  @available(macOS, unavailable, introduced: 10.14.4, renamed: "purchase(product:promotionalOffer:completion:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(product:promotionalOffer:completion:)")
  @objc(purchaseProduct:withDiscount:completionBlock:) final public func purchaseProduct(_ product: StoreKit.SKProduct, discount: StoreKit.SKPaymentDiscount, _ completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(product:promotionalOffer:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(product:promotionalOffer:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(product:promotionalOffer:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(product:promotionalOffer:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(product:promotionalOffer:)")
  final public func purchaseProduct(_ product: StoreKit.SKProduct, discount: StoreKit.SKPaymentDiscount) throws
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(package:promotionalOffer:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  final public func purchase(package: RevenueCat.Package, discount: RevenueCat.StoreProductDiscount) throws -> RevenueCat.PurchaseResultData
  @available(iOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(tvOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macOS, unavailable, introduced: 10.14.4, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macCatalyst, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  final public func purchase(package: RevenueCat.Package, discount: RevenueCat.StoreProductDiscount, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(package:promotionalOffer:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  final public func purchase(product: RevenueCat.StoreProduct, discount: RevenueCat.StoreProductDiscount) throws -> RevenueCat.PurchaseResultData
  @available(iOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(tvOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macOS, unavailable, introduced: 10.14.4, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macCatalyst, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  final public func purchase(product: RevenueCat.StoreProduct, discount: RevenueCat.StoreProductDiscount, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @available(iOS, unavailable, introduced: 13.0, renamed: "getPromotionalOffer(forProductDiscount:product:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "getPromotionalOffer(forProductDiscount:product:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "getPromotionalOffer(forProductDiscount:product:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "getPromotionalOffer(forProductDiscount:product:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "getPromotionalOffer(forProductDiscount:product:)")
  final public func checkPromotionalDiscountEligibility(forProductDiscount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct)
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, unavailable, introduced: 12.2, renamed: "getPromotionalOffer(forProductDiscount:product:completion:)")
  @available(tvOS, unavailable, introduced: 12.2, renamed: "getPromotionalOffer(forProductDiscount:product:completion:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "getPromotionalOffer(forProductDiscount:product:completion:)")
  @available(macOS, unavailable, introduced: 10.14.4, renamed: "getPromotionalOffer(forProductDiscount:product:completion:)")
  @available(macCatalyst, unavailable, introduced: 12.2, renamed: "getPromotionalOffer(forProductDiscount:product:completion:)")
  final public func checkPromotionalDiscountEligibility(forProductDiscount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct, completion: @escaping (Swift.AnyObject, (any Swift.Error)?) -> Swift.Void)
  #endif
  @available(iOS, obsoleted: 1, renamed: "invalidateCustomerInfoCache")
  @available(tvOS, obsoleted: 1, renamed: "invalidateCustomerInfoCache")
  @available(watchOS, obsoleted: 1, renamed: "invalidateCustomerInfoCache")
  @available(macOS, obsoleted: 1, renamed: "invalidateCustomerInfoCache")
  @available(macCatalyst, obsoleted: 1, renamed: "invalidateCustomerInfoCache")
  @objc final public func invalidatePurchaserInfoCache()
  @available(iOS, obsoleted: 1, renamed: "checkTrialOrIntroDiscountEligibility(_:completion:)")
  @available(tvOS, obsoleted: 1, renamed: "checkTrialOrIntroDiscountEligibility(_:completion:)")
  @available(watchOS, obsoleted: 1, renamed: "checkTrialOrIntroDiscountEligibility(_:completion:)")
  @available(macOS, obsoleted: 1, renamed: "checkTrialOrIntroDiscountEligibility(_:completion:)")
  @available(macCatalyst, obsoleted: 1, renamed: "checkTrialOrIntroDiscountEligibility(_:completion:)")
  @objc(checkTrialOrIntroductoryPriceEligibility:completion:) final public func checkTrialOrIntroductoryPriceEligibility(_ productIdentifiers: [Swift.String], completion: @escaping ([Swift.String : RevenueCat.IntroEligibility]) -> Swift.Void)
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, unavailable, introduced: 12.2, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(tvOS, unavailable, introduced: 12.2, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(watchOS, unavailable, introduced: 6.2, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(macOS, unavailable, introduced: 10.14.4, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(macCatalyst, unavailable, introduced: 13.0, message: "Check eligibility for a discount using getPromotionalOffer:")
  @objc(paymentDiscountForProductDiscount:product:completion:) final public func paymentDiscount(for discount: StoreKit.SKProductDiscount, product: StoreKit.SKProduct, completion: @escaping (StoreKit.SKPaymentDiscount?, (any Swift.Error)?) -> Swift.Void)
  #endif
  @available(iOS, unavailable, introduced: 13.0, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(tvOS, unavailable, introduced: 13.0, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(watchOS, unavailable, introduced: 6.2, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(macOS, unavailable, introduced: 10.15, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(macCatalyst, unavailable, introduced: 13.0, message: "Check eligibility for a discount using getPromotionalOffer:")
  final public func paymentDiscount(for discount: StoreKit.SKProductDiscount, product: StoreKit.SKProduct) throws -> StoreKit.SKPaymentDiscount
  @available(iOS, obsoleted: 1, message: "This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`")
  @available(tvOS, obsoleted: 1, message: "This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`")
  @available(watchOS, obsoleted: 1, message: "This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`")
  @available(macOS, obsoleted: 1, message: "This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`")
  @available(macCatalyst, obsoleted: 1, message: "This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`")
  @objc final public func shouldPurchasePromoProduct(_ product: RevenueCat.StoreProduct, defermentBlock: @escaping RevenueCat.StartPurchaseBlock)
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, obsoleted: 1, renamed: "logIn")
  @available(tvOS, obsoleted: 1, renamed: "logIn")
  @available(watchOS, obsoleted: 1, renamed: "logIn")
  @available(macOS, obsoleted: 1, renamed: "logIn")
  @objc(createAlias:completionBlock:) final public func createAlias(_ alias: Swift.String, _ completion: ((RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, obsoleted: 1, renamed: "logIn")
  @available(tvOS, obsoleted: 1, renamed: "logIn")
  @available(watchOS, obsoleted: 1, renamed: "logIn")
  @available(macOS, obsoleted: 1, renamed: "logIn")
  @objc(identify:completionBlock:) final public func identify(_ appUserID: Swift.String, _ completion: ((RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, obsoleted: 1, renamed: "logOut")
  @available(tvOS, obsoleted: 1, renamed: "logOut")
  @available(watchOS, obsoleted: 1, renamed: "logOut")
  @available(macOS, obsoleted: 1, renamed: "logOut")
  @objc(resetWithCompletionBlock:) final public func reset(completion: ((RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting purchasesAreCompletedBy.")
  @available(tvOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting purchasesAreCompletedBy.")
  @available(watchOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting purchasesAreCompletedBy.")
  @available(macOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting purchasesAreCompletedBy.")
  @discardableResult
  @objc(configureWithAPIKey:appUserID:observerMode:) @_disfavoredOverload public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.String?, observerMode: Swift.Bool) -> RevenueCat.Purchases
  #endif
  @available(iOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting purchasesAreCompletedBy.")
  @available(tvOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting purchasesAreCompletedBy.")
  @available(watchOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting purchasesAreCompletedBy.")
  @available(macOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting purchasesAreCompletedBy.")
  @discardableResult
  public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.StaticString, observerMode: Swift.Bool) -> RevenueCat.Purchases
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting\npurchasesAreCompletedBy. Please use the Configuration.Builder class to configure the SDK with\ncustom UserDefaults.")
  @available(tvOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting\npurchasesAreCompletedBy. Please use the Configuration.Builder class to configure the SDK with\ncustom UserDefaults.")
  @available(watchOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting\npurchasesAreCompletedBy. Please use the Configuration.Builder class to configure the SDK with\ncustom UserDefaults.")
  @available(macOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting\npurchasesAreCompletedBy. Please use the Configuration.Builder class to configure the SDK with\ncustom UserDefaults.")
  @discardableResult
  @objc(configureWithAPIKey:appUserID:observerMode:userDefaults:) public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.String?, observerMode: Swift.Bool, userDefaults: Foundation.UserDefaults?) -> RevenueCat.Purchases
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, obsoleted: 1, renamed: "configure(with:)")
  @available(tvOS, obsoleted: 1, renamed: "configure(with:)")
  @available(watchOS, obsoleted: 1, renamed: "configure(with:)")
  @available(macOS, obsoleted: 1, renamed: "configure(with:)")
  @available(macCatalyst, obsoleted: 1, renamed: "configure(with:)")
  @discardableResult
  @objc(configureWithAPIKey:appUserID:observerMode:userDefaults:useStoreKit2IfAvailable:) public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.String?, observerMode: Swift.Bool, userDefaults: Foundation.UserDefaults?, useStoreKit2IfAvailable: Swift.Bool) -> RevenueCat.Purchases
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, obsoleted: 1, renamed: "configure(with:)")
  @available(tvOS, obsoleted: 1, renamed: "configure(with:)")
  @available(watchOS, obsoleted: 1, renamed: "configure(with:)")
  @available(macOS, obsoleted: 1, renamed: "configure(with:)")
  @available(macCatalyst, obsoleted: 1, renamed: "configure(with:)")
  @discardableResult
  @objc(configureWithAPIKey:appUserID:observerMode:userDefaults:useStoreKit2IfAvailable:dangerousSettings:) public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.String?, observerMode: Swift.Bool, userDefaults: Foundation.UserDefaults?, useStoreKit2IfAvailable: Swift.Bool, dangerousSettings: RevenueCat.DangerousSettings?) -> RevenueCat.Purchases
  #endif
  @available(iOS, obsoleted: 1, renamed: "Purchases.shared.attribution.enableAdServicesAttributionTokenCollection()", message: "Use Purchases.shared.attribution.enableAdServicesAttributionTokenCollection() instead.\nAdClient doesn't work after February 7, 2023  so this boolean doesn't have any effect.")
  @available(tvOS, obsoleted: 1, renamed: "Purchases.shared.attribution.enableAdServicesAttributionTokenCollection()", message: "Use Purchases.shared.attribution.enableAdServicesAttributionTokenCollection() instead.\nAdClient doesn't work after February 7, 2023  so this boolean doesn't have any effect.")
  @available(watchOS, obsoleted: 1, renamed: "Purchases.shared.attribution.enableAdServicesAttributionTokenCollection()", message: "Use Purchases.shared.attribution.enableAdServicesAttributionTokenCollection() instead.\nAdClient doesn't work after February 7, 2023  so this boolean doesn't have any effect.")
  @available(macOS, obsoleted: 1, renamed: "Purchases.shared.attribution.enableAdServicesAttributionTokenCollection()", message: "Use Purchases.shared.attribution.enableAdServicesAttributionTokenCollection() instead.\nAdClient doesn't work after February 7, 2023  so this boolean doesn't have any effect.")
  @objc public static var automaticAppleSearchAdsAttributionCollection: Swift.Bool {
    @objc get
    @objc set
  }
}
@available(iOS, obsoleted: 1, renamed: "StartPurchaseBlock")
@available(tvOS, obsoleted: 1, renamed: "StartPurchaseBlock")
@available(watchOS, obsoleted: 1, renamed: "StartPurchaseBlock")
@available(macOS, obsoleted: 1, renamed: "StartPurchaseBlock")
public typealias DeferredPromotionalPurchaseBlock = RevenueCat.StartPurchaseBlock
@_inheritsConvenienceInitializers @available(iOS, obsoleted: 1, renamed: "CustomerInfo")
@available(tvOS, obsoleted: 1, renamed: "CustomerInfo")
@available(watchOS, obsoleted: 1, renamed: "CustomerInfo")
@available(macOS, obsoleted: 1, renamed: "CustomerInfo")
@objc(RCPurchaserInfo) public class PurchaserInfo : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @available(iOS, obsoleted: 1, renamed: "StoreTransaction")
@available(tvOS, obsoleted: 1, renamed: "StoreTransaction")
@available(watchOS, obsoleted: 1, renamed: "StoreTransaction")
@available(macOS, obsoleted: 1, renamed: "StoreTransaction")
@objc(RCTransaction) public class Transaction : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
extension RevenueCat.StoreTransaction {
  @available(iOS, obsoleted: 1, renamed: "productIdentifier")
  @available(tvOS, obsoleted: 1, renamed: "productIdentifier")
  @available(watchOS, obsoleted: 1, renamed: "productIdentifier")
  @available(macOS, obsoleted: 1, renamed: "productIdentifier")
  @objc final public var productId: Swift.String {
    @objc get
  }
  @available(iOS, obsoleted: 1, renamed: "transactionIdentifier")
  @available(tvOS, obsoleted: 1, renamed: "transactionIdentifier")
  @available(watchOS, obsoleted: 1, renamed: "transactionIdentifier")
  @available(macOS, obsoleted: 1, renamed: "transactionIdentifier")
  @objc final public var revenueCatId: Swift.String {
    @objc get
  }
}
extension RevenueCat.Package {
  @available(iOS, obsoleted: 1, renamed: "storeProduct", message: "Use StoreProduct instead")
  @available(tvOS, obsoleted: 1, renamed: "storeProduct", message: "Use StoreProduct instead")
  @available(watchOS, obsoleted: 1, renamed: "storeProduct", message: "Use StoreProduct instead")
  @available(macOS, obsoleted: 1, renamed: "storeProduct", message: "Use StoreProduct instead")
  @available(macCatalyst, obsoleted: 1, renamed: "storeProduct", message: "Use StoreProduct instead")
  @objc final public var product: StoreKit.SKProduct {
    @objc get
  }
}
extension RevenueCat.StoreProductDiscount.PaymentMode {
  @available(iOS, obsoleted: 1, message: "This option no longer exists. PaymentMode would be nil instead.")
  @available(tvOS, obsoleted: 1, message: "This option no longer exists. PaymentMode would be nil instead.")
  @available(watchOS, obsoleted: 1, message: "This option no longer exists. PaymentMode would be nil instead.")
  @available(macOS, obsoleted: 1, message: "This option no longer exists. PaymentMode would be nil instead.")
  @available(macCatalyst, obsoleted: 1, message: "This option no longer exists. PaymentMode would be nil instead.")
  public static var none: RevenueCat.StoreProductDiscount.PaymentMode {
    get
  }
}
@available(iOS, obsoleted: 1, renamed: "StoreProductDiscount.PaymentMode")
@available(tvOS, obsoleted: 1, renamed: "StoreProductDiscount.PaymentMode")
@available(watchOS, obsoleted: 1, renamed: "StoreProductDiscount.PaymentMode")
@available(macOS, obsoleted: 1, renamed: "StoreProductDiscount.PaymentMode")
@available(macCatalyst, obsoleted: 1, renamed: "StoreProductDiscount.PaymentMode")
public enum RCPaymentMode {
}
@_inheritsConvenienceInitializers @available(iOS, obsoleted: 1, message: "Use PromotionalOffer instead")
@available(tvOS, obsoleted: 1, message: "Use PromotionalOffer instead")
@available(watchOS, obsoleted: 1, message: "Use PromotionalOffer instead")
@available(macOS, obsoleted: 1, message: "Use PromotionalOffer instead")
@available(macCatalyst, obsoleted: 1, message: "Use PromotionalOffer instead")
@objc(RCPromotionalOfferEligibility) public class PromotionalOfferEligibility : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(tvOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(watchOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(macOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(macCatalyst, obsoleted: 1, message: "Use ErrorCode instead")
public var ErrorDomain: Foundation.NSErrorDomain {
  get
}
@available(iOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(tvOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(watchOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(macOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(macCatalyst, obsoleted: 1, message: "Use ErrorCode instead")
public enum RCBackendErrorCode {
}
@objc @_inheritsConvenienceInitializers @available(iOS, obsoleted: 1)
@available(tvOS, obsoleted: 1)
@available(watchOS, obsoleted: 1)
@available(macOS, obsoleted: 1)
@available(macCatalyst, obsoleted: 1)
public class RCPurchasesErrorUtils : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
extension RevenueCat.Purchases {
  @available(iOS, obsoleted: 1, renamed: "ErrorCode")
  @available(tvOS, obsoleted: 1, renamed: "ErrorCode")
  @available(watchOS, obsoleted: 1, renamed: "ErrorCode")
  @available(macOS, obsoleted: 1, renamed: "ErrorCode")
  @available(macCatalyst, obsoleted: 1, renamed: "ErrorCode")
  public enum Errors {
  }
  @available(iOS, obsoleted: 1)
  @available(tvOS, obsoleted: 1)
  @available(watchOS, obsoleted: 1)
  @available(macOS, obsoleted: 1)
  @available(macCatalyst, obsoleted: 1)
  public enum FinishableKey {
  }
  @available(iOS, obsoleted: 1)
  @available(tvOS, obsoleted: 1)
  @available(watchOS, obsoleted: 1)
  @available(macOS, obsoleted: 1)
  @available(macCatalyst, obsoleted: 1)
  public enum ReadableErrorCodeKey {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum ErrorCode {
  }
  @available(iOS, obsoleted: 1)
  @available(tvOS, obsoleted: 1)
  @available(watchOS, obsoleted: 1)
  @available(macOS, obsoleted: 1)
  @available(macCatalyst, obsoleted: 1)
  public enum RevenueCatBackendErrorCode {
  }
  @available(iOS, obsoleted: 1, renamed: "StoreTransaction")
  @available(tvOS, obsoleted: 1, renamed: "StoreTransaction")
  @available(watchOS, obsoleted: 1, renamed: "StoreTransaction")
  @available(macOS, obsoleted: 1, renamed: "StoreTransaction")
  @available(macCatalyst, obsoleted: 1, renamed: "StoreTransaction")
  public enum Transaction {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum EntitlementInfo {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum EntitlementInfos {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum PackageType {
  }
  @available(iOS, obsoleted: 1, renamed: "CustomerInfo")
  @available(tvOS, obsoleted: 1, renamed: "CustomerInfo")
  @available(watchOS, obsoleted: 1, renamed: "CustomerInfo")
  @available(macOS, obsoleted: 1, renamed: "CustomerInfo")
  @available(macCatalyst, obsoleted: 1, renamed: "CustomerInfo")
  public enum PurchaserInfo {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum Offering {
  }
  @available(iOS, obsoleted: 1)
  @available(tvOS, obsoleted: 1)
  @available(watchOS, obsoleted: 1)
  @available(macOS, obsoleted: 1)
  @available(macCatalyst, obsoleted: 1)
  public enum ErrorUtils {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum Store {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum PeriodType {
  }
}
extension RevenueCat.Configuration.Builder {
  @available(iOS, obsoleted: 1, renamed: "with(purchasesAreCompletedBy:storeKitVersion:)", message: "Observer Mode is now named PurchasesAreCompletedBy.")
  @available(tvOS, obsoleted: 1, renamed: "with(purchasesAreCompletedBy:storeKitVersion:)", message: "Observer Mode is now named PurchasesAreCompletedBy.")
  @available(watchOS, obsoleted: 1, renamed: "with(purchasesAreCompletedBy:storeKitVersion:)", message: "Observer Mode is now named PurchasesAreCompletedBy.")
  @available(macOS, obsoleted: 1, renamed: "with(purchasesAreCompletedBy:storeKitVersion:)", message: "Observer Mode is now named PurchasesAreCompletedBy.")
  @objc dynamic public func with(observerMode: Swift.Bool) -> RevenueCat.Configuration.Builder
}
@_hasMissingDesignatedInitializers @objc(RCPromotionalOffer) final public class PromotionalOffer : ObjectiveC.NSObject {
  @objc final public let discount: RevenueCat.StoreProductDiscount
  @objc final public let signedData: RevenueCat.PromotionalOffer.SignedData
  @objc deinit
}
extension RevenueCat.PromotionalOffer : Swift.Sendable {
}
@objc extension RevenueCat.PromotionalOffer {
  @_hasMissingDesignatedInitializers @objc(RCPromotionalOfferSignedData) final public class SignedData : ObjectiveC.NSObject {
    @objc final public let identifier: Swift.String
    @objc final public let keyIdentifier: Swift.String
    @objc final public let nonce: Foundation.UUID
    @objc final public let signature: Swift.String
    @objc final public let timestamp: Swift.Int
    #if compiler(>=5.3) && $NonescapableTypes
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    #endif
    public static func == (lhs: RevenueCat.PromotionalOffer.SignedData, rhs: RevenueCat.PromotionalOffer.SignedData) -> Swift.Bool
    @objc deinit
  }
}
extension RevenueCat.PromotionalOffer.SignedData : Swift.Sendable {
}
public struct PaywallData {
  public var id: Swift.String?
  public var templateName: Swift.String
  public var config: RevenueCat.PaywallData.Configuration
  public var assetBaseURL: Foundation.URL
  public var revision: Swift.Int {
    get
    set
  }
  public var zeroDecimalPlaceCountries: [Swift.String] {
    get
  }
  public var defaultLocale: Swift.String?
  public var exitOffers: RevenueCat.ExitOffers?
}
public protocol PaywallLocalizedConfiguration {
  var title: Swift.String { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var subtitle: Swift.String? { get }
  #endif
  var callToAction: Swift.String { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var callToActionWithIntroOffer: Swift.String? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var offerDetails: Swift.String? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var offerDetailsWithIntroOffer: Swift.String? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var offerName: Swift.String? { get }
  #endif
  var features: [RevenueCat.PaywallData.LocalizedConfiguration.Feature] { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var tierName: Swift.String? { get }
  #endif
}
extension RevenueCat.PaywallData {
  public struct ZeroDecimalPlaceCountries : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public var apple: [Swift.String]
    public init(apple: [Swift.String])
    public static func == (a: RevenueCat.PaywallData.ZeroDecimalPlaceCountries, b: RevenueCat.PaywallData.ZeroDecimalPlaceCountries) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension RevenueCat.PaywallData {
  public struct LocalizedConfiguration : RevenueCat.PaywallLocalizedConfiguration {
    public var title: Swift.String
    public var callToAction: Swift.String
    #if compiler(>=5.3) && $NonescapableTypes
    public var subtitle: Swift.String? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var callToActionWithIntroOffer: Swift.String? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var offerDetails: Swift.String? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var offerDetailsWithIntroOffer: Swift.String? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var offerName: Swift.String? {
      get
      set
    }
    #endif
    public var offerOverrides: [Swift.String : RevenueCat.PaywallData.LocalizedConfiguration.OfferOverride] {
      get
      set
    }
    public var features: [RevenueCat.PaywallData.LocalizedConfiguration.Feature] {
      get
      set
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public var tierName: Swift.String? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init(title: Swift.String, subtitle: Swift.String? = nil, callToAction: Swift.String, callToActionWithIntroOffer: Swift.String? = nil, offerDetails: Swift.String? = nil, offerDetailsWithIntroOffer: Swift.String? = nil, offerName: Swift.String? = nil, offerOverrides: [Swift.String : RevenueCat.PaywallData.LocalizedConfiguration.OfferOverride] = [:], features: [RevenueCat.PaywallData.LocalizedConfiguration.Feature] = [], tierName: Swift.String? = nil)
    #endif
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public func config(for requiredLocale: Foundation.Locale) -> RevenueCat.PaywallData.LocalizedConfiguration?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func tiersLocalization(for requiredLocale: Foundation.Locale) -> [Swift.String : RevenueCat.PaywallData.LocalizedConfiguration]?
  #endif
}
extension RevenueCat.PaywallData.LocalizedConfiguration {
  public struct Feature {
    public var title: Swift.String
    public var content: Swift.String?
    public var iconID: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(title: Swift.String, content: Swift.String? = nil, iconID: Swift.String? = nil)
    #endif
  }
}
extension RevenueCat.PaywallData.LocalizedConfiguration {
  public struct OfferOverride {
    public var offerDetails: Swift.String?
    public var offerDetailsWithIntroOffer: Swift.String?
    public var offerName: Swift.String?
    public var offerBadge: Swift.String?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(offerDetails: Swift.String? = nil, offerDetailsWithIntroOffer: Swift.String? = nil, offerName: Swift.String? = nil, offerBadge: Swift.String? = nil)
    #endif
  }
}
extension RevenueCat.PaywallData {
  public struct Configuration {
    public var packages: [Swift.String] {
      get
      set
    }
    public var defaultPackage: Swift.String?
    public var tiers: [RevenueCat.PaywallData.Tier] {
      get
      set
    }
    public var images: RevenueCat.PaywallData.Configuration.Images {
      get
      set
    }
    public var imagesByTier: [Swift.String : RevenueCat.PaywallData.Configuration.Images] {
      get
    }
    public var imagesLowRes: RevenueCat.PaywallData.Configuration.Images {
      get
      set
    }
    public var blurredBackgroundImage: Swift.Bool {
      get
      set
    }
    public var displayRestorePurchases: Swift.Bool {
      get
      set
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public var termsOfServiceURL: Foundation.URL? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var privacyURL: Foundation.URL? {
      get
      set
    }
    #endif
    public var colors: RevenueCat.PaywallData.Configuration.ColorInformation
    public var colorsByTier: [Swift.String : RevenueCat.PaywallData.Configuration.ColorInformation] {
      get
      set
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init(packages: [Swift.String], defaultPackage: Swift.String? = nil, images: RevenueCat.PaywallData.Configuration.Images, imagesLowRes: RevenueCat.PaywallData.Configuration.Images = Images(), colors: RevenueCat.PaywallData.Configuration.ColorInformation, blurredBackgroundImage: Swift.Bool = false, displayRestorePurchases: Swift.Bool = true, termsOfServiceURL: Foundation.URL? = nil, privacyURL: Foundation.URL? = nil)
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init(images: RevenueCat.PaywallData.Configuration.Images, imagesByTier: [Swift.String : RevenueCat.PaywallData.Configuration.Images] = [:], colors: RevenueCat.PaywallData.Configuration.ColorInformation, colorsByTier: [Swift.String : RevenueCat.PaywallData.Configuration.ColorInformation] = [:], tiers: [RevenueCat.PaywallData.Tier], blurredBackgroundImage: Swift.Bool = false, displayRestorePurchases: Swift.Bool = true, termsOfServiceURL: Foundation.URL? = nil, privacyURL: Foundation.URL? = nil)
    #endif
  }
}
extension RevenueCat.PaywallData.Configuration {
  public struct Images {
    #if compiler(>=5.3) && $NonescapableTypes
    public var header: Swift.String? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var background: Swift.String? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var icon: Swift.String? {
      get
      set
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init(header: Swift.String? = nil, background: Swift.String? = nil, icon: Swift.String? = nil)
    #endif
  }
}
extension RevenueCat.PaywallData.Configuration {
  public struct ColorInformation {
    public var light: RevenueCat.PaywallData.Configuration.Colors
    public var dark: RevenueCat.PaywallData.Configuration.Colors?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(light: RevenueCat.PaywallData.Configuration.Colors, dark: RevenueCat.PaywallData.Configuration.Colors? = nil)
    #endif
  }
  public struct Colors {
    public var background: RevenueCat.PaywallColor?
    public var text1: RevenueCat.PaywallColor?
    public var text2: RevenueCat.PaywallColor?
    public var text3: RevenueCat.PaywallColor?
    public var callToActionBackground: RevenueCat.PaywallColor?
    public var callToActionForeground: RevenueCat.PaywallColor?
    public var callToActionSecondaryBackground: RevenueCat.PaywallColor?
    public var accent1: RevenueCat.PaywallColor?
    public var accent2: RevenueCat.PaywallColor?
    public var accent3: RevenueCat.PaywallColor?
    public var closeButton: RevenueCat.PaywallColor?
    public var tierControlBackground: RevenueCat.PaywallColor?
    public var tierControlForeground: RevenueCat.PaywallColor?
    public var tierControlSelectedBackground: RevenueCat.PaywallColor?
    public var tierControlSelectedForeground: RevenueCat.PaywallColor?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(background: RevenueCat.PaywallColor? = nil, text1: RevenueCat.PaywallColor? = nil, text2: RevenueCat.PaywallColor? = nil, text3: RevenueCat.PaywallColor? = nil, callToActionBackground: RevenueCat.PaywallColor? = nil, callToActionForeground: RevenueCat.PaywallColor? = nil, callToActionSecondaryBackground: RevenueCat.PaywallColor? = nil, accent1: RevenueCat.PaywallColor? = nil, accent2: RevenueCat.PaywallColor? = nil, accent3: RevenueCat.PaywallColor? = nil, closeButton: RevenueCat.PaywallColor? = nil, tierControlBackground: RevenueCat.PaywallColor? = nil, tierControlForeground: RevenueCat.PaywallColor? = nil, tierControlSelectedBackground: RevenueCat.PaywallColor? = nil, tierControlSelectedForeground: RevenueCat.PaywallColor? = nil)
    #endif
  }
}
extension RevenueCat.PaywallData {
  public struct Tier {
    public var id: Swift.String
    public var packages: [Swift.String]
    public var defaultPackage: Swift.String
    public init(id: Swift.String, packages: [Swift.String], defaultPackage: Swift.String)
  }
}
extension RevenueCat.PaywallData {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: Swift.String? = nil, templateName: Swift.String, config: RevenueCat.PaywallData.Configuration, localization: RevenueCat.PaywallData.LocalizedConfiguration, assetBaseURL: Foundation.URL, revision: Swift.Int = 0, locale: Foundation.Locale = .current, zeroDecimalPlaceCountries: [Swift.String] = [])
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: Swift.String? = nil, templateName: Swift.String, config: RevenueCat.PaywallData.Configuration, localizationByTier: [Swift.String : RevenueCat.PaywallData.LocalizedConfiguration], assetBaseURL: Foundation.URL, revision: Swift.Int = 0, locale: Foundation.Locale = .current, zeroDecimalPlaceCountries: [Swift.String] = [])
  #endif
}
extension RevenueCat.PaywallData.LocalizedConfiguration.Feature : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.LocalizedConfiguration.OfferOverride : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.LocalizedConfiguration : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.Configuration.ColorInformation : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.Configuration.Colors : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.Configuration.Images : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.Tier : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.Configuration : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.Tier : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData.Tier, b: RevenueCat.PaywallData.Tier) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.LocalizedConfiguration.Feature : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData.LocalizedConfiguration.Feature, b: RevenueCat.PaywallData.LocalizedConfiguration.Feature) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.LocalizedConfiguration.OfferOverride : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData.LocalizedConfiguration.OfferOverride, b: RevenueCat.PaywallData.LocalizedConfiguration.OfferOverride) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.LocalizedConfiguration : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData.LocalizedConfiguration, b: RevenueCat.PaywallData.LocalizedConfiguration) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.Configuration.ColorInformation : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData.Configuration.ColorInformation, b: RevenueCat.PaywallData.Configuration.ColorInformation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.Configuration.Colors : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData.Configuration.Colors, b: RevenueCat.PaywallData.Configuration.Colors) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.Configuration.Images : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData.Configuration.Images, b: RevenueCat.PaywallData.Configuration.Images) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.Configuration : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData.Configuration, b: RevenueCat.PaywallData.Configuration) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData, b: RevenueCat.PaywallData) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.LocalizedConfiguration.Feature : Swift.Sendable {
}
extension RevenueCat.PaywallData.LocalizedConfiguration.OfferOverride : Swift.Sendable {
}
extension RevenueCat.PaywallData.LocalizedConfiguration : Swift.Sendable {
}
extension RevenueCat.PaywallData.Tier : Swift.Sendable {
}
extension RevenueCat.PaywallData.Configuration.ColorInformation : Swift.Sendable {
}
extension RevenueCat.PaywallData.Configuration.Colors : Swift.Sendable {
}
extension RevenueCat.PaywallData.Configuration.Images : Swift.Sendable {
}
extension RevenueCat.PaywallData.Configuration : Swift.Sendable {
}
extension RevenueCat.PaywallData : Swift.Sendable {
}
extension RevenueCat.PaywallData.Tier : Swift.Identifiable {
  public typealias ID = Swift.String
}
@_hasMissingDesignatedInitializers @objc(RCPurchasesDiagnostics) final public class PurchasesDiagnostics : ObjectiveC.NSObject, Swift.Sendable {
  @objc public static let `default`: RevenueCat.PurchasesDiagnostics
  @objc deinit
}
extension RevenueCat.PurchasesDiagnostics {
  public enum ProductStatus : Swift.Sendable {
    case valid
    case couldNotCheck
    case notFound
    case actionInProgress
    case needsAction
    case unknown
    public static func == (a: RevenueCat.PurchasesDiagnostics.ProductStatus, b: RevenueCat.PurchasesDiagnostics.ProductStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct ProductDiagnosticsPayload : Swift.Sendable {
    public let identifier: Swift.String
    public let title: Swift.String?
    public let status: RevenueCat.PurchasesDiagnostics.ProductStatus
    public let description: Swift.String
  }
  public struct InvalidBundleIdErrorPayload : Swift.Equatable {
    public let appBundleId: Swift.String
    public let sdkBundleId: Swift.String
    public static func == (a: RevenueCat.PurchasesDiagnostics.InvalidBundleIdErrorPayload, b: RevenueCat.PurchasesDiagnostics.InvalidBundleIdErrorPayload) -> Swift.Bool
  }
  public enum SDKHealthCheckStatus : Swift.Sendable {
    case passed
    case failed
    case warning
    public static func == (a: RevenueCat.PurchasesDiagnostics.SDKHealthCheckStatus, b: RevenueCat.PurchasesDiagnostics.SDKHealthCheckStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct OfferingDiagnosticsPayload : Swift.Sendable {
    public let identifier: Swift.String
    public let packages: [RevenueCat.PurchasesDiagnostics.OfferingPackageDiagnosticsPayload]
    public let status: RevenueCat.PurchasesDiagnostics.SDKHealthCheckStatus
  }
  public struct OfferingPackageDiagnosticsPayload : Swift.Sendable {
    public let identifier: Swift.String
    public let title: Swift.String?
    public let status: RevenueCat.PurchasesDiagnostics.ProductStatus
    public let description: Swift.String
    public let productIdentifier: Swift.String
    public let productTitle: Swift.String?
  }
  public enum SDKHealthError : Swift.Error {
    case invalidAPIKey
    case noOfferings
    case offeringConfiguration([RevenueCat.PurchasesDiagnostics.OfferingDiagnosticsPayload])
    case invalidBundleId(RevenueCat.PurchasesDiagnostics.InvalidBundleIdErrorPayload?)
    case invalidProducts([RevenueCat.PurchasesDiagnostics.ProductDiagnosticsPayload])
    case notAuthorizedToMakePayments
    case unknown(any Swift.Error)
  }
  public struct SDKHealthReport : Swift.Sendable {
    public let status: RevenueCat.PurchasesDiagnostics.SDKHealthStatus
    public let projectId: Swift.String?
    public let appId: Swift.String?
    public let products: [RevenueCat.PurchasesDiagnostics.ProductDiagnosticsPayload]
    public let offerings: [RevenueCat.PurchasesDiagnostics.OfferingDiagnosticsPayload]
  }
  public enum SDKHealthStatus : Swift.Sendable {
    case healthy(warnings: [RevenueCat.PurchasesDiagnostics.SDKHealthError])
    case unhealthy(RevenueCat.PurchasesDiagnostics.SDKHealthError)
  }
}
extension RevenueCat.PurchasesDiagnostics {
  public enum Error : Swift.Error {
    case failedConnectingToAPI(any Swift.Error)
    case invalidAPIKey
    case failedFetchingOfferings(any Swift.Error)
    case failedMakingSignedRequest(any Swift.Error)
    case unknown(any Swift.Error)
  }
}
extension RevenueCat.PurchasesDiagnostics {
  @available(*, deprecated, message: "Use the `PurchasesDiagnostics.shared.checkSDKHealth()` method instead.")
  @objc(testSDKHealthWithCompletion:) final public func testSDKHealth() async throws
  final public func checkSDKHealth() async throws
  final public func healthReport() async -> RevenueCat.PurchasesDiagnostics.SDKHealthReport
}
extension RevenueCat.PurchasesDiagnostics.Error : Foundation.CustomNSError {
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
@_hasMissingDesignatedInitializers @objc(RCNonSubscriptionTransaction) final public class NonSubscriptionTransaction : ObjectiveC.NSObject {
  @objc final public let productIdentifier: Swift.String
  @objc final public let purchaseDate: Foundation.Date
  @objc final public let transactionIdentifier: Swift.String
  @objc final public let storeTransactionIdentifier: Swift.String
  @objc final public let store: RevenueCat.Store
  @objc final public let price: RevenueCat.ProductPaidPrice?
  @objc final public let isSandbox: Swift.Bool
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.NonSubscriptionTransaction : Swift.Sendable {
}
extension RevenueCat.Purchases {
  @available(iOS, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(tvOS, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(watchOS, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(macOS, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(macCatalyst, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  final public func checkTrialOrIntroDiscountEligibility(_ productIdentifiers: [Swift.String], completion: @escaping ([Swift.String : RevenueCat.IntroEligibility]) -> Swift.Void)
  @available(iOS, introduced: 13.0, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(tvOS, introduced: 13.0, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(watchOS, introduced: 6.2, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(macOS, introduced: 10.15, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(macCatalyst, introduced: 13.0, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  final public func checkTrialOrIntroDiscountEligibility(_ productIdentifiers: [Swift.String]) async -> [Swift.String : RevenueCat.IntroEligibility]
  @available(iOS, deprecated, introduced: 13.0, renamed: "promotionalOffer(forProductDiscount:product:)")
  @available(tvOS, deprecated, introduced: 13.0, renamed: "promotionalOffer(forProductDiscount:product:)")
  @available(watchOS, deprecated, introduced: 6.2, renamed: "promotionalOffer(forProductDiscount:product:)")
  @available(macOS, deprecated, introduced: 10.15, renamed: "promotionalOffer(forProductDiscount:product:)")
  @available(macCatalyst, deprecated, introduced: 13.0, renamed: "promotionalOffer(forProductDiscount:product:)")
  final public func getPromotionalOffer(forProductDiscount discount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct) async throws -> RevenueCat.PromotionalOffer
  @available(iOS, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers(forProduct:)")
  @available(tvOS, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers(forProduct:)")
  @available(watchOS, deprecated, introduced: 6.2, renamed: "eligiblePromotionalOffers(forProduct:)")
  @available(macOS, deprecated, introduced: 10.15, renamed: "eligiblePromotionalOffers(forProduct:)")
  @available(macCatalyst, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers(forProduct:)")
  final public func getEligiblePromotionalOffers(forProduct product: RevenueCat.StoreProduct) async -> [RevenueCat.PromotionalOffer]
}
extension RevenueCat.Purchases {
  @available(iOS, deprecated, renamed: "attribution.collectDeviceIdentifiers()")
  @available(tvOS, deprecated, renamed: "attribution.collectDeviceIdentifiers()")
  @available(watchOS, deprecated, renamed: "attribution.collectDeviceIdentifiers()")
  @available(macOS, deprecated, renamed: "attribution.collectDeviceIdentifiers()")
  @available(macCatalyst, deprecated, renamed: "attribution.collectDeviceIdentifiers()")
  @objc final public func collectDeviceIdentifiers()
  @available(iOS, deprecated, renamed: "attribution.setAttributes(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAttributes(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAttributes(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAttributes(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAttributes(_:)")
  @objc final public func setAttributes(_ attributes: [Swift.String : Swift.String])
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setEmail(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setEmail(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setEmail(_:)")
  @available(macOS, deprecated, renamed: "attribution.setEmail(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setEmail(_:)")
  @objc final public func setEmail(_ email: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setPhoneNumber(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setPhoneNumber(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setPhoneNumber(_:)")
  @available(macOS, deprecated, renamed: "attribution.setPhoneNumber(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setPhoneNumber(_:)")
  @objc final public func setPhoneNumber(_ phoneNumber: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setDisplayName(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setDisplayName(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setDisplayName(_:)")
  @available(macOS, deprecated, renamed: "attribution.setDisplayName(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setDisplayName(_:)")
  @objc final public func setDisplayName(_ displayName: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setPushToken(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setPushToken(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setPushToken(_:)")
  @available(macOS, deprecated, renamed: "attribution.setPushToken(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setPushToken(_:)")
  @objc final public func setPushToken(_ pushToken: Foundation.Data?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setPushTokenString(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setPushTokenString(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setPushTokenString(_:)")
  @available(macOS, deprecated, renamed: "attribution.setPushTokenString(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setPushTokenString(_:)")
  @objc final public func setPushTokenString(_ pushToken: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setAdjustID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAdjustID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAdjustID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAdjustID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAdjustID(_:)")
  @objc final public func setAdjustID(_ adjustID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setAppsflyerID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAppsflyerID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAppsflyerID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAppsflyerID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAppsflyerID(_:)")
  @objc final public func setAppsflyerID(_ appsflyerID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setFBAnonymousID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setFBAnonymousID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setFBAnonymousID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setFBAnonymousID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setFBAnonymousID(_:)")
  @objc final public func setFBAnonymousID(_ fbAnonymousID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setMparticleID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setMparticleID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setMparticleID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setMparticleID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setMparticleID(_:)")
  @objc final public func setMparticleID(_ mparticleID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setOnesignalID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setOnesignalID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setOnesignalID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setOnesignalID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setOnesignalID(_:)")
  @objc final public func setOnesignalID(_ onesignalID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setAirshipChannelID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAirshipChannelID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAirshipChannelID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAirshipChannelID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAirshipChannelID(_:)")
  @objc final public func setAirshipChannelID(_ airshipChannelID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setCleverTapID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setCleverTapID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setCleverTapID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setCleverTapID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setCleverTapID(_:)")
  @objc final public func setCleverTapID(_ cleverTapID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setMixpanelDistinctID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setMixpanelDistinctID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setMixpanelDistinctID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setMixpanelDistinctID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setMixpanelDistinctID(_:)")
  @objc final public func setMixpanelDistinctID(_ mixpanelDistinctID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setFirebaseAppInstanceID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setFirebaseAppInstanceID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setFirebaseAppInstanceID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setFirebaseAppInstanceID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setFirebaseAppInstanceID(_:)")
  @objc final public func setFirebaseAppInstanceID(_ firebaseAppInstanceID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setMediaSource(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setMediaSource(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setMediaSource(_:)")
  @available(macOS, deprecated, renamed: "attribution.setMediaSource(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setMediaSource(_:)")
  @objc final public func setMediaSource(_ mediaSource: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setCampaign(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setCampaign(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setCampaign(_:)")
  @available(macOS, deprecated, renamed: "attribution.setCampaign(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setCampaign(_:)")
  @objc final public func setCampaign(_ campaign: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setAdGroup(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAdGroup(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAdGroup(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAdGroup(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAdGroup(_:)")
  @objc final public func setAdGroup(_ adGroup: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setAd(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAd(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAd(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAd(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAd(_:)")
  @objc final public func setAd(_ installAd: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setKeyword(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setKeyword(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setKeyword(_:)")
  @available(macOS, deprecated, renamed: "attribution.setKeyword(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setKeyword(_:)")
  @objc final public func setKeyword(_ keyword: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, deprecated, renamed: "attribution.setCreative(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setCreative(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setCreative(_:)")
  @available(macOS, deprecated, renamed: "attribution.setCreative(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setCreative(_:)")
  @objc final public func setCreative(_ creative: Swift.String?)
  #endif
  @available(iOS, deprecated, renamed: "purchase(_:completion:)")
  @available(tvOS, deprecated, renamed: "purchase(_:completion:)")
  @available(watchOS, deprecated, renamed: "purchase(_:completion:)")
  @available(macOS, deprecated, renamed: "purchase(_:completion:)")
  @available(macCatalyst, deprecated, renamed: "purchase(_:completion:)")
  @objc(params:withCompletion:) final public func purchaseWithParams(_ params: RevenueCat.PurchaseParams, completion: @escaping RevenueCat.PurchaseCompletedBlock)
}
extension RevenueCat.StoreProduct {
  @available(iOS, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers()")
  @available(tvOS, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers()")
  @available(watchOS, deprecated, introduced: 6.2, renamed: "eligiblePromotionalOffers()")
  @available(macOS, deprecated, introduced: 10.15, renamed: "eligiblePromotionalOffers()")
  @available(macCatalyst, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers()")
  final public func getEligiblePromotionalOffers() async -> [RevenueCat.PromotionalOffer]
}
extension RevenueCat.CustomerInfo {
  @available(*, deprecated, message: "use nonSubscriptionTransactions")
  @objc final public var nonConsumablePurchases: Swift.Set<Swift.String> {
    @objc get
  }
  @available(*, deprecated, renamed: "nonSubscriptions")
  @objc final public var nonSubscriptionTransactions: [RevenueCat.StoreTransaction] {
    @objc get
  }
}
extension RevenueCat.Configuration.Builder {
  @available(*, deprecated, message: "Use .with(storeKitVersion:) to enable StoreKit 2")
  @objc dynamic public func with(usesStoreKit2IfAvailable: Swift.Bool) -> RevenueCat.Configuration.Builder
}
@objc(RCPurchasesErrorCode) public enum ErrorCode : Swift.Int, Swift.Error {
  @objc(RCUnknownError) case unknownError = 0
  @objc(RCPurchaseCancelledError) case purchaseCancelledError = 1
  @objc(RCStoreProblemError) case storeProblemError = 2
  @objc(RCPurchaseNotAllowedError) case purchaseNotAllowedError = 3
  @objc(RCPurchaseInvalidError) case purchaseInvalidError = 4
  @objc(RCProductNotAvailableForPurchaseError) case productNotAvailableForPurchaseError = 5
  @objc(RCProductAlreadyPurchasedError) case productAlreadyPurchasedError = 6
  @objc(RCReceiptAlreadyInUseError) case receiptAlreadyInUseError = 7
  @objc(RCInvalidReceiptError) case invalidReceiptError = 8
  @objc(RCMissingReceiptFileError) case missingReceiptFileError = 9
  @objc(RCNetworkError) case networkError = 10
  @objc(RCInvalidCredentialsError) case invalidCredentialsError = 11
  @objc(RCUnexpectedBackendResponseError) case unexpectedBackendResponseError = 12
  @objc(RCReceiptInUseByOtherSubscriberError) case receiptInUseByOtherSubscriberError = 13
  @objc(RCInvalidAppUserIdError) case invalidAppUserIdError = 14
  @objc(RCOperationAlreadyInProgressForProductError) case operationAlreadyInProgressForProductError = 15
  @objc(RCUnknownBackendError) case unknownBackendError = 16
  @objc(RCInvalidAppleSubscriptionKeyError) case invalidAppleSubscriptionKeyError = 17
  @objc(RCIneligibleError) case ineligibleError = 18
  @objc(RCInsufficientPermissionsError) case insufficientPermissionsError = 19
  @objc(RCPaymentPendingError) case paymentPendingError = 20
  @objc(RCInvalidSubscriberAttributesError) case invalidSubscriberAttributesError = 21
  @objc(RCLogOutAnonymousUserError) case logOutAnonymousUserError = 22
  @objc(RCConfigurationError) case configurationError = 23
  @objc(RCUnsupportedError) case unsupportedError = 24
  @objc(RCEmptySubscriberAttributesError) case emptySubscriberAttributes = 25
  @objc(RCProductDiscountMissingIdentifierError) case productDiscountMissingIdentifierError = 26
  @objc(RCProductDiscountMissingSubscriptionGroupIdentifierError) case productDiscountMissingSubscriptionGroupIdentifierError = 28
  @objc(RCCustomerInfoError) case customerInfoError = 29
  @objc(RCSystemInfoError) case systemInfoError = 30
  @objc(RCBeginRefundRequestError) case beginRefundRequestError = 31
  @objc(RCProductRequestTimedOut) case productRequestTimedOut = 32
  @objc(RCAPIEndpointBlocked) case apiEndpointBlockedError = 33
  @objc(RCInvalidPromotionalOfferError) case invalidPromotionalOfferError = 34
  @objc(RCOfflineConnectionError) case offlineConnectionError = 35
  @objc(RCFeatureNotAvailableInCustomEntitlementsComputationMode) case featureNotAvailableInCustomEntitlementsComputationMode = 36
  @objc(RCSignatureVerificationFailed) case signatureVerificationFailed = 37
  @objc(RCFeatureNotSupportedWithStoreKit1) case featureNotSupportedWithStoreKit1 = 38
  @objc(RCInvalidWebPurchaseToken) case invalidWebPurchaseToken = 39
  @objc(RCPurchaseBelongsToOtherUser) case purchaseBelongsToOtherUser = 40
  @objc(RCExpiredWebPurchaseToken) case expiredWebPurchaseToken = 41
  @objc(RCTestStoreSimulatedPurchaseError) case testStoreSimulatedPurchaseError = 42
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public static var _nsErrorDomain: Swift.String {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.ErrorCode : Swift.CaseIterable {
  public typealias AllCases = [RevenueCat.ErrorCode]
  nonisolated public static var allCases: [RevenueCat.ErrorCode] {
    get
  }
}
extension RevenueCat.ErrorCode {
  public var description: Swift.String {
    get
  }
}
extension RevenueCat.ErrorCode : Foundation.CustomNSError {
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
@objc(RCPurchasesAreCompletedBy) public enum PurchasesAreCompletedBy : Swift.Int {
  case revenueCat
  case myApp
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.PurchasesAreCompletedBy : Swift.Sendable {
}
extension RevenueCat.PurchasesAreCompletedBy : Swift.Codable {
}
@objc(RCRefundRequestStatus) public enum RefundRequestStatus : Swift.Int, Swift.Sendable {
  @objc(RCRefundRequestUserCancelled) case userCancelled = 0
  @objc(RCRefundRequestSuccess) case success
  @objc(RCRefundRequestError) case error
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum CustomerCenterPresentationMode {
  case sheet
  case fullScreen
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.CustomerCenterPresentationMode {
  public static let `default`: RevenueCat.CustomerCenterPresentationMode
}
extension RevenueCat.CustomerCenterPresentationMode : Swift.CaseIterable {
  public static var allCases: [RevenueCat.CustomerCenterPresentationMode] {
    get
  }
  public typealias AllCases = [RevenueCat.CustomerCenterPresentationMode]
}
extension RevenueCat.CustomerCenterPresentationMode : Swift.Equatable, Swift.Sendable {
  public static func == (a: RevenueCat.CustomerCenterPresentationMode, b: RevenueCat.CustomerCenterPresentationMode) -> Swift.Bool
}
extension RevenueCat.CustomerCenterPresentationMode : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@objc @_hasMissingDesignatedInitializers public class PurchasesReceiptParser : ObjectiveC.NSObject {
  public func parse(from receiptData: Foundation.Data) throws -> RevenueCat.AppleReceipt
  @objc deinit
}
extension RevenueCat.PurchasesReceiptParser {
  public func parse(base64String string: Swift.String) throws -> RevenueCat.AppleReceipt
}
extension RevenueCat.PurchasesReceiptParser : @unchecked Swift.Sendable {
}
extension RevenueCat.Purchases {
  @objc(RCPlatformInfo) final public class PlatformInfo : ObjectiveC.NSObject {
    @objc public init(flavor: Swift.String, version: Swift.String)
    @objc deinit
  }
  @objc public static var platformInfo: RevenueCat.Purchases.PlatformInfo?
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(RCDangerousSettings) final public class DangerousSettings : ObjectiveC.NSObject {
  @objc final public let autoSyncPurchases: Swift.Bool
  @objc final public let customEntitlementComputation: Swift.Bool
  @objc override convenience dynamic public init()
  @objc convenience public init(autoSyncPurchases: Swift.Bool = true)
  @objc deinit
}
extension RevenueCat.DangerousSettings : Swift.Sendable {
}
public typealias ProductIdentifier = Swift.String
@_hasMissingDesignatedInitializers @objc(RCCustomerInfo) final public class CustomerInfo : ObjectiveC.NSObject {
  @objc final public let entitlements: RevenueCat.EntitlementInfos
  @objc final public var activeSubscriptions: Swift.Set<RevenueCat.ProductIdentifier> {
    @objc get
  }
  @objc final public let allPurchasedProductIdentifiers: Swift.Set<RevenueCat.ProductIdentifier>
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var latestExpirationDate: Foundation.Date? {
    @objc get
  }
  #endif
  @objc final public let nonSubscriptions: [RevenueCat.NonSubscriptionTransaction]
  @objc final public let requestDate: Foundation.Date
  @objc final public let firstSeen: Foundation.Date
  @objc final public let originalAppUserId: Swift.String
  @objc final public let managementURL: Foundation.URL?
  @objc final public let originalPurchaseDate: Foundation.Date?
  @objc final public let originalApplicationVersion: Swift.String?
  @objc final public let subscriptionsByProductIdentifier: [RevenueCat.ProductIdentifier : RevenueCat.SubscriptionInfo]
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func expirationDate(forProductIdentifier productIdentifier: RevenueCat.ProductIdentifier) -> Foundation.Date?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func purchaseDate(forProductIdentifier productIdentifier: RevenueCat.ProductIdentifier) -> Foundation.Date?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func expirationDate(forEntitlement entitlementIdentifier: Swift.String) -> Foundation.Date?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func purchaseDate(forEntitlement entitlementIdentifier: Swift.String) -> Foundation.Date?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  #endif
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(entitlements: RevenueCat.EntitlementInfos, expirationDatesByProductId: [Swift.String : Foundation.Date] = [:], purchaseDatesByProductId: [Swift.String : Foundation.Date] = [:], allPurchasedProductIds: Swift.Set<Swift.String> = [], requestDate: Foundation.Date, firstSeen: Foundation.Date, originalAppUserId: Swift.String, originalPurchaseDate: Foundation.Date? = nil, managementURL: Foundation.URL? = nil)
  #endif
  @objc deinit
}
extension RevenueCat.CustomerInfo : RevenueCat.RawDataContainer {
  @objc final public var rawData: [Swift.String : Any] {
    @objc get
  }
  public typealias Content = [Swift.String : Any]
}
extension RevenueCat.CustomerInfo : Swift.Sendable {
}
extension RevenueCat.CustomerInfo : Swift.Codable {
  convenience public init(from decoder: any Swift.Decoder) throws
  final public func encode(to encoder: any Swift.Encoder) throws
}
extension RevenueCat.CustomerInfo : Swift.Identifiable {
  final public var id: Swift.String {
    get
  }
  public typealias ID = Swift.String
}
extension RevenueCat.PaywallComponent {
  public enum Background : Swift.Codable, Swift.Sendable, Swift.Hashable {
    case color(RevenueCat.PaywallComponent.ColorScheme)
    case image(RevenueCat.PaywallComponent.ThemeImageUrls, RevenueCat.PaywallComponent.FitMode, RevenueCat.PaywallComponent.ColorScheme?)
    case video(RevenueCat.PaywallComponent.ThemeVideoUrls, RevenueCat.PaywallComponent.ThemeImageUrls, RevenueCat.PaywallComponent.Background.Loop, RevenueCat.PaywallComponent.Background.MuteAudio, RevenueCat.PaywallComponent.FitMode, RevenueCat.PaywallComponent.ColorScheme?)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public static func == (a: RevenueCat.PaywallComponent.Background, b: RevenueCat.PaywallComponent.Background) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension RevenueCat.PaywallComponent.Background {
  public typealias Loop = Swift.Bool
  public typealias MuteAudio = Swift.Bool
}
extension RevenueCat.AppleReceipt {
  public struct InAppPurchase : Swift.Equatable {
    public let quantity: Swift.Int
    public let productId: Swift.String
    public let transactionId: Swift.String
    public let originalTransactionId: Swift.String?
    public let productType: RevenueCat.AppleReceipt.InAppPurchase.ProductType
    public let purchaseDate: Foundation.Date
    public let originalPurchaseDate: Foundation.Date?
    public let expiresDate: Foundation.Date?
    public let cancellationDate: Foundation.Date?
    public let isInTrialPeriod: Swift.Bool?
    public let isInIntroOfferPeriod: Swift.Bool?
    public let webOrderLineItemId: Swift.Int64?
    public let promotionalOfferIdentifier: Swift.String?
    public static func == (a: RevenueCat.AppleReceipt.InAppPurchase, b: RevenueCat.AppleReceipt.InAppPurchase) -> Swift.Bool
  }
}
extension RevenueCat.AppleReceipt.InAppPurchase {
  public enum ProductType : Swift.Int {
    case unknown
    case nonConsumable
    case consumable
    case nonRenewingSubscription
    case autoRenewableSubscription
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension RevenueCat.AppleReceipt.InAppPurchase.ProductType : Swift.Sendable {
}
extension RevenueCat.AppleReceipt.InAppPurchase : Swift.Sendable {
}
extension RevenueCat.AppleReceipt.InAppPurchase.ProductType : Swift.Codable {
}
extension RevenueCat.AppleReceipt.InAppPurchase : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.AppleReceipt.InAppPurchase : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@objc(RCStore) public enum Store : Swift.Int {
  @objc(RCAppStore) case appStore = 0
  @objc(RCMacAppStore) case macAppStore = 1
  @objc(RCPlayStore) case playStore = 2
  @objc(RCStripe) case stripe = 3
  @objc(RCPromotional) case promotional = 4
  @objc(RCUnknownStore) case unknownStore = 5
  @objc(RCAmazon) case amazon = 6
  @objc(RCBilling) case rcBilling = 7
  @objc(RCExternal) case external = 8
  @objc(RCPaddle) case paddle = 9
  @objc(RCTestStore) case testStore = 10
  @objc(RCGalaxy) case galaxy = 11
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.Store : Swift.CaseIterable {
  public typealias AllCases = [RevenueCat.Store]
  nonisolated public static var allCases: [RevenueCat.Store] {
    get
  }
}
extension RevenueCat.Store : Swift.Sendable {
}
@objc(RCPeriodType) public enum PeriodType : Swift.Int {
  @objc(RCNormal) case normal = 0
  @objc(RCIntro) case intro = 1
  @objc(RCTrial) case trial = 2
  @objc(RCPrepaid) case prepaid = 3
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.PeriodType : Swift.CaseIterable {
  public typealias AllCases = [RevenueCat.PeriodType]
  nonisolated public static var allCases: [RevenueCat.PeriodType] {
    get
  }
}
extension RevenueCat.PeriodType : Swift.Sendable {
}
@_hasMissingDesignatedInitializers @objc(RCEntitlementInfo) final public class EntitlementInfo : ObjectiveC.NSObject {
  @objc final public var identifier: Swift.String {
    @objc get
  }
  @objc final public var isActive: Swift.Bool {
    @objc get
  }
  @objc final public var willRenew: Swift.Bool {
    @objc get
  }
  @objc final public var periodType: RevenueCat.PeriodType {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var latestPurchaseDate: Foundation.Date? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var originalPurchaseDate: Foundation.Date? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var expirationDate: Foundation.Date? {
    @objc get
  }
  #endif
  @objc final public var store: RevenueCat.Store {
    @objc get
  }
  @objc final public var productIdentifier: Swift.String {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var productPlanIdentifier: Swift.String? {
    @objc get
  }
  #endif
  @objc final public var isSandbox: Swift.Bool {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var unsubscribeDetectedAt: Foundation.Date? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var billingIssueDetectedAt: Foundation.Date? {
    @objc get
  }
  #endif
  @objc final public var ownershipType: RevenueCat.PurchaseOwnershipType {
    @objc get
  }
  @objc final public var verification: RevenueCat.VerificationResult {
    @objc get
  }
  @objc final public let rawData: [Swift.String : Any]
  @objc override final public var description: Swift.String {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  #endif
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init(identifier: Swift.String, isActive: Swift.Bool, willRenew: Swift.Bool, periodType: RevenueCat.PeriodType, latestPurchaseDate: Foundation.Date? = nil, originalPurchaseDate: Foundation.Date? = nil, expirationDate: Foundation.Date? = nil, store: RevenueCat.Store, productIdentifier: Swift.String, productPlanIdentifier: Swift.String? = nil, isSandbox: Swift.Bool, unsubscribeDetectedAt: Foundation.Date? = nil, billingIssueDetectedAt: Foundation.Date? = nil, ownershipType: RevenueCat.PurchaseOwnershipType, verification: RevenueCat.VerificationResult = .notRequested)
  #endif
  @objc deinit
}
extension RevenueCat.EntitlementInfo : RevenueCat.RawDataContainer {
  public typealias Content = [Swift.String : Any]
}
extension RevenueCat.EntitlementInfo : @unchecked Swift.Sendable {
}
extension RevenueCat.EntitlementInfo {
  @objc final public var isActiveInCurrentEnvironment: Swift.Bool {
    @objc get
  }
  @objc final public var isActiveInAnyEnvironment: Swift.Bool {
    @objc get
  }
}
extension RevenueCat.EntitlementInfo : Swift.Identifiable {
  final public var id: Swift.String {
    get
  }
  public typealias ID = Swift.String
}
@objc(RCVirtualCurrency) final public class VirtualCurrency : ObjectiveC.NSObject, Swift.Codable {
  @objc final public let balance: Swift.Int
  @objc final public let name: Swift.String
  @objc final public let code: Swift.String
  @objc final public let serverDescription: Swift.String?
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.VirtualCurrency : Swift.Sendable {
}
extension RevenueCat.VirtualCurrency {
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  #endif
}
public typealias VerboseLogHandler = (_ level: RevenueCat.LogLevel, _ message: Swift.String, _ file: Swift.String?, _ function: Swift.String?, _ line: Swift.UInt) -> Swift.Void
public typealias LogHandler = (_ level: RevenueCat.LogLevel, _ message: Swift.String) -> Swift.Void
extension RevenueCat.LogLevel : Swift.Comparable {
  public static func < (lhs: RevenueCat.LogLevel, rhs: RevenueCat.LogLevel) -> Swift.Bool
}
extension RevenueCat.PurchasesReceiptParser {
  public enum Error : Swift.Error {
    case dataObjectIdentifierMissing
    case asn1ParsingError(description: Swift.String)
    case receiptParsingError
    case inAppPurchaseParsingError
    case failedToDecodeBase64String
    case receiptNotPresent
    case failedToLoadLocalReceipt(any Swift.Error)
    case foundEmptyLocalReceipt
  }
}
extension RevenueCat.PurchasesReceiptParser.Error : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
public struct Checksum : Swift.Codable, Swift.Sendable, Swift.Hashable {
  public let algorithm: RevenueCat.Checksum.Algorithm
  public let value: Swift.String
  public init(algorithm: RevenueCat.Checksum.Algorithm, value: Swift.String)
  public enum Algorithm : Swift.String, Swift.Codable, Swift.Sendable {
    case sha256, sha384, sha512, md5
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public static func == (a: RevenueCat.Checksum, b: RevenueCat.Checksum) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.Checksum {
  public static func generate(from data: Foundation.Data, with algorithm: RevenueCat.Checksum.Algorithm) -> RevenueCat.Checksum
  public func compare(to checksome: RevenueCat.Checksum) throws
  public struct ChecksumValidationFailure : Swift.Error {
  }
}
@objc(RCLogLevel) public enum LogLevel : Swift.Int, Swift.CustomStringConvertible, Swift.CaseIterable, Swift.Sendable {
  case verbose = 4
  case debug = 0
  case info = 1
  case warn = 2
  case error = 3
  public var description: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias AllCases = [RevenueCat.LogLevel]
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [RevenueCat.LogLevel] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallComponent {
  public struct Transition : RevenueCat.PaywallComponentBase {
    public let type: RevenueCat.PaywallComponent.TransitionType
    public let displacementStrategy: RevenueCat.PaywallComponent.DisplacementStrategy
    public let animation: RevenueCat.PaywallComponent.Animation?
    public static func == (a: RevenueCat.PaywallComponent.Transition, b: RevenueCat.PaywallComponent.Transition) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum DisplacementStrategy : Swift.String, RevenueCat.PaywallComponentBase {
    case greedy, lazy
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum TransitionType : Swift.String, RevenueCat.PaywallComponentBase {
    case fade
    case fadeAndScale
    case scale
    case slide
    public init(from decoder: any Swift.Decoder) throws
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
@objc(RCPackageType) public enum PackageType : Swift.Int {
  case unknown = -2, custom, lifetime, annual, sixMonth, threeMonth, twoMonth, monthly, weekly
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.PackageType : Swift.CaseIterable {
  public typealias AllCases = [RevenueCat.PackageType]
  nonisolated public static var allCases: [RevenueCat.PackageType] {
    get
  }
}
extension RevenueCat.PackageType : Swift.Sendable {
}
extension RevenueCat.PackageType : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RevenueCat.PackageType : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers @objc(RCSubscriptionInfo) final public class SubscriptionInfo : ObjectiveC.NSObject {
  @objc final public let productIdentifier: RevenueCat.ProductIdentifier
  @objc final public let purchaseDate: Foundation.Date
  @objc final public let originalPurchaseDate: Foundation.Date?
  @objc final public let expiresDate: Foundation.Date?
  @objc final public let store: RevenueCat.Store
  @objc final public let isSandbox: Swift.Bool
  @objc final public let unsubscribeDetectedAt: Foundation.Date?
  @objc final public let billingIssuesDetectedAt: Foundation.Date?
  @objc final public let gracePeriodExpiresDate: Foundation.Date?
  @objc final public let ownershipType: RevenueCat.PurchaseOwnershipType
  @objc final public let periodType: RevenueCat.PeriodType
  @objc final public let refundedAt: Foundation.Date?
  @objc final public let storeTransactionId: Swift.String?
  @objc final public let isActive: Swift.Bool
  @objc final public let willRenew: Swift.Bool
  @objc final public let displayName: Swift.String?
  @objc final public let price: RevenueCat.ProductPaidPrice?
  @objc final public let managementURL: Foundation.URL?
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.SubscriptionInfo : Swift.Sendable {
}
public enum WebPurchaseRedemptionResult : Swift.Sendable {
  case success(_: RevenueCat.CustomerInfo)
  case error(_: RevenueCat.PublicError)
  case invalidToken
  case purchaseBelongsToOtherUser
  case expired(_: Swift.String)
}
public typealias SK1Transaction = StoreKit.SKPaymentTransaction
@available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
public typealias SK2Transaction = StoreKit.Transaction
@_hasMissingDesignatedInitializers @objc(RCStoreTransaction) final public class StoreTransaction : ObjectiveC.NSObject {
  @objc final public var productIdentifier: Swift.String {
    @objc get
  }
  @objc final public var purchaseDate: Foundation.Date {
    @objc get
  }
  @objc final public var transactionIdentifier: Swift.String {
    @objc get
  }
  @objc final public var quantity: Swift.Int {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var storefront: RevenueCat.Storefront? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  #endif
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.StoreTransaction {
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(productIdentifier: Swift.String, purchaseDate: Foundation.Date, transactionIdentifier: Swift.String, quantity: Swift.Int = 1, storefront: RevenueCat.Storefront? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var sk1Transaction: RevenueCat.SK1Transaction? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  final public var sk2Transaction: RevenueCat.SK2Transaction? {
    get
  }
  #endif
}
extension RevenueCat.StoreTransaction : Swift.Identifiable {
  final public var id: Swift.String {
    get
  }
  public typealias ID = Swift.String
}
extension RevenueCat.PaywallComponent {
  final public class StackComponent : RevenueCat.PaywallComponentBase {
    public enum Overflow : Swift.String, RevenueCat.PaywallComponentBase {
      case `default`
      case scroll
      public init(from decoder: any Swift.Decoder) throws
      #if compiler(>=5.3) && $NonescapableTypes
      public init?(rawValue: Swift.String)
      #endif
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    final public let visible: Swift.Bool?
    final public let components: [RevenueCat.PaywallComponent]
    final public let size: RevenueCat.PaywallComponent.Size
    final public let spacing: CoreFoundation.CGFloat?
    final public let backgroundColor: RevenueCat.PaywallComponent.ColorScheme?
    final public let background: RevenueCat.PaywallComponent.Background?
    final public let dimension: RevenueCat.PaywallComponent.Dimension
    final public let padding: RevenueCat.PaywallComponent.Padding
    final public let margin: RevenueCat.PaywallComponent.Padding
    final public let shape: RevenueCat.PaywallComponent.Shape?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    final public let badge: RevenueCat.PaywallComponent.Badge?
    final public let overflow: RevenueCat.PaywallComponent.StackComponent.Overflow?
    final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialStackComponent>?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(visible: Swift.Bool? = nil, components: [RevenueCat.PaywallComponent], dimension: RevenueCat.PaywallComponent.Dimension = .vertical(.center, .start), size: RevenueCat.PaywallComponent.Size = .init(width: .fill, height: .fit), spacing: CoreFoundation.CGFloat? = nil, backgroundColor: RevenueCat.PaywallComponent.ColorScheme? = nil, background: RevenueCat.PaywallComponent.Background? = nil, padding: RevenueCat.PaywallComponent.Padding = .zero, margin: RevenueCat.PaywallComponent.Padding = .zero, shape: RevenueCat.PaywallComponent.Shape? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil, badge: RevenueCat.PaywallComponent.Badge? = nil, overflow: RevenueCat.PaywallComponent.StackComponent.Overflow? = nil, overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialStackComponent>? = nil)
    #endif
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.StackComponent, rhs: RevenueCat.PaywallComponent.StackComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class PartialStackComponent : RevenueCat.PaywallPartialComponent {
    final public let visible: Swift.Bool?
    final public let size: RevenueCat.PaywallComponent.Size?
    final public let spacing: CoreFoundation.CGFloat?
    final public let backgroundColor: RevenueCat.PaywallComponent.ColorScheme?
    final public let background: RevenueCat.PaywallComponent.Background?
    final public let dimension: RevenueCat.PaywallComponent.Dimension?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let shape: RevenueCat.PaywallComponent.Shape?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    final public let overflow: RevenueCat.PaywallComponent.StackComponent.Overflow?
    final public let badge: RevenueCat.PaywallComponent.Badge?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(visible: Swift.Bool? = true, dimension: RevenueCat.PaywallComponent.Dimension? = nil, size: RevenueCat.PaywallComponent.Size? = nil, spacing: CoreFoundation.CGFloat? = nil, backgroundColor: RevenueCat.PaywallComponent.ColorScheme? = nil, background: RevenueCat.PaywallComponent.Background? = nil, padding: RevenueCat.PaywallComponent.Padding? = nil, margin: RevenueCat.PaywallComponent.Padding? = nil, shape: RevenueCat.PaywallComponent.Shape? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil, overflow: RevenueCat.PaywallComponent.StackComponent.Overflow? = nil, badge: RevenueCat.PaywallComponent.Badge? = nil)
    #endif
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PartialStackComponent, rhs: RevenueCat.PaywallComponent.PartialStackComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension RevenueCat.PaywallComponent {
  final public class PackageComponent : RevenueCat.PaywallComponentBase {
    final public let packageID: Swift.String
    final public let isSelectedByDefault: Swift.Bool
    final public let stack: RevenueCat.PaywallComponent.StackComponent
    #if compiler(>=5.3) && $NonescapableTypes
    public init(packageID: Swift.String, isSelectedByDefault: Swift.Bool, applePromoOfferProductCode: Swift.String?, stack: RevenueCat.PaywallComponent.StackComponent)
    #endif
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PackageComponent, rhs: RevenueCat.PaywallComponent.PackageComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
public protocol RawDataContainer {
  associatedtype Content
  var rawData: Self.Content { get }
}
public typealias PurchaseResultData = (transaction: RevenueCat.StoreTransaction?, customerInfo: RevenueCat.CustomerInfo, userCancelled: Swift.Bool)
public typealias PurchaseCompletedBlock = @_Concurrency.MainActor @Sendable (RevenueCat.StoreTransaction?, RevenueCat.CustomerInfo?, RevenueCat.PublicError?, Swift.Bool) -> Swift.Void
public typealias GetStorefrontBlock = @_Concurrency.MainActor @Sendable (RevenueCat.Storefront?) -> Swift.Void
public typealias StartPurchaseBlock = (@escaping RevenueCat.PurchaseCompletedBlock) -> Swift.Void
@_hasMissingDesignatedInitializers @objc(RCPurchases) final public class Purchases : ObjectiveC.NSObject, RevenueCat.PurchasesType, RevenueCat.PurchasesSwiftType {
  @objc(sharedPurchases) public static var shared: RevenueCat.Purchases {
    @objc get
  }
  @objc public static var isConfigured: Swift.Bool {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var delegate: (any RevenueCat.PurchasesDelegate)? {
    @objc get
    @objc set
  }
  #endif
  @objc public static var logLevel: RevenueCat.LogLevel {
    @objc get
    @objc set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc public static var proxyURL: Foundation.URL? {
    @objc get
    @objc set
  }
  #endif
  @objc public static var forceUniversalAppStore: Swift.Bool {
    @objc get
    @objc set
  }
  @available(iOS 8.0, macOS 10.14, watchOS 6.2, macCatalyst 13.0, *)
  @objc public static var simulatesAskToBuyInSandbox: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public static func canMakePayments() -> Swift.Bool
  @objc public static var logHandler: RevenueCat.LogHandler {
    @objc get
    @objc set
  }
  @objc public static var verboseLogHandler: RevenueCat.VerboseLogHandler {
    @objc get
    @objc set
  }
  @objc public static var verboseLogs: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public static var frameworkVersion: Swift.String {
    @objc get
  }
  @objc final public let attribution: RevenueCat.Attribution
  @objc final public var purchasesAreCompletedBy: RevenueCat.PurchasesAreCompletedBy {
    @objc get
    @objc set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var storeFrontCountryCode: Swift.String? {
    @objc get
  }
  #endif
  @objc deinit
}
extension RevenueCat.Purchases {
  @objc final public var appUserID: Swift.String {
    @objc get
  }
  @objc final public var isAnonymous: Swift.Bool {
    @objc get
  }
  @objc final public var isSandbox: Swift.Bool {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func getOfferings(completion: @escaping (RevenueCat.Offerings?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  @objc final public func offerings() async throws -> RevenueCat.Offerings
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var cachedOfferings: RevenueCat.Offerings? {
    @objc get
  }
  #endif
}
extension RevenueCat.Purchases {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "The appUserID passed to logIn is a constant string known at compile time.\nThis is likely a programmer error. This ID is used to identify the current user.\nSee https://docs.revenuecat.com/docs/user-ids for more information.")
  final public func logIn(_ appUserID: Swift.StaticString, completion: @escaping (RevenueCat.CustomerInfo?, Swift.Bool, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_disfavoredOverload @objc(logIn:completion:) final public func logIn(_ appUserID: Swift.String, completion: @escaping (RevenueCat.CustomerInfo?, Swift.Bool, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  final public func logIn(_ appUserID: Swift.StaticString) async throws -> (customerInfo: RevenueCat.CustomerInfo, created: Swift.Bool)
  @_disfavoredOverload @objc final public func logIn(_ appUserID: Swift.String) async throws -> (customerInfo: RevenueCat.CustomerInfo, created: Swift.Bool)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func logOut(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)?)
  #endif
  @objc final public func logOut() async throws -> RevenueCat.CustomerInfo
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func syncAttributesAndOfferingsIfNeeded(completion: @escaping (RevenueCat.Offerings?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @objc final public func syncAttributesAndOfferingsIfNeeded() async throws -> RevenueCat.Offerings?
  #endif
  @objc final public func getStorefront(completion: @escaping RevenueCat.GetStorefrontBlock)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func getStorefront() async -> RevenueCat.Storefront?
  #endif
}
extension RevenueCat.Purchases {
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func getCustomerInfo(completion: @escaping (RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func getCustomerInfo(fetchPolicy: RevenueCat.CacheFetchPolicy, completion: @escaping (RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  @objc final public func customerInfo() async throws -> RevenueCat.CustomerInfo
  @objc final public func customerInfo(fetchPolicy: RevenueCat.CacheFetchPolicy) async throws -> RevenueCat.CustomerInfo
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var cachedCustomerInfo: RevenueCat.CustomerInfo? {
    @objc get
  }
  #endif
  final public var customerInfoStream: _Concurrency.AsyncStream<RevenueCat.CustomerInfo> {
    get
  }
  @objc(getProductsWithIdentifiers:completion:) final public func getProducts(_ productIdentifiers: [Swift.String], completion: @escaping ([RevenueCat.StoreProduct]) -> Swift.Void)
  @objc final public func products(_ productIdentifiers: [Swift.String]) async -> [RevenueCat.StoreProduct]
  @objc(purchaseProduct:withCompletion:) final public func purchase(product: RevenueCat.StoreProduct, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc final public func purchase(product: RevenueCat.StoreProduct) async throws -> RevenueCat.PurchaseResultData
  @objc(purchasePackage:withCompletion:) final public func purchase(package: RevenueCat.Package, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc final public func purchase(package: RevenueCat.Package) async throws -> RevenueCat.PurchaseResultData
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func restorePurchases(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)? = nil)
  #endif
  @objc final public func restorePurchases() async throws -> RevenueCat.CustomerInfo
  @objc(purchaseWithParams:completion:) final public func purchase(_ params: RevenueCat.PurchaseParams, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc final public func purchase(_ params: RevenueCat.PurchaseParams) async throws -> RevenueCat.PurchaseResultData
  @objc(purchaseProduct:withPromotionalOffer:completion:) final public func purchase(product: RevenueCat.StoreProduct, promotionalOffer: RevenueCat.PromotionalOffer, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc final public func purchase(product: RevenueCat.StoreProduct, promotionalOffer: RevenueCat.PromotionalOffer) async throws -> RevenueCat.PurchaseResultData
  @objc(purchasePackage:withPromotionalOffer:completion:) final public func purchase(package: RevenueCat.Package, promotionalOffer: RevenueCat.PromotionalOffer, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc final public func purchase(package: RevenueCat.Package, promotionalOffer: RevenueCat.PromotionalOffer) async throws -> RevenueCat.PurchaseResultData
  @objc final public func invalidateCustomerInfoCache()
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func syncPurchases(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)?)
  #endif
  @objc final public func syncPurchases() async throws -> RevenueCat.CustomerInfo
  @objc(checkTrialOrIntroDiscountEligibility:completion:) final public func checkTrialOrIntroDiscountEligibility(productIdentifiers: [Swift.String], completion: @escaping ([Swift.String : RevenueCat.IntroEligibility]) -> Swift.Void)
  @objc final public func checkTrialOrIntroDiscountEligibility(productIdentifiers: [Swift.String]) async -> [Swift.String : RevenueCat.IntroEligibility]
  final public func checkTrialOrIntroDiscountEligibility(packages: [RevenueCat.Package]) async -> [RevenueCat.Package : RevenueCat.IntroEligibility]
  @objc(checkTrialOrIntroDiscountEligibilityForProduct:completion:) final public func checkTrialOrIntroDiscountEligibility(product: RevenueCat.StoreProduct, completion: @escaping (RevenueCat.IntroEligibilityStatus) -> Swift.Void)
  @objc final public func checkTrialOrIntroDiscountEligibility(product: RevenueCat.StoreProduct) async -> RevenueCat.IntroEligibilityStatus
  @available(iOS 13.4, macCatalyst 13.4, *)
  @objc final public func showPriceConsentIfNeeded()
  @available(iOS 14.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @available(macOS, unavailable)
  @available(macCatalyst, unavailable)
  @objc final public func presentCodeRedemptionSheet()
  #if compiler(>=5.3) && $NonescapableTypes
  @objc(getPromotionalOfferForProductDiscount:withProduct:withCompletion:) final public func getPromotionalOffer(forProductDiscount discount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct, completion: @escaping (RevenueCat.PromotionalOffer?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  @objc final public func promotionalOffer(forProductDiscount discount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct) async throws -> RevenueCat.PromotionalOffer
  @objc final public func eligiblePromotionalOffers(forProduct product: RevenueCat.StoreProduct) async -> [RevenueCat.PromotionalOffer]
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 13.0, macOS 10.15, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc final public func showManageSubscriptions(completion: @escaping (RevenueCat.PublicError?) -> Swift.Void)
  #endif
  @available(iOS 13.0, macOS 10.15, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc final public func showManageSubscriptions() async throws
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForProduct:completion:) final public func beginRefundRequest(forProduct productID: Swift.String) async throws -> RevenueCat.RefundRequestStatus
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForEntitlement:completion:) final public func beginRefundRequest(forEntitlement entitlementID: Swift.String) async throws -> RevenueCat.RefundRequestStatus
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForActiveEntitlementWithCompletion:) final public func beginRefundRequestForActiveEntitlement() async throws -> RevenueCat.RefundRequestStatus
  @available(iOS 16.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  final public func showStoreMessages(for types: Swift.Set<RevenueCat.StoreMessageType> = Set(StoreMessageType.allCases)) async
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
  final public func recordPurchase(_ purchaseResult: StoreKit.Product.PurchaseResult) async throws -> RevenueCat.StoreTransaction?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func redeemWebPurchase(webPurchaseRedemption: RevenueCat.WebPurchaseRedemption, completion: @escaping (RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  final public func redeemWebPurchase(_ webPurchaseRedemption: RevenueCat.WebPurchaseRedemption) async -> RevenueCat.WebPurchaseRedemptionResult
}
extension RevenueCat.Purchases {
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func getVirtualCurrencies(completion: @escaping @Sendable (RevenueCat.VirtualCurrencies?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var cachedVirtualCurrencies: RevenueCat.VirtualCurrencies? {
    @objc get
  }
  #endif
  final public func virtualCurrencies() async throws -> RevenueCat.VirtualCurrencies
  @objc final public func invalidateVirtualCurrenciesCache()
}
@available(iOS 15.0, tvOS 15.0, macOS 12.0, watchOS 8.0, *)
extension RevenueCat.Purchases {
  final public func track(paywallEvent: RevenueCat.PaywallEvent) async
  @available(iOS 15.0, macOS 12.0, watchOS 8.0, tvOS 15.0, *)
  public static let paywallImageDownloadSession: Foundation.URLSession
}
extension RevenueCat.Purchases {
  #if compiler(>=5.3) && $NonescapableTypes
  final public func overridePreferredUILocale(_ locale: Swift.String?)
  #endif
}
extension RevenueCat.Purchases {
  @discardableResult
  @objc(configureWithConfiguration:) public static func configure(with configuration: RevenueCat.Configuration) -> RevenueCat.Purchases
  @discardableResult
  @objc(configureWithConfigurationBuilder:) public static func configure(with builder: RevenueCat.Configuration.Builder) -> RevenueCat.Purchases
  @discardableResult
  @objc(configureWithAPIKey:) public static func configure(withAPIKey apiKey: Swift.String) -> RevenueCat.Purchases
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_disfavoredOverload @objc(configureWithAPIKey:appUserID:) public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.String?) -> RevenueCat.Purchases
  #endif
  @available(*, deprecated, message: "The appUserID passed to logIn is a constant string known at compile time.\nThis is likely a programmer error. This ID is used to identify the current user.\nSee https://docs.revenuecat.com/docs/user-ids for more information.")
  @discardableResult
  public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.StaticString) -> RevenueCat.Purchases
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_disfavoredOverload @objc(configureWithAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:) public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.String?, purchasesAreCompletedBy: RevenueCat.PurchasesAreCompletedBy, storeKitVersion: RevenueCat.StoreKitVersion) -> RevenueCat.Purchases
  #endif
  @available(*, deprecated, message: "The appUserID passed to logIn is a constant string known at compile time.\nThis is likely a programmer error. This ID is used to identify the current user.\nSee https://docs.revenuecat.com/docs/user-ids for more information.")
  @discardableResult
  public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.StaticString, purchasesAreCompletedBy: RevenueCat.PurchasesAreCompletedBy, storeKitVersion: RevenueCat.StoreKitVersion) -> RevenueCat.Purchases
}
extension RevenueCat.Purchases {
  @available(*, deprecated, message: "use Purchases.logLevel instead")
  @objc public static var debugLogsEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "Configure behavior through the RevenueCat dashboard instead. If you have configured the \"Legacy\" restore\nbehavior in the [RevenueCat Dashboard](app.revenuecat.com) and are currently setting this to `true`, keep\nthis setting active.")
  @objc final public var allowSharingAppStoreAccount: Swift.Bool {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "Use ``purchasesAreCompletedBy`` instead.")
  @objc final public var finishTransactions: Swift.Bool {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "Use the set<NetworkId> functions instead")
  @objc public static func addAttributionData(_ data: [Swift.String : Any], fromNetwork network: RevenueCat.AttributionNetwork)
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "Use the set<NetworkId> functions instead")
  @objc(addAttributionData:fromNetwork:forNetworkUserId:) public static func addAttributionData(_ data: [Swift.String : Any], from network: RevenueCat.AttributionNetwork, forNetworkUserId networkUserId: Swift.String?)
  #endif
}
extension RevenueCat.Purchases : @unchecked Swift.Sendable {
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension RevenueCat.Purchases {
  final public func eligibleWinBackOffers(forProduct product: RevenueCat.StoreProduct) async throws -> [RevenueCat.WinBackOffer]
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  final public func eligibleWinBackOffers(forPackage package: RevenueCat.Package) async throws -> [RevenueCat.WinBackOffer]
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func eligibleWinBackOffers(forProduct product: RevenueCat.StoreProduct, completion: @escaping @Sendable ([RevenueCat.WinBackOffer]?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @objc final public func eligibleWinBackOffers(forPackage package: RevenueCat.Package, completion: @escaping @Sendable ([RevenueCat.WinBackOffer]?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
}
@objc(RCSubscriptionPeriod) final public class SubscriptionPeriod : ObjectiveC.NSObject {
  @objc final public let value: Swift.Int
  @objc final public let unit: RevenueCat.SubscriptionPeriod.Unit
  public init(value: Swift.Int, unit: RevenueCat.SubscriptionPeriod.Unit)
  @objc(RCSubscriptionPeriodUnit) public enum Unit : Swift.Int {
    case day = 0
    case week = 1
    case month = 2
    case year = 3
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  #endif
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.SubscriptionPeriod {
  @available(iOS, unavailable, renamed: "value")
  @available(tvOS, unavailable, renamed: "value")
  @available(watchOS, unavailable, renamed: "value")
  @available(macOS, unavailable, renamed: "value")
  @objc final public var numberOfUnits: Swift.Int {
    @objc get
  }
}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.Sendable {
}
extension RevenueCat.SubscriptionPeriod : Swift.Sendable {
}
extension RevenueCat.SubscriptionPeriod {
  final public func numberOfUnitsAs(unit: RevenueCat.SubscriptionPeriod.Unit) -> Foundation.Decimal
}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RevenueCat.SubscriptionPeriod {
  @objc override final public var debugDescription: Swift.String {
    @objc get
  }
}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.Codable {
}
extension RevenueCat.SubscriptionPeriod : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@objc(RCPurchaseOwnershipType) public enum PurchaseOwnershipType : Swift.Int {
  case purchased = 0
  case familyShared = 1
  case unknown = 2
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.PurchaseOwnershipType : Swift.CaseIterable {
  public typealias AllCases = [RevenueCat.PurchaseOwnershipType]
  nonisolated public static var allCases: [RevenueCat.PurchaseOwnershipType] {
    get
  }
}
extension RevenueCat.PurchaseOwnershipType : Swift.Sendable {
}
@_hasMissingDesignatedInitializers @available(iOS 16.0, *)
@objc(RCDebugViewController) @_Concurrency.MainActor @preconcurrency final public class DebugViewController : UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc override final public func loadView()
  @_Concurrency.MainActor @preconcurrency @objc override final public func viewWillLayoutSubviews()
  @objc deinit
}
@available(iOS 16.0, *)
extension UIKit.UIViewController {
  @objc(rc_presentDebugRevenueCatOverlayAnimated:) @_Concurrency.MainActor @preconcurrency dynamic public func presentDebugRevenueCatOverlay(animated: Swift.Bool = true)
}
public struct TestStoreProduct {
  public var localizedTitle: Swift.String
  public var price: Foundation.Decimal
  public var currencyCode: Swift.String?
  public var localizedPriceString: Swift.String
  public var localizedPricePerDay: Swift.String?
  public var localizedPricePerWeek: Swift.String?
  public var localizedPricePerMonth: Swift.String?
  public var localizedPricePerYear: Swift.String?
  public var productIdentifier: Swift.String
  public var productType: RevenueCat.StoreProduct.ProductType
  public var localizedDescription: Swift.String
  public var subscriptionGroupIdentifier: Swift.String?
  public var subscriptionPeriod: RevenueCat.SubscriptionPeriod?
  public var isFamilyShareable: Swift.Bool
  public var introductoryDiscount: RevenueCat.StoreProductDiscount?
  public var discounts: [RevenueCat.StoreProductDiscount]
  public var locale: Foundation.Locale
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, message: "Use init(localizedTitle:price:currencyCode:localizedPriceString:productIdentifier:productType:localizedDescription:subscriptionGroupIdentifier:subscriptionPeriod:isFamilyShareable:introductoryDiscount:discounts:locale:) instead")
  public init(localizedTitle: Swift.String, price: Foundation.Decimal, localizedPriceString: Swift.String, productIdentifier: Swift.String, productType: RevenueCat.StoreProduct.ProductType, localizedDescription: Swift.String, subscriptionGroupIdentifier: Swift.String? = nil, subscriptionPeriod: RevenueCat.SubscriptionPeriod? = nil, isFamilyShareable: Swift.Bool = false, introductoryDiscount: RevenueCat.TestStoreProductDiscount? = nil, discounts: [RevenueCat.TestStoreProductDiscount] = [], locale: Foundation.Locale = .current)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(localizedTitle: Swift.String, price: Foundation.Decimal, currencyCode: Swift.String, localizedPriceString: Swift.String, productIdentifier: Swift.String, productType: RevenueCat.StoreProduct.ProductType, localizedDescription: Swift.String, subscriptionGroupIdentifier: Swift.String? = nil, subscriptionPeriod: RevenueCat.SubscriptionPeriod? = nil, isFamilyShareable: Swift.Bool = false, introductoryDiscount: RevenueCat.TestStoreProductDiscount? = nil, discounts: [RevenueCat.TestStoreProductDiscount] = [], locale: Foundation.Locale)
  #endif
}
extension RevenueCat.TestStoreProduct {
  public func toStoreProduct() -> RevenueCat.StoreProduct
}
extension RevenueCat.PaywallData {
  #if compiler(>=5.3) && $NonescapableTypes
  public var locale: Foundation.Locale? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var localizedConfiguration: RevenueCat.PaywallData.LocalizedConfiguration? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var localizedConfigurationByTier: [Swift.String : RevenueCat.PaywallData.LocalizedConfiguration]? {
    get
  }
  #endif
}
extension RevenueCat.PaywallComponent {
  final public class PurchaseButtonComponent : RevenueCat.PaywallComponentBase {
    final public let stack: RevenueCat.PaywallComponent.StackComponent
    final public let action: RevenueCat.PaywallComponent.PurchaseButtonComponent.Action?
    final public let method: RevenueCat.PaywallComponent.PurchaseButtonComponent.Method?
    public enum Action : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      case inAppCheckout
      case webCheckout
      case webProductSelection
      #if compiler(>=5.3) && $NonescapableTypes
      public init?(rawValue: Swift.String)
      #endif
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public enum Method : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      case inAppCheckout
      case webCheckout(RevenueCat.PaywallComponent.PurchaseButtonComponent.WebCheckout)
      case webProductSelection(RevenueCat.PaywallComponent.PurchaseButtonComponent.WebCheckout)
      case customWebCheckout(RevenueCat.PaywallComponent.PurchaseButtonComponent.CustomWebCheckout)
      case unknown
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
      public static func == (a: RevenueCat.PaywallComponent.PurchaseButtonComponent.Method, b: RevenueCat.PaywallComponent.PurchaseButtonComponent.Method) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct WebCheckout : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      public let autoDismiss: Swift.Bool?
      public let openMethod: RevenueCat.PaywallComponent.ButtonComponent.URLMethod?
      #if compiler(>=5.3) && $NonescapableTypes
      public init(autoDismiss: Swift.Bool? = nil, openMethod: RevenueCat.PaywallComponent.ButtonComponent.URLMethod? = nil)
      #endif
      public static func == (a: RevenueCat.PaywallComponent.PurchaseButtonComponent.WebCheckout, b: RevenueCat.PaywallComponent.PurchaseButtonComponent.WebCheckout) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct CustomWebCheckout : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      public struct CustomURL : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
        public let url: RevenueCat.PaywallComponent.LocalizationKey
        public let packageParam: Swift.String?
        #if compiler(>=5.3) && $NonescapableTypes
        public init(url: RevenueCat.PaywallComponent.LocalizationKey, packageParam: Swift.String? = nil)
        #endif
        public static func == (a: RevenueCat.PaywallComponent.PurchaseButtonComponent.CustomWebCheckout.CustomURL, b: RevenueCat.PaywallComponent.PurchaseButtonComponent.CustomWebCheckout.CustomURL) -> Swift.Bool
        public func encode(to encoder: any Swift.Encoder) throws
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
        public init(from decoder: any Swift.Decoder) throws
      }
      #if compiler(>=5.3) && $NonescapableTypes
      public init(customUrl: RevenueCat.PaywallComponent.PurchaseButtonComponent.CustomWebCheckout.CustomURL, autoDismiss: Swift.Bool? = nil, openMethod: RevenueCat.PaywallComponent.ButtonComponent.URLMethod? = nil)
      #endif
      public let customUrl: RevenueCat.PaywallComponent.PurchaseButtonComponent.CustomWebCheckout.CustomURL
      public let autoDismiss: Swift.Bool?
      public let openMethod: RevenueCat.PaywallComponent.ButtonComponent.URLMethod?
      public static func == (a: RevenueCat.PaywallComponent.PurchaseButtonComponent.CustomWebCheckout, b: RevenueCat.PaywallComponent.PurchaseButtonComponent.CustomWebCheckout) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init(stack: RevenueCat.PaywallComponent.StackComponent, action: RevenueCat.PaywallComponent.PurchaseButtonComponent.Action?, method: RevenueCat.PaywallComponent.PurchaseButtonComponent.Method?)
    #endif
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PurchaseButtonComponent, rhs: RevenueCat.PaywallComponent.PurchaseButtonComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension RevenueCat.PurchaseOwnershipType : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PurchaseOwnershipType : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension RevenueCat.PeriodType : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PeriodType : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension RevenueCat.PurchasesReceiptParser {
  @objc public static let `default`: RevenueCat.PurchasesReceiptParser
}
public struct AppleReceipt : Swift.Equatable {
  public let environment: RevenueCat.AppleReceipt.Environment
  public let bundleId: Swift.String
  public let applicationVersion: Swift.String
  public let originalApplicationVersion: Swift.String?
  public let opaqueValue: Foundation.Data
  public let sha1Hash: Foundation.Data
  public let creationDate: Foundation.Date
  public let expirationDate: Foundation.Date?
  public let inAppPurchases: [RevenueCat.AppleReceipt.InAppPurchase]
  public static func == (a: RevenueCat.AppleReceipt, b: RevenueCat.AppleReceipt) -> Swift.Bool
}
extension RevenueCat.AppleReceipt {
  public enum Environment : Swift.String {
    case production
    case sandbox
    case xcode
    case unknown
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension RevenueCat.AppleReceipt : Swift.Sendable {
}
extension RevenueCat.AppleReceipt.Environment : Swift.Sendable {
}
extension RevenueCat.AppleReceipt : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.AppleReceipt.Environment : Swift.Codable {
}
extension RevenueCat.AppleReceipt : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Foundation.URL {
  #if compiler(>=5.3) && $NonescapableTypes
  public var asWebPurchaseRedemption: RevenueCat.WebPurchaseRedemption? {
    get
  }
  #endif
}
@_hasMissingDesignatedInitializers @objc(RCProductPaidPrice) final public class ProductPaidPrice : ObjectiveC.NSObject, Swift.Sendable {
  @objc final public let currency: Swift.String
  @objc final public let amount: Swift.Double
  @objc final public let formatted: Swift.String
  convenience public init(currency: Swift.String, amount: Swift.Double)
  convenience public init(currency: Swift.String, amount: Swift.Double, locale: Foundation.Locale = .current)
  @objc deinit
}
extension RevenueCat.PaywallComponent {
  final public class VideoComponent : RevenueCat.PaywallComponentBase {
    final public let source: RevenueCat.PaywallComponent.ThemeVideoUrls
    final public let fallbackSource: RevenueCat.PaywallComponent.ThemeImageUrls?
    final public let visible: Swift.Bool?
    final public let showControls: Swift.Bool
    final public let autoPlay: Swift.Bool
    final public let loop: Swift.Bool
    final public let muteAudio: Swift.Bool
    final public let size: RevenueCat.PaywallComponent.Size
    final public let fitMode: RevenueCat.PaywallComponent.FitMode
    final public let maskShape: RevenueCat.PaywallComponent.MaskShape?
    final public let colorOverlay: RevenueCat.PaywallComponent.ColorScheme?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialVideoComponent>?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(visible: Swift.Bool? = nil, source: RevenueCat.PaywallComponent.ThemeVideoUrls, fallbackSource: RevenueCat.PaywallComponent.ThemeImageUrls? = nil, showControls: Swift.Bool = false, autoPlay: Swift.Bool = true, loop: Swift.Bool = true, muteAudio: Swift.Bool = true, size: RevenueCat.PaywallComponent.Size = .init(width: .fill, height: .fit), fitMode: RevenueCat.PaywallComponent.FitMode = .fit, maskShape: RevenueCat.PaywallComponent.MaskShape? = nil, colorOverlay: RevenueCat.PaywallComponent.ColorScheme? = nil, padding: RevenueCat.PaywallComponent.Padding? = nil, margin: RevenueCat.PaywallComponent.Padding? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil, overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialVideoComponent>? = nil)
    #endif
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.VideoComponent, rhs: RevenueCat.PaywallComponent.VideoComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class PartialVideoComponent : RevenueCat.PaywallPartialComponent {
    final public let source: RevenueCat.PaywallComponent.ThemeVideoUrls?
    final public let fallbackSource: RevenueCat.PaywallComponent.ThemeImageUrls?
    final public let visible: Swift.Bool?
    final public let showControls: Swift.Bool?
    final public let autoPlay: Swift.Bool?
    final public let loop: Swift.Bool?
    final public let muteAudio: Swift.Bool?
    final public let size: RevenueCat.PaywallComponent.Size?
    final public let fitMode: RevenueCat.PaywallComponent.FitMode?
    final public let maskShape: RevenueCat.PaywallComponent.MaskShape?
    final public let colorOverlay: RevenueCat.PaywallComponent.ColorScheme?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(source: RevenueCat.PaywallComponent.ThemeVideoUrls? = nil, fallbackSource: RevenueCat.PaywallComponent.ThemeImageUrls? = nil, visible: Swift.Bool? = true, showControls: Swift.Bool? = nil, autoPlay: Swift.Bool? = nil, loop: Swift.Bool? = nil, muteAudio: Swift.Bool? = nil, size: RevenueCat.PaywallComponent.Size? = nil, fitMode: RevenueCat.PaywallComponent.FitMode? = nil, maskShape: RevenueCat.PaywallComponent.MaskShape? = nil, colorOverlay: RevenueCat.PaywallComponent.ColorScheme? = nil, padding: RevenueCat.PaywallComponent.Padding? = nil, margin: RevenueCat.PaywallComponent.Padding? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil)
    #endif
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PartialVideoComponent, rhs: RevenueCat.PaywallComponent.PartialVideoComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension RevenueCat.Store : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.Store : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers @objc(RCPurchaseParams) final public class PurchaseParams : ObjectiveC.NSObject, Swift.Sendable {
  @objc(RCPurchaseParamsBuilder) public class Builder : ObjectiveC.NSObject {
    @objc public init(package: RevenueCat.Package)
    @objc public init(product: RevenueCat.StoreProduct)
    @objc public func with(promotionalOffer: RevenueCat.PromotionalOffer) -> Self
    @objc public func with(quantity: Swift.Int) -> Self
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    @objc public func with(winBackOffer: RevenueCat.WinBackOffer) -> Self
    @objc public func build() -> RevenueCat.PurchaseParams
    @objc deinit
  }
  @objc deinit
}
public struct UIConfig : Swift.Codable, Swift.Equatable, Swift.Sendable {
  public struct AppConfig : Swift.Codable, Swift.Equatable, Swift.Sendable {
    public var colors: [Swift.String : RevenueCat.PaywallComponent.ColorScheme]
    public var fonts: [Swift.String : RevenueCat.UIConfig.FontsConfig]
    public init(colors: [Swift.String : RevenueCat.PaywallComponent.ColorScheme], fonts: [Swift.String : RevenueCat.UIConfig.FontsConfig])
    public static func == (a: RevenueCat.UIConfig.AppConfig, b: RevenueCat.UIConfig.AppConfig) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct FontsConfig : Swift.Codable, Swift.Equatable, Swift.Sendable {
    public static func == (a: RevenueCat.UIConfig.FontsConfig, b: RevenueCat.UIConfig.FontsConfig) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct VariableConfig : Swift.Codable, Swift.Equatable, Swift.Sendable {
    public var variableCompatibilityMap: [Swift.String : Swift.String]
    public var functionCompatibilityMap: [Swift.String : Swift.String]
    public init(variableCompatibilityMap: [Swift.String : Swift.String], functionCompatibilityMap: [Swift.String : Swift.String])
    public static func == (a: RevenueCat.UIConfig.VariableConfig, b: RevenueCat.UIConfig.VariableConfig) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct CustomVariableDefinition : Swift.Codable, Swift.Equatable, Swift.Sendable {
    public let type: Swift.String
    public let defaultValue: Swift.String
    public init(type: Swift.String, defaultValue: Swift.String)
    public static func == (a: RevenueCat.UIConfig.CustomVariableDefinition, b: RevenueCat.UIConfig.CustomVariableDefinition) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public var app: RevenueCat.UIConfig.AppConfig
  public var localizations: [Swift.String : [Swift.String : Swift.String]]
  public var variableConfig: RevenueCat.UIConfig.VariableConfig
  public var customVariables: [Swift.String : RevenueCat.UIConfig.CustomVariableDefinition]
  public init(app: RevenueCat.UIConfig.AppConfig, localizations: [Swift.String : [Swift.String : Swift.String]], variableConfig: RevenueCat.UIConfig.VariableConfig, customVariables: [Swift.String : RevenueCat.UIConfig.CustomVariableDefinition] = [:])
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: RevenueCat.UIConfig, b: RevenueCat.UIConfig) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
extension RevenueCat.PaywallComponent {
  final public class TimelineComponent : RevenueCat.PaywallComponentBase {
    final public let visible: Swift.Bool?
    final public let iconAlignment: RevenueCat.PaywallComponent.TimelineComponent.IconAlignment?
    final public let itemSpacing: CoreFoundation.CGFloat?
    final public let textSpacing: CoreFoundation.CGFloat?
    final public let columnGutter: CoreFoundation.CGFloat?
    final public let size: RevenueCat.PaywallComponent.Size
    final public let padding: RevenueCat.PaywallComponent.Padding
    final public let margin: RevenueCat.PaywallComponent.Padding
    final public let items: [RevenueCat.PaywallComponent.TimelineComponent.Item]
    final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialTimelineComponent>?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(visible: Swift.Bool? = nil, iconAlignment: RevenueCat.PaywallComponent.TimelineComponent.IconAlignment?, itemSpacing: CoreFoundation.CGFloat?, textSpacing: CoreFoundation.CGFloat?, columnGutter: CoreFoundation.CGFloat?, size: RevenueCat.PaywallComponent.Size, padding: RevenueCat.PaywallComponent.Padding, margin: RevenueCat.PaywallComponent.Padding, items: [RevenueCat.PaywallComponent.TimelineComponent.Item], overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialTimelineComponent>?)
    #endif
    public static func == (lhs: RevenueCat.PaywallComponent.TimelineComponent, rhs: RevenueCat.PaywallComponent.TimelineComponent) -> Swift.Bool
    final public func hash(into hasher: inout Swift.Hasher)
    final public class Item : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      final public let title: RevenueCat.PaywallComponent.TextComponent
      final public let description: RevenueCat.PaywallComponent.TextComponent?
      final public let icon: RevenueCat.PaywallComponent.IconComponent
      final public let connector: RevenueCat.PaywallComponent.TimelineComponent.Connector?
      final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialTimelineItem>?
      #if compiler(>=5.3) && $NonescapableTypes
      public init(title: RevenueCat.PaywallComponent.TextComponent, description: RevenueCat.PaywallComponent.TextComponent?, icon: RevenueCat.PaywallComponent.IconComponent, connector: RevenueCat.PaywallComponent.TimelineComponent.Connector, overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialTimelineItem>?)
      #endif
      public static func == (lhs: RevenueCat.PaywallComponent.TimelineComponent.Item, rhs: RevenueCat.PaywallComponent.TimelineComponent.Item) -> Swift.Bool
      final public func hash(into hasher: inout Swift.Hasher)
      @objc deinit
      final public func encode(to encoder: any Swift.Encoder) throws
      final public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    final public class Connector : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      final public let width: CoreFoundation.CGFloat
      final public let color: RevenueCat.PaywallComponent.ColorScheme
      final public let margin: RevenueCat.PaywallComponent.Padding
      public init(width: CoreFoundation.CGFloat, color: RevenueCat.PaywallComponent.ColorScheme, margin: RevenueCat.PaywallComponent.Padding)
      public static func == (lhs: RevenueCat.PaywallComponent.TimelineComponent.Connector, rhs: RevenueCat.PaywallComponent.TimelineComponent.Connector) -> Swift.Bool
      final public func hash(into hasher: inout Swift.Hasher)
      @objc deinit
      final public func encode(to encoder: any Swift.Encoder) throws
      final public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public enum IconAlignment : Swift.String, Swift.Sendable, Swift.Codable, Swift.Equatable, Swift.Hashable {
      case title
      case titleAndDescription
      public init(from decoder: any Swift.Decoder) throws
      #if compiler(>=5.3) && $NonescapableTypes
      public init?(rawValue: Swift.String)
      #endif
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class PartialTimelineComponent : RevenueCat.PaywallPartialComponent {
    final public let visible: Swift.Bool?
    final public let iconAlignment: RevenueCat.PaywallComponent.TimelineComponent.IconAlignment?
    final public let itemSpacing: CoreFoundation.CGFloat?
    final public let textSpacing: CoreFoundation.CGFloat?
    final public let columnGutter: CoreFoundation.CGFloat?
    final public let size: RevenueCat.PaywallComponent.Size?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(visible: Swift.Bool? = nil, iconAlignment: RevenueCat.PaywallComponent.TimelineComponent.IconAlignment?, itemSpacing: CoreFoundation.CGFloat?, textSpacing: CoreFoundation.CGFloat?, columnGutter: CoreFoundation.CGFloat?, size: RevenueCat.PaywallComponent.Size?, padding: RevenueCat.PaywallComponent.Padding?, margin: RevenueCat.PaywallComponent.Padding?)
    #endif
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PartialTimelineComponent, rhs: RevenueCat.PaywallComponent.PartialTimelineComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class PartialTimelineItem : RevenueCat.PaywallPartialComponent {
    final public let visible: Swift.Bool?
    final public let connector: RevenueCat.PaywallComponent.TimelineComponent.Connector?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(visible: Swift.Bool?, connector: RevenueCat.PaywallComponent.TimelineComponent.Connector?)
    #endif
    public static func == (lhs: RevenueCat.PaywallComponent.PartialTimelineItem, rhs: RevenueCat.PaywallComponent.PartialTimelineItem) -> Swift.Bool
    final public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@objc(RCEntitlementInfos) final public class EntitlementInfos : ObjectiveC.NSObject {
  @objc final public let all: [Swift.String : RevenueCat.EntitlementInfo]
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public subscript(key: Swift.String) -> RevenueCat.EntitlementInfo? {
    @objc get
  }
  #endif
  @objc final public var verification: RevenueCat.VerificationResult {
    @objc get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  #endif
  public init(entitlements: [Swift.String : RevenueCat.EntitlementInfo] = [:], verification: RevenueCat.VerificationResult = .notRequested)
  @objc deinit
}
extension RevenueCat.EntitlementInfos {
  @objc final public var active: [Swift.String : RevenueCat.EntitlementInfo] {
    @objc get
  }
  @objc final public var activeInCurrentEnvironment: [Swift.String : RevenueCat.EntitlementInfo] {
    @objc get
  }
  @objc final public var activeInAnyEnvironment: [Swift.String : RevenueCat.EntitlementInfo] {
    @objc get
  }
}
extension RevenueCat.EntitlementInfos : Swift.Sendable {
}
@objc(RCStoreMessageType) public enum StoreMessageType : Swift.Int, Swift.CaseIterable, Swift.Sendable {
  case billingIssue = 0
  case priceIncreaseConsent
  case generic
  case winBackOffer
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias AllCases = [RevenueCat.StoreMessageType]
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [RevenueCat.StoreMessageType] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc(RCPresentedOfferingContext) final public class PresentedOfferingContext : ObjectiveC.NSObject {
  @objc(RCTargetingContext) final public class TargetingContext : ObjectiveC.NSObject {
    @objc final public let revision: Swift.Int
    @objc final public let ruleId: Swift.String
    @objc public init(revision: Swift.Int, ruleId: Swift.String)
    @objc deinit
  }
  @objc final public let offeringIdentifier: Swift.String
  @objc final public let placementIdentifier: Swift.String?
  @objc final public let targetingContext: RevenueCat.PresentedOfferingContext.TargetingContext?
  #if compiler(>=5.3) && $NonescapableTypes
  @objc public init(offeringIdentifier: Swift.String, placementIdentifier: Swift.String?, targetingContext: RevenueCat.PresentedOfferingContext.TargetingContext?)
  #endif
  @objc convenience public init(offeringIdentifier: Swift.String)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  #endif
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
@objc(RCPackage) final public class Package : ObjectiveC.NSObject {
  @objc final public let identifier: Swift.String
  @objc final public let packageType: RevenueCat.PackageType
  @objc final public let storeProduct: RevenueCat.StoreProduct
  @objc final public let presentedOfferingContext: RevenueCat.PresentedOfferingContext
  @objc final public var localizedPriceString: Swift.String {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var localizedIntroductoryPriceString: Swift.String? {
    @objc get
  }
  #endif
  @objc final public let webCheckoutUrl: Foundation.URL?
  #if compiler(>=5.3) && $NonescapableTypes
  @objc convenience public init(identifier: Swift.String, packageType: RevenueCat.PackageType, storeProduct: RevenueCat.StoreProduct, offeringIdentifier: Swift.String, webCheckoutUrl: Foundation.URL?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc public init(identifier: Swift.String, packageType: RevenueCat.PackageType, storeProduct: RevenueCat.StoreProduct, presentedOfferingContext: RevenueCat.PresentedOfferingContext, webCheckoutUrl: Foundation.URL?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  #endif
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
@objc extension RevenueCat.Package {
  #if compiler(>=5.3) && $NonescapableTypes
  @objc public static func string(from packageType: RevenueCat.PackageType) -> Swift.String?
  #endif
  @objc public static func packageType(from string: Swift.String) -> RevenueCat.PackageType
  @objc final public var offeringIdentifier: Swift.String {
    @objc get
  }
}
extension RevenueCat.Package : Swift.Identifiable {
  final public var id: Swift.String {
    get
  }
  public typealias ID = Swift.String
}
extension RevenueCat.Package : Swift.Sendable {
}
extension RevenueCat.PresentedOfferingContext : Swift.Sendable {
}
extension RevenueCat.PresentedOfferingContext.TargetingContext : Swift.Sendable {
}
extension RevenueCat.PaywallComponent {
  final public class ButtonComponent : RevenueCat.PaywallComponentBase {
    final public let action: RevenueCat.PaywallComponent.ButtonComponent.Action
    final public let stack: RevenueCat.PaywallComponent.StackComponent
    final public let transition: RevenueCat.PaywallComponent.Transition?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(action: RevenueCat.PaywallComponent.ButtonComponent.Action, stack: RevenueCat.PaywallComponent.StackComponent, transition: RevenueCat.PaywallComponent.Transition? = nil)
    #endif
    required public init(from decoder: any Swift.Decoder) throws
    final public func encode(to encoder: any Swift.Encoder) throws
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.ButtonComponent, rhs: RevenueCat.PaywallComponent.ButtonComponent) -> Swift.Bool
    public enum Action : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      case restorePurchases
      case navigateBack
      case navigateTo(destination: RevenueCat.PaywallComponent.ButtonComponent.Destination)
      case unknown
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
      public static func == (a: RevenueCat.PaywallComponent.ButtonComponent.Action, b: RevenueCat.PaywallComponent.ButtonComponent.Action) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Destination : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      case customerCenter
      case offerCode
      case privacyPolicy(urlLid: Swift.String, method: RevenueCat.PaywallComponent.ButtonComponent.URLMethod)
      case sheet(sheet: RevenueCat.PaywallComponent.ButtonComponent.Sheet)
      case terms(urlLid: Swift.String, method: RevenueCat.PaywallComponent.ButtonComponent.URLMethod)
      case webPaywallLink(urlLid: Swift.String, method: RevenueCat.PaywallComponent.ButtonComponent.URLMethod)
      case url(urlLid: Swift.String, method: RevenueCat.PaywallComponent.ButtonComponent.URLMethod)
      case unknown
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
      public static func == (a: RevenueCat.PaywallComponent.ButtonComponent.Destination, b: RevenueCat.PaywallComponent.ButtonComponent.Destination) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum URLMethod : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      case inAppBrowser
      case externalBrowser
      case deepLink
      case unknown
      public init(from decoder: any Swift.Decoder) throws
      #if compiler(>=5.3) && $NonescapableTypes
      public init?(rawValue: Swift.String)
      #endif
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public struct Sheet : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public let id: Swift.String
      public let name: Swift.String?
      public let stack: RevenueCat.PaywallComponent.StackComponent
      public let backgroundBlur: Swift.Bool
      public let size: RevenueCat.PaywallComponent.Size?
      #if compiler(>=5.3) && $NonescapableTypes
      public init(id: Swift.String, name: Swift.String?, stack: RevenueCat.PaywallComponent.StackComponent, backgroundBlur: Swift.Bool, size: RevenueCat.PaywallComponent.Size?)
      #endif
      public static func == (a: RevenueCat.PaywallComponent.ButtonComponent.Sheet, b: RevenueCat.PaywallComponent.ButtonComponent.Sheet) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    @objc deinit
    final public var hashValue: Swift.Int {
      get
    }
  }
}
@_hasMissingDesignatedInitializers @objc(RCConfiguration) final public class Configuration : ObjectiveC.NSObject {
  @objc public static func builder(withAPIKey apiKey: Swift.String) -> RevenueCat.Configuration.Builder
  @objc(RCConfigurationBuilder) public class Builder : ObjectiveC.NSObject {
    @objc public init(withAPIKey apiKey: Swift.String)
    @objc public func with(apiKey: Swift.String) -> RevenueCat.Configuration.Builder
    #if compiler(>=5.3) && $NonescapableTypes
    @_disfavoredOverload @objc public func with(appUserID: Swift.String?) -> RevenueCat.Configuration.Builder
    #endif
    @available(*, deprecated, message: "The appUserID passed to logIn is a constant string known at compile time.\nThis is likely a programmer error. This ID is used to identify the current user.\nSee https://docs.revenuecat.com/docs/user-ids for more information.")
    public func with(appUserID: Swift.StaticString) -> RevenueCat.Configuration.Builder
    @objc public func with(purchasesAreCompletedBy: RevenueCat.PurchasesAreCompletedBy, storeKitVersion: RevenueCat.StoreKitVersion) -> RevenueCat.Configuration.Builder
    @objc public func with(userDefaults: Foundation.UserDefaults) -> RevenueCat.Configuration.Builder
    @objc public func with(dangerousSettings: RevenueCat.DangerousSettings) -> RevenueCat.Configuration.Builder
    @objc public func with(networkTimeout: Foundation.TimeInterval) -> RevenueCat.Configuration.Builder
    @objc public func with(storeKit1Timeout: Foundation.TimeInterval) -> RevenueCat.Configuration.Builder
    @objc public func with(platformInfo: RevenueCat.Purchases.PlatformInfo) -> RevenueCat.Configuration.Builder
    @objc public func with(showStoreMessagesAutomatically: Swift.Bool) -> RevenueCat.Configuration.Builder
    @objc public func with(entitlementVerificationMode mode: RevenueCat.Configuration.EntitlementVerificationMode) -> RevenueCat.Configuration.Builder
    @available(iOS 15.0, tvOS 15.0, macOS 12.0, watchOS 8.0, *)
    @objc public func with(diagnosticsEnabled: Swift.Bool) -> RevenueCat.Configuration.Builder
    @objc public func with(storeKitVersion version: RevenueCat.StoreKitVersion) -> RevenueCat.Configuration.Builder
    @objc public func with(automaticDeviceIdentifierCollectionEnabled: Swift.Bool) -> RevenueCat.Configuration.Builder
    @objc public func build() -> RevenueCat.Configuration
    #if compiler(>=5.3) && $NonescapableTypes
    public func with(preferredUILocaleOverride: Swift.String?) -> RevenueCat.Configuration.Builder
    #endif
    @objc deinit
  }
  @objc deinit
}
extension RevenueCat.Configuration {
  @objc(RCEntitlementVerificationMode) public enum EntitlementVerificationMode : Swift.Int {
    case disabled = 0
    case informational = 1
    @available(*, unavailable, message: "This will be supported in a future release")
    case enforced = 2
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
public enum PaywallViewMode {
  case fullScreen
  @available(watchOS, unavailable)
  @available(macOS, unavailable)
  case footer
  @available(watchOS, unavailable)
  @available(macOS, unavailable)
  case condensedFooter
  public static let `default`: RevenueCat.PaywallViewMode
  public static func == (a: RevenueCat.PaywallViewMode, b: RevenueCat.PaywallViewMode) -> Swift.Bool
}
extension RevenueCat.PaywallViewMode {
  public var isFullScreen: Swift.Bool {
    get
  }
}
extension RevenueCat.PaywallViewMode : Swift.CaseIterable {
  public static var allCases: [RevenueCat.PaywallViewMode] {
    get
  }
  public typealias AllCases = [RevenueCat.PaywallViewMode]
}
extension RevenueCat.PaywallViewMode : Swift.Sendable {
}
extension RevenueCat.PaywallViewMode : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallViewMode : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TestStoreProductDiscount {
  public var identifier: Swift.String
  public var price: Foundation.Decimal
  public var localizedPriceString: Swift.String
  public var paymentMode: RevenueCat.StoreProductDiscount.PaymentMode
  public var subscriptionPeriod: RevenueCat.SubscriptionPeriod
  public var numberOfPeriods: Swift.Int
  public var type: RevenueCat.StoreProductDiscount.DiscountType
  public init(identifier: Swift.String, price: Foundation.Decimal, localizedPriceString: Swift.String, paymentMode: RevenueCat.StoreProductDiscount.PaymentMode, subscriptionPeriod: RevenueCat.SubscriptionPeriod, numberOfPeriods: Swift.Int, type: RevenueCat.StoreProductDiscount.DiscountType)
}
extension RevenueCat.TestStoreProductDiscount {
  public func toStoreProductDiscount() -> RevenueCat.StoreProductDiscount
}
@objc(RCIntroEligibilityStatus) public enum IntroEligibilityStatus : Swift.Int {
  case unknown = 0
  case ineligible
  case eligible
  case noIntroOfferExists
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.IntroEligibilityStatus : Swift.CaseIterable, Swift.Sendable {
  public typealias AllCases = [RevenueCat.IntroEligibilityStatus]
  nonisolated public static var allCases: [RevenueCat.IntroEligibilityStatus] {
    get
  }
}
extension RevenueCat.IntroEligibilityStatus : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension RevenueCat.IntroEligibilityStatus {
  public var isEligible: Swift.Bool {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(RCIntroEligibility) final public class IntroEligibility : ObjectiveC.NSObject {
  @objc final public let status: RevenueCat.IntroEligibilityStatus
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  #endif
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.IntroEligibility {
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc override final public var debugDescription: Swift.String {
    @objc get
  }
}
extension RevenueCat.IntroEligibility : Swift.Sendable {
}
@objc(RCCacheFetchPolicy) public enum CacheFetchPolicy : Swift.Int {
  case fromCacheOnly
  case fetchCurrent
  case notStaleCachedOrFetched
  case cachedOrFetched
  public static let `default`: RevenueCat.CacheFetchPolicy
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.CacheFetchPolicy : Swift.Sendable {
}
@available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
public typealias SK1ProductDiscount = StoreKit.SKProductDiscount
@available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
public typealias SK2ProductDiscount = StoreKit.Product.SubscriptionOffer
@_hasMissingDesignatedInitializers @objc(RCStoreProductDiscount) final public class StoreProductDiscount : ObjectiveC.NSObject {
  @objc(RCPaymentMode) public enum PaymentMode : Swift.Int {
    case payAsYouGo = 0
    case payUpFront = 1
    case freeTrial = 2
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(RCDiscountType) public enum DiscountType : Swift.Int {
    case introductory = 0
    case promotional = 1
    case winBack = 2
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.Int)
    #endif
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var offerIdentifier: Swift.String? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var currencyCode: Swift.String? {
    @objc get
  }
  #endif
  final public var price: Foundation.Decimal {
    get
  }
  @objc final public var localizedPriceString: Swift.String {
    @objc get
  }
  @objc final public var paymentMode: RevenueCat.StoreProductDiscount.PaymentMode {
    @objc get
  }
  @objc final public var subscriptionPeriod: RevenueCat.SubscriptionPeriod {
    @objc get
  }
  @objc final public var numberOfPeriods: Swift.Int {
    @objc get
  }
  @objc final public var type: RevenueCat.StoreProductDiscount.DiscountType {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  #endif
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.StoreProductDiscount : Swift.Sendable {
}
extension RevenueCat.StoreProductDiscount.PaymentMode : Swift.Sendable {
}
extension RevenueCat.StoreProductDiscount.DiscountType : Swift.Sendable {
}
extension RevenueCat.StoreProductDiscount {
  @objc(price) final public var priceDecimalNumber: Foundation.NSDecimalNumber {
    @objc get
  }
}
extension RevenueCat.StoreProductDiscount {
  public struct Data : Swift.Hashable {
    public static func == (a: RevenueCat.StoreProductDiscount.Data, b: RevenueCat.StoreProductDiscount.Data) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension RevenueCat.StoreProductDiscount {
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var sk1Discount: RevenueCat.SK1ProductDiscount? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  final public var sk2Discount: RevenueCat.SK2ProductDiscount? {
    get
  }
  #endif
}
extension RevenueCat.StoreProductDiscount : Swift.Encodable {
  final public func encode(to encoder: any Swift.Encoder) throws
}
extension RevenueCat.StoreProductDiscount.PaymentMode : Swift.Codable {
}
extension RevenueCat.StoreProductDiscount.DiscountType : Swift.Codable {
}
extension RevenueCat.StoreProductDiscount : Swift.Identifiable {
  final public var id: RevenueCat.StoreProductDiscount.Data {
    get
  }
  public typealias ID = RevenueCat.StoreProductDiscount.Data
}
extension RevenueCat.StoreProductDiscount {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerDay: Foundation.NSDecimalNumber? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerWeek: Foundation.NSDecimalNumber? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerMonth: Foundation.NSDecimalNumber? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerYear: Foundation.NSDecimalNumber? {
    @objc get
  }
  #endif
}
extension RevenueCat.PaywallComponent {
  final public class TextComponent : RevenueCat.PaywallComponentBase {
    final public let visible: Swift.Bool?
    final public let text: RevenueCat.PaywallComponent.LocalizationKey
    final public let fontName: Swift.String?
    final public let fontWeight: RevenueCat.PaywallComponent.FontWeight
    final public let color: RevenueCat.PaywallComponent.ColorScheme
    final public let fontSize: CoreFoundation.CGFloat
    final public let horizontalAlignment: RevenueCat.PaywallComponent.HorizontalAlignment
    final public let backgroundColor: RevenueCat.PaywallComponent.ColorScheme?
    final public let size: RevenueCat.PaywallComponent.Size
    final public let padding: RevenueCat.PaywallComponent.Padding
    final public let margin: RevenueCat.PaywallComponent.Padding
    final public let fontWeightInt: Swift.Int?
    final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialTextComponent>?
    final public var fontWeightResolved: RevenueCat.PaywallComponent.FontWeight {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init(visible: Swift.Bool? = nil, text: Swift.String, fontName: Swift.String? = nil, fontWeight: RevenueCat.PaywallComponent.FontWeight = .regular, color: RevenueCat.PaywallComponent.ColorScheme, backgroundColor: RevenueCat.PaywallComponent.ColorScheme? = nil, size: RevenueCat.PaywallComponent.Size = .init(width: .fill, height: .fit), padding: RevenueCat.PaywallComponent.Padding = .zero, margin: RevenueCat.PaywallComponent.Padding = .zero, fontSize: CoreFoundation.CGFloat = 16, horizontalAlignment: RevenueCat.PaywallComponent.HorizontalAlignment = .center, overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialTextComponent>? = nil, fontWeightInt: Swift.Int? = nil)
    #endif
    required public init(from decoder: any Swift.Decoder) throws
    final public func encode(to encoder: any Swift.Encoder) throws
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.TextComponent, rhs: RevenueCat.PaywallComponent.TextComponent) -> Swift.Bool
    @objc deinit
    final public var hashValue: Swift.Int {
      get
    }
  }
  final public class PartialTextComponent : RevenueCat.PaywallPartialComponent {
    final public let visible: Swift.Bool?
    final public let text: RevenueCat.PaywallComponent.LocalizationKey?
    final public let fontName: Swift.String?
    final public let fontWeight: RevenueCat.PaywallComponent.FontWeight?
    final public let color: RevenueCat.PaywallComponent.ColorScheme?
    final public let fontSize: CoreFoundation.CGFloat?
    final public let horizontalAlignment: RevenueCat.PaywallComponent.HorizontalAlignment?
    final public let backgroundColor: RevenueCat.PaywallComponent.ColorScheme?
    final public let size: RevenueCat.PaywallComponent.Size?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let fontWeightInt: Swift.Int?
    #if compiler(>=5.3) && $NonescapableTypes
    final public var fontWeightResolved: RevenueCat.PaywallComponent.FontWeight? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public init(visible: Swift.Bool? = true, text: RevenueCat.PaywallComponent.LocalizationKey? = nil, fontName: Swift.String? = nil, fontWeight: RevenueCat.PaywallComponent.FontWeight? = nil, color: RevenueCat.PaywallComponent.ColorScheme? = nil, backgroundColor: RevenueCat.PaywallComponent.ColorScheme? = nil, size: RevenueCat.PaywallComponent.Size? = nil, padding: RevenueCat.PaywallComponent.Padding? = nil, margin: RevenueCat.PaywallComponent.Padding? = nil, fontSize: CoreFoundation.CGFloat? = nil, horizontalAlignment: RevenueCat.PaywallComponent.HorizontalAlignment? = nil, fontWeightInt: Swift.Int? = nil)
    #endif
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PartialTextComponent, rhs: RevenueCat.PaywallComponent.PartialTextComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension RevenueCat.PurchasesDiagnostics.SDKHealthError : Foundation.CustomNSError {
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public struct PaywallColor {
  @frozen public enum ColorScheme : Swift.String {
    case light
    case dark
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var stringRepresentation: Swift.String
  public var underlyingColor: SwiftUICore.Color {
    get
  }
}
extension RevenueCat.PaywallColor {
  public init(stringRepresentation: Swift.String) throws
  @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
  public init(light: RevenueCat.PaywallColor, dark: RevenueCat.PaywallColor)
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SwiftUICore.Color {
  public var asPaywallColor: RevenueCat.PaywallColor {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension UIKit.UIColor {
  public var asPaywallColor: RevenueCat.PaywallColor {
    get
  }
}
extension RevenueCat.PaywallColor.ColorScheme : Swift.Equatable {
}
extension RevenueCat.PaywallColor.ColorScheme : Swift.Sendable {
}
extension RevenueCat.PaywallColor.ColorScheme : Swift.Codable {
}
extension RevenueCat.PaywallColor : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RevenueCat.PaywallColor : Swift.Equatable {
  public static func == (lhs: RevenueCat.PaywallColor, rhs: RevenueCat.PaywallColor) -> Swift.Bool
}
extension RevenueCat.PaywallColor : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallColor : Swift.Sendable {
}
extension RevenueCat.PaywallColor : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@objc(RCPurchasesDelegate) public protocol PurchasesDelegate : ObjectiveC.NSObjectProtocol {
  @available(swift, obsoleted: 1, renamed: "purchases(_:receivedUpdated:)")
  @available(iOS, obsoleted: 1)
  @available(macOS, obsoleted: 1)
  @available(tvOS, obsoleted: 1)
  @available(watchOS, obsoleted: 1)
  @objc(purchases:didReceiveUpdatedPurchaserInfo:) optional func purchases(_ purchases: RevenueCat.Purchases, didReceiveUpdated purchaserInfo: RevenueCat.CustomerInfo)
  @objc(purchases:receivedUpdatedCustomerInfo:) optional func purchases(_ purchases: RevenueCat.Purchases, receivedUpdated customerInfo: RevenueCat.CustomerInfo)
  @objc optional func purchases(_ purchases: RevenueCat.Purchases, readyForPromotedProduct product: RevenueCat.StoreProduct, purchase startPurchase: @escaping RevenueCat.StartPurchaseBlock)
  @available(iOS, obsoleted: 1, renamed: "purchases(_:readyForPromotedProduct:purchase:)")
  @available(tvOS, obsoleted: 1, renamed: "purchases(_:readyForPromotedProduct:purchase:)")
  @available(watchOS, obsoleted: 1, renamed: "purchases(_:readyForPromotedProduct:purchase:)")
  @available(macOS, obsoleted: 1, renamed: "purchases(_:readyForPromotedProduct:purchase:)")
  @available(macCatalyst, obsoleted: 1, renamed: "purchases(_:readyForPromotedProduct:purchase:)")
  @objc optional func purchases(_ purchases: RevenueCat.Purchases, shouldPurchasePromoProduct product: RevenueCat.StoreProduct, defermentBlock makeDeferredPurchase: @escaping RevenueCat.StartPurchaseBlock)
  @available(iOS 13.4, macCatalyst 13.4, *)
  @available(macOS, unavailable)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @objc optional var shouldShowPriceConsent: Swift.Bool { get }
}
public protocol PaywallPartialComponent : RevenueCat.PaywallComponentBase {
}
extension RevenueCat.PaywallComponent {
  public typealias ComponentOverrides<T> = [RevenueCat.PaywallComponent.ComponentOverride<T>] where T : RevenueCat.PaywallPartialComponent
  public struct ComponentOverride<T> : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable where T : RevenueCat.PaywallPartialComponent {
    public let conditions: [RevenueCat.PaywallComponent.Condition]
    public let properties: T
    public init(conditions: [RevenueCat.PaywallComponent.Condition], properties: T)
    public static func == (a: RevenueCat.PaywallComponent.ComponentOverride<T>, b: RevenueCat.PaywallComponent.ComponentOverride<T>) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum Condition : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case compact
    case medium
    case expanded
    case introOffer
    case promoOffer
    case selected
    case unsupported
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension RevenueCat.PaywallComponent {
  final public class StickyFooterComponent : RevenueCat.PaywallComponentBase {
    final public let stack: RevenueCat.PaywallComponent.StackComponent
    public init(stack: RevenueCat.PaywallComponent.StackComponent)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.StickyFooterComponent, rhs: RevenueCat.PaywallComponent.StickyFooterComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension RevenueCat.PaywallComponent {
  public struct ThemeImageUrls : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    #if compiler(>=5.3) && $NonescapableTypes
    public init(light: RevenueCat.PaywallComponent.ImageUrls, dark: RevenueCat.PaywallComponent.ImageUrls? = nil)
    #endif
    public let light: RevenueCat.PaywallComponent.ImageUrls
    public let dark: RevenueCat.PaywallComponent.ImageUrls?
    public static func == (a: RevenueCat.PaywallComponent.ThemeImageUrls, b: RevenueCat.PaywallComponent.ThemeImageUrls) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ImageUrls : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public init(width: Swift.Int, height: Swift.Int, original: Foundation.URL, heic: Foundation.URL, heicLowRes: Foundation.URL)
    public let width: Swift.Int
    public let height: Swift.Int
    public let original: Foundation.URL
    public let heic: Foundation.URL
    public let heicLowRes: Foundation.URL
    public static func == (a: RevenueCat.PaywallComponent.ImageUrls, b: RevenueCat.PaywallComponent.ImageUrls) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ThemeVideoUrls : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    #if compiler(>=5.3) && $NonescapableTypes
    public init(light: RevenueCat.PaywallComponent.VideoUrls, dark: RevenueCat.PaywallComponent.VideoUrls? = nil)
    #endif
    public let light: RevenueCat.PaywallComponent.VideoUrls
    public let dark: RevenueCat.PaywallComponent.VideoUrls?
    public static func == (a: RevenueCat.PaywallComponent.ThemeVideoUrls, b: RevenueCat.PaywallComponent.ThemeVideoUrls) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct VideoUrls : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public let width: Swift.Int
    public let height: Swift.Int
    public let url: Foundation.URL
    public let checksum: RevenueCat.Checksum?
    public let urlLowRes: Foundation.URL?
    public let checksumLowRes: RevenueCat.Checksum?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(width: Swift.Int, height: Swift.Int, url: Foundation.URL, checksum: RevenueCat.Checksum?, urlLowRes: Foundation.URL?, checksumLowRes: RevenueCat.Checksum?)
    #endif
    public static func == (a: RevenueCat.PaywallComponent.VideoUrls, b: RevenueCat.PaywallComponent.VideoUrls) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct GradientPoint : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public let color: RevenueCat.PaywallComponent.ColorHex
    public let percent: Swift.Int
    public init(color: RevenueCat.PaywallComponent.ColorHex, percent: Swift.Int)
    public static func == (a: RevenueCat.PaywallComponent.GradientPoint, b: RevenueCat.PaywallComponent.GradientPoint) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ColorScheme : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    #if compiler(>=5.3) && $NonescapableTypes
    public init(light: RevenueCat.PaywallComponent.ColorInfo, dark: RevenueCat.PaywallComponent.ColorInfo? = nil)
    #endif
    public let light: RevenueCat.PaywallComponent.ColorInfo
    public let dark: RevenueCat.PaywallComponent.ColorInfo?
    public static func == (a: RevenueCat.PaywallComponent.ColorScheme, b: RevenueCat.PaywallComponent.ColorScheme) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum ColorInfo : Swift.Codable, Swift.Sendable, Swift.Hashable {
    case hex(RevenueCat.PaywallComponent.ColorHex)
    case alias(Swift.String)
    case linear(Swift.Int, [RevenueCat.PaywallComponent.GradientPoint])
    case radial([RevenueCat.PaywallComponent.GradientPoint])
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public static func == (a: RevenueCat.PaywallComponent.ColorInfo, b: RevenueCat.PaywallComponent.ColorInfo) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Shape : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case rectangle(RevenueCat.PaywallComponent.CornerRadiuses?)
    case pill
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public static func == (a: RevenueCat.PaywallComponent.Shape, b: RevenueCat.PaywallComponent.Shape) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum IconBackgroundShape : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case rectangle(RevenueCat.PaywallComponent.CornerRadiuses?)
    case circle
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public static func == (a: RevenueCat.PaywallComponent.IconBackgroundShape, b: RevenueCat.PaywallComponent.IconBackgroundShape) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum MaskShape : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case rectangle(RevenueCat.PaywallComponent.CornerRadiuses?)
    case circle
    case concave
    case convex
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public static func == (a: RevenueCat.PaywallComponent.MaskShape, b: RevenueCat.PaywallComponent.MaskShape) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Padding : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    #if compiler(>=5.3) && $NonescapableTypes
    public init(top: Swift.Double?, bottom: Swift.Double?, leading: Swift.Double?, trailing: Swift.Double?)
    #endif
    public let top: Swift.Double?
    public let bottom: Swift.Double?
    public let leading: Swift.Double?
    public let trailing: Swift.Double?
    public static let `default`: RevenueCat.PaywallComponent.Padding
    public static let zero: RevenueCat.PaywallComponent.Padding
    public static func == (a: RevenueCat.PaywallComponent.Padding, b: RevenueCat.PaywallComponent.Padding) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct CornerRadiuses : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    #if compiler(>=5.3) && $NonescapableTypes
    public init(topLeading: Swift.Double?, topTrailing: Swift.Double?, bottomLeading: Swift.Double?, bottomTrailing: Swift.Double?)
    #endif
    public let topLeading: Swift.Double?
    public let topTrailing: Swift.Double?
    public let bottomLeading: Swift.Double?
    public let bottomTrailing: Swift.Double?
    public static let `default`: RevenueCat.PaywallComponent.CornerRadiuses
    public static let zero: RevenueCat.PaywallComponent.CornerRadiuses
    public static func == (a: RevenueCat.PaywallComponent.CornerRadiuses, b: RevenueCat.PaywallComponent.CornerRadiuses) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Size : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public let width: RevenueCat.PaywallComponent.SizeConstraint
    public let height: RevenueCat.PaywallComponent.SizeConstraint
    public init(width: RevenueCat.PaywallComponent.SizeConstraint, height: RevenueCat.PaywallComponent.SizeConstraint)
    public static func == (a: RevenueCat.PaywallComponent.Size, b: RevenueCat.PaywallComponent.Size) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum SizeConstraint : Swift.Codable, Swift.Sendable, Swift.Hashable {
    case fit
    case fill
    case fixed(Swift.UInt)
    case relative(Swift.Double)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public static func == (a: RevenueCat.PaywallComponent.SizeConstraint, b: RevenueCat.PaywallComponent.SizeConstraint) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum FlexDistribution : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case start
    case center
    case end
    case spaceBetween
    case spaceAround
    case spaceEvenly
    public init(from decoder: any Swift.Decoder) throws
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum HorizontalAlignment : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case leading
    case center
    case trailing
    public init(from decoder: any Swift.Decoder) throws
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum VerticalAlignment : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case top
    case center
    case bottom
    public init(from decoder: any Swift.Decoder) throws
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum TwoDimensionAlignment : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case center
    case leading
    case trailing
    case top
    case bottom
    case topLeading
    case topTrailing
    case bottomLeading
    case bottomTrailing
    public init(from decoder: any Swift.Decoder) throws
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum FontWeight : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case extraLight
    case thin
    case light
    case regular
    case medium
    case semibold
    case bold
    case extraBold
    case black
    public init(from decoder: any Swift.Decoder) throws
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum FontSize : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case headingXXL
    case headingXL
    case headingL
    case headingM
    case headingS
    case headingXS
    case bodyXL
    case bodyL
    case bodyM
    case bodyS
    public init(from decoder: any Swift.Decoder) throws
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum FitMode : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case fit
    case fill
    public init(from decoder: any Swift.Decoder) throws
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct Shadow : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public let color: RevenueCat.PaywallComponent.ColorScheme
    public let radius: CoreFoundation.CGFloat
    public let x: CoreFoundation.CGFloat
    public let y: CoreFoundation.CGFloat
    public init(color: RevenueCat.PaywallComponent.ColorScheme, radius: CoreFoundation.CGFloat, x: CoreFoundation.CGFloat, y: CoreFoundation.CGFloat)
    public static func == (a: RevenueCat.PaywallComponent.Shadow, b: RevenueCat.PaywallComponent.Shadow) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum BadgeStyle : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case edgeToEdge
    case overlaid
    case nested
    public init(from decoder: any Swift.Decoder) throws
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  final public class Badge : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    final public let style: RevenueCat.PaywallComponent.BadgeStyle
    final public let alignment: RevenueCat.PaywallComponent.TwoDimensionAlignment
    final public let stack: RevenueCat.PaywallComponent.StackComponent
    public init(style: RevenueCat.PaywallComponent.BadgeStyle, alignment: RevenueCat.PaywallComponent.TwoDimensionAlignment, stack: RevenueCat.PaywallComponent.StackComponent)
    public static func == (lhs: RevenueCat.PaywallComponent.Badge, rhs: RevenueCat.PaywallComponent.Badge) -> Swift.Bool
    final public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension Swift.Dictionary where Key == Swift.String, Value == RevenueCat.PaywallComponentsData.LocalizationData {
  public func string(key: Swift.String) throws -> Swift.String
  public func image(key: Swift.String) throws -> RevenueCat.PaywallComponent.ThemeImageUrls
}
extension RevenueCat.PaywallComponent {
  public struct Border : Swift.Codable, Swift.Sendable, Swift.Hashable {
    public let color: RevenueCat.PaywallComponent.ColorScheme
    public let width: Swift.Double
    public init(color: RevenueCat.PaywallComponent.ColorScheme, width: Swift.Double)
    public static func == (a: RevenueCat.PaywallComponent.Border, b: RevenueCat.PaywallComponent.Border) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension RevenueCat.PaywallComponent {
  public enum Dimension : Swift.Codable, Swift.Sendable, Swift.Hashable {
    case vertical(RevenueCat.PaywallComponent.HorizontalAlignment, RevenueCat.PaywallComponent.FlexDistribution)
    case horizontal(RevenueCat.PaywallComponent.VerticalAlignment, RevenueCat.PaywallComponent.FlexDistribution)
    case zlayer(RevenueCat.PaywallComponent.TwoDimensionAlignment)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public static func horizontal() -> RevenueCat.PaywallComponent.Dimension
    public static func vertical() -> RevenueCat.PaywallComponent.Dimension
    public static func == (a: RevenueCat.PaywallComponent.Dimension, b: RevenueCat.PaywallComponent.Dimension) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol PaywallComponentBase : Swift.Decodable, Swift.Encodable, Swift.Hashable, Swift.Sendable {
}
public enum PaywallComponent : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
  case text(RevenueCat.PaywallComponent.TextComponent)
  case image(RevenueCat.PaywallComponent.ImageComponent)
  case icon(RevenueCat.PaywallComponent.IconComponent)
  case stack(RevenueCat.PaywallComponent.StackComponent)
  case button(RevenueCat.PaywallComponent.ButtonComponent)
  case package(RevenueCat.PaywallComponent.PackageComponent)
  case purchaseButton(RevenueCat.PaywallComponent.PurchaseButtonComponent)
  case stickyFooter(RevenueCat.PaywallComponent.StickyFooterComponent)
  case timeline(RevenueCat.PaywallComponent.TimelineComponent)
  case tabs(RevenueCat.PaywallComponent.TabsComponent)
  case tabControl(RevenueCat.PaywallComponent.TabControlComponent)
  case tabControlButton(RevenueCat.PaywallComponent.TabControlButtonComponent)
  case tabControlToggle(RevenueCat.PaywallComponent.TabControlToggleComponent)
  case carousel(RevenueCat.PaywallComponent.CarouselComponent)
  case video(RevenueCat.PaywallComponent.VideoComponent)
  case countdown(RevenueCat.PaywallComponent.CountdownComponent)
  public enum ComponentType : Swift.String, Swift.Codable, Swift.Sendable {
    case text
    case image
    case icon
    case stack
    case button
    case package
    case purchaseButton
    case stickyFooter
    case timeline
    case tabs
    case tabControl
    case tabControlButton
    case tabControlToggle
    case carousel
    case video
    case countdown
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public static func == (a: RevenueCat.PaywallComponent, b: RevenueCat.PaywallComponent) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallComponent {
  public typealias LocaleID = Swift.String
  public typealias LocalizationDictionary = [Swift.String : RevenueCat.PaywallComponentsData.LocalizationData]
  public typealias LocalizationKey = Swift.String
  public typealias ColorHex = Swift.String
}
extension RevenueCat.PaywallComponent {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, *)
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func debugRevenueCatOverlay() -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func debugRevenueCatOverlay(isPresented: SwiftUICore.Binding<Swift.Bool>) -> some SwiftUICore.View
  
}
@objc(RCAttributionNetwork) public enum AttributionNetwork : Swift.Int {
  @available(*, deprecated, message: "use adServices")
  case appleSearchAds = 0
  case adjust = 1
  case appsFlyer = 2
  case branch = 3
  case tenjin = 4
  case facebook = 5
  case mParticle = 6
  case adServices = 7
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.AttributionNetwork : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct PaywallComponentsData : Swift.Codable, Swift.Equatable, Swift.Sendable {
  public struct ComponentsConfig : Swift.Codable, Swift.Equatable, Swift.Sendable {
    public var base: RevenueCat.PaywallComponentsData.PaywallComponentsConfig
    public init(base: RevenueCat.PaywallComponentsData.PaywallComponentsConfig)
    public static func == (a: RevenueCat.PaywallComponentsData.ComponentsConfig, b: RevenueCat.PaywallComponentsData.ComponentsConfig) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct PaywallComponentsConfig : Swift.Codable, Swift.Equatable, Swift.Sendable {
    public var stack: RevenueCat.PaywallComponent.StackComponent
    public let stickyFooter: RevenueCat.PaywallComponent.StickyFooterComponent?
    public var background: RevenueCat.PaywallComponent.Background
    #if compiler(>=5.3) && $NonescapableTypes
    public init(stack: RevenueCat.PaywallComponent.StackComponent, stickyFooter: RevenueCat.PaywallComponent.StickyFooterComponent?, background: RevenueCat.PaywallComponent.Background)
    #endif
    public static func == (a: RevenueCat.PaywallComponentsData.PaywallComponentsConfig, b: RevenueCat.PaywallComponentsData.PaywallComponentsConfig) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum LocalizationData : Swift.Codable, Swift.Equatable, Swift.Sendable {
    case string(Swift.String), image(RevenueCat.PaywallComponent.ThemeImageUrls)
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public static func == (a: RevenueCat.PaywallComponentsData.LocalizationData, b: RevenueCat.PaywallComponentsData.LocalizationData) -> Swift.Bool
  }
  public var id: Swift.String?
  public var templateName: Swift.String
  public var assetBaseURL: Foundation.URL
  public var revision: Swift.Int {
    get
    set
  }
  public var zeroDecimalPlaceCountries: [Swift.String] {
    get
  }
  public var componentsConfig: RevenueCat.PaywallComponentsData.ComponentsConfig
  public var componentsLocalizations: [RevenueCat.PaywallComponent.LocaleID : RevenueCat.PaywallComponent.LocalizationDictionary]
  public var defaultLocale: Swift.String
  public var exitOffers: RevenueCat.ExitOffers?
  public var errorInfo: [Swift.String : RevenueCat.PaywallComponentsData.EquatableError]?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: Swift.String? = nil, templateName: Swift.String, assetBaseURL: Foundation.URL, componentsConfig: RevenueCat.PaywallComponentsData.ComponentsConfig, componentsLocalizations: [RevenueCat.PaywallComponent.LocaleID : RevenueCat.PaywallComponent.LocalizationDictionary], revision: Swift.Int, defaultLocaleIdentifier: Swift.String, zeroDecimalPlaceCountries: [Swift.String] = [], exitOffers: RevenueCat.ExitOffers? = nil)
  #endif
  public static func == (a: RevenueCat.PaywallComponentsData, b: RevenueCat.PaywallComponentsData) -> Swift.Bool
}
extension RevenueCat.PaywallComponentsData {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension RevenueCat.PaywallComponentsData {
  public struct EquatableError : Swift.Equatable, Swift.Sendable {
    public static func == (lhs: RevenueCat.PaywallComponentsData.EquatableError, rhs: RevenueCat.PaywallComponentsData.EquatableError) -> Swift.Bool
  }
}
public typealias PublicError = Foundation.NSError
extension Foundation.NSError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var asErrorCode: RevenueCat.ErrorCode? {
    get
  }
  #endif
}
@objc(RCPurchasesType) public protocol PurchasesType {
  @objc var appUserID: Swift.String { get }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc var storeFrontCountryCode: Swift.String? { get }
  #endif
  @objc var isAnonymous: Swift.Bool { get }
  @objc var purchasesAreCompletedBy: RevenueCat.PurchasesAreCompletedBy { get set }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc var delegate: (any RevenueCat.PurchasesDelegate)? { get set }
  #endif
  @objc func getStorefront(completion: @escaping RevenueCat.GetStorefrontBlock)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc func getStorefront() async -> RevenueCat.Storefront?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc func logIn(_ appUserID: Swift.String, completion: @escaping (RevenueCat.CustomerInfo?, Swift.Bool, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  @objc func logIn(_ appUserID: Swift.String) async throws -> (customerInfo: RevenueCat.CustomerInfo, created: Swift.Bool)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc func logOut(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)?)
  #endif
  @objc func logOut() async throws -> RevenueCat.CustomerInfo
  #if compiler(>=5.3) && $NonescapableTypes
  @objc func getCustomerInfo(completion: @escaping (RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc func getCustomerInfo(fetchPolicy: RevenueCat.CacheFetchPolicy, completion: @escaping (RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  @objc func customerInfo() async throws -> RevenueCat.CustomerInfo
  @objc func customerInfo(fetchPolicy: RevenueCat.CacheFetchPolicy) async throws -> RevenueCat.CustomerInfo
  #if compiler(>=5.3) && $NonescapableTypes
  @objc var cachedCustomerInfo: RevenueCat.CustomerInfo? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc func getOfferings(completion: @escaping (RevenueCat.Offerings?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  @objc func offerings() async throws -> RevenueCat.Offerings
  #if compiler(>=5.3) && $NonescapableTypes
  @objc var cachedOfferings: RevenueCat.Offerings? { get }
  #endif
  @objc(getProductsWithIdentifiers:completion:) func getProducts(_ productIdentifiers: [Swift.String], completion: @escaping ([RevenueCat.StoreProduct]) -> Swift.Void)
  @objc func products(_ productIdentifiers: [Swift.String]) async -> [RevenueCat.StoreProduct]
  @objc(purchaseProduct:withCompletion:) func purchase(product: RevenueCat.StoreProduct, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc func purchase(product: RevenueCat.StoreProduct) async throws -> RevenueCat.PurchaseResultData
  @objc(purchasePackage:withCompletion:) func purchase(package: RevenueCat.Package, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc func purchase(package: RevenueCat.Package) async throws -> RevenueCat.PurchaseResultData
  @objc(purchaseWithParams:completion:) func purchase(_ params: RevenueCat.PurchaseParams, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc func purchase(_ params: RevenueCat.PurchaseParams) async throws -> RevenueCat.PurchaseResultData
  @objc func invalidateCustomerInfoCache()
  #if compiler(>=5.3) && $NonescapableTypes
  @objc func restorePurchases(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)?)
  #endif
  @objc func restorePurchases() async throws -> RevenueCat.CustomerInfo
  #if compiler(>=5.3) && $NonescapableTypes
  @objc func syncPurchases(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)?)
  #endif
  @objc func syncPurchases() async throws -> RevenueCat.CustomerInfo
  @objc(purchaseProduct:withPromotionalOffer:completion:) func purchase(product: RevenueCat.StoreProduct, promotionalOffer: RevenueCat.PromotionalOffer, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc func purchase(product: RevenueCat.StoreProduct, promotionalOffer: RevenueCat.PromotionalOffer) async throws -> RevenueCat.PurchaseResultData
  @objc(purchasePackage:withPromotionalOffer:completion:) func purchase(package: RevenueCat.Package, promotionalOffer: RevenueCat.PromotionalOffer, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc func purchase(package: RevenueCat.Package, promotionalOffer: RevenueCat.PromotionalOffer) async throws -> RevenueCat.PurchaseResultData
  @objc(checkTrialOrIntroDiscountEligibility:completion:) func checkTrialOrIntroDiscountEligibility(productIdentifiers: [Swift.String], completion receiveEligibility: @escaping ([Swift.String : RevenueCat.IntroEligibility]) -> Swift.Void)
  @objc func checkTrialOrIntroDiscountEligibility(productIdentifiers: [Swift.String]) async -> [Swift.String : RevenueCat.IntroEligibility]
  @objc(checkTrialOrIntroDiscountEligibilityForProduct:completion:) func checkTrialOrIntroDiscountEligibility(product: RevenueCat.StoreProduct, completion: @escaping (RevenueCat.IntroEligibilityStatus) -> Swift.Void)
  @objc func checkTrialOrIntroDiscountEligibility(product: RevenueCat.StoreProduct) async -> RevenueCat.IntroEligibilityStatus
  #if compiler(>=5.3) && $NonescapableTypes
  @objc(getPromotionalOfferForProductDiscount:withProduct:withCompletion:) func getPromotionalOffer(forProductDiscount discount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct, completion: @escaping (RevenueCat.PromotionalOffer?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  @objc func promotionalOffer(forProductDiscount discount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct) async throws -> RevenueCat.PromotionalOffer
  @objc func eligiblePromotionalOffers(forProduct product: RevenueCat.StoreProduct) async -> [RevenueCat.PromotionalOffer]
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  func eligibleWinBackOffers(forProduct product: RevenueCat.StoreProduct, completion: @escaping @Sendable ([RevenueCat.WinBackOffer]?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  func eligibleWinBackOffers(forPackage package: RevenueCat.Package, completion: @escaping @Sendable ([RevenueCat.WinBackOffer]?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForProduct:completion:) func beginRefundRequest(forProduct productID: Swift.String) async throws -> RevenueCat.RefundRequestStatus
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForEntitlement:completion:) func beginRefundRequest(forEntitlement entitlementID: Swift.String) async throws -> RevenueCat.RefundRequestStatus
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForActiveEntitlementWithCompletion:) func beginRefundRequestForActiveEntitlement() async throws -> RevenueCat.RefundRequestStatus
  @objc @available(iOS 14.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @available(macOS, unavailable)
  @available(macCatalyst, unavailable)
  func presentCodeRedemptionSheet()
  @available(iOS 13.4, macCatalyst 13.4, *)
  @objc func showPriceConsentIfNeeded()
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 13.0, macOS 10.15, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc func showManageSubscriptions(completion: @escaping (RevenueCat.PublicError?) -> Swift.Void)
  #endif
  @objc @available(iOS 13.0, macOS 10.15, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  func showManageSubscriptions() async throws
  @objc var attribution: RevenueCat.Attribution { get }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc func syncAttributesAndOfferingsIfNeeded(completion: @escaping (RevenueCat.Offerings?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  func syncAttributesAndOfferingsIfNeeded() async throws -> RevenueCat.Offerings?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc func redeemWebPurchase(webPurchaseRedemption: RevenueCat.WebPurchaseRedemption, completion: @escaping (RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc func getVirtualCurrencies(completion: @escaping @Sendable (RevenueCat.VirtualCurrencies?, RevenueCat.PublicError?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc var cachedVirtualCurrencies: RevenueCat.VirtualCurrencies? { get }
  #endif
  @objc func invalidateVirtualCurrenciesCache()
  @objc func setAttributes(_ attributes: [Swift.String : Swift.String])
  @objc @available(*, deprecated)
  var allowSharingAppStoreAccount: Swift.Bool { get set }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setEmail(_ email: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setPhoneNumber(_ phoneNumber: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setDisplayName(_ displayName: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setPushToken(_ pushToken: Foundation.Data?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setPushTokenString(_ pushToken: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setAdjustID(_ adjustID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setAppsflyerID(_ appsflyerID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setFBAnonymousID(_ fbAnonymousID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setMparticleID(_ mparticleID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setOnesignalID(_ onesignalID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setMediaSource(_ mediaSource: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setCampaign(_ campaign: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setAdGroup(_ adGroup: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setAd(_ value: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setKeyword(_ keyword: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setCreative(_ creative: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setCleverTapID(_ cleverTapID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setMixpanelDistinctID(_ mixpanelDistinctID: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @available(*, deprecated)
  func setFirebaseAppInstanceID(_ firebaseAppInstanceID: Swift.String?)
  #endif
  @objc @available(*, deprecated)
  func collectDeviceIdentifiers()
  @available(*, deprecated)
  @objc(params:withCompletion:) func purchaseWithParams(_ params: RevenueCat.PurchaseParams, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc @available(*, deprecated, message: "Use purchasesAreCompletedBy instead.")
  var finishTransactions: Swift.Bool { get set }
}
public protocol PurchasesSwiftType : AnyObject {
  var customerInfoStream: _Concurrency.AsyncStream<RevenueCat.CustomerInfo> { get }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  func beginRefundRequest(forProduct productID: Swift.String, completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  func beginRefundRequest(forEntitlement entitlementID: Swift.String, completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  func beginRefundRequestForActiveEntitlement(completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  #endif
  @available(iOS 16.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  func showStoreMessages(for types: Swift.Set<RevenueCat.StoreMessageType>) async
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
  func recordPurchase(_ purchaseResult: StoreKit.Product.PurchaseResult) async throws -> RevenueCat.StoreTransaction?
  #endif
  func redeemWebPurchase(_ webPurchaseRedemption: RevenueCat.WebPurchaseRedemption) async -> RevenueCat.WebPurchaseRedemptionResult
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  func eligibleWinBackOffers(forProduct product: RevenueCat.StoreProduct) async throws -> [RevenueCat.WinBackOffer]
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  func eligibleWinBackOffers(forPackage package: RevenueCat.Package) async throws -> [RevenueCat.WinBackOffer]
  func virtualCurrencies() async throws -> RevenueCat.VirtualCurrencies
}
@objc(RCStoreKitVersion) public enum StoreKitVersion : Swift.Int {
  @objc(RCStoreKitVersion1) case storeKit1 = 1
  @objc(RCStoreKitVersion2) case storeKit2 = 2
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.StoreKitVersion {
  public static let `default`: RevenueCat.StoreKitVersion
}
extension RevenueCat.StoreKitVersion : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RevenueCat.PaywallComponent {
  final public class IconComponent : RevenueCat.PaywallComponentBase {
    final public class Formats : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      final public let svg: Swift.String
      final public let png: Swift.String
      final public let heic: Swift.String
      final public let webp: Swift.String
      public init(svg: Swift.String, png: Swift.String, heic: Swift.String, webp: Swift.String)
      final public func hash(into hasher: inout Swift.Hasher)
      public static func == (lhs: RevenueCat.PaywallComponent.IconComponent.Formats, rhs: RevenueCat.PaywallComponent.IconComponent.Formats) -> Swift.Bool
      @objc deinit
      final public func encode(to encoder: any Swift.Encoder) throws
      final public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    final public class IconBackground : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      final public let color: RevenueCat.PaywallComponent.ColorScheme
      final public let shape: RevenueCat.PaywallComponent.IconBackgroundShape
      final public let border: RevenueCat.PaywallComponent.Border?
      final public let shadow: RevenueCat.PaywallComponent.Shadow?
      #if compiler(>=5.3) && $NonescapableTypes
      public init(color: RevenueCat.PaywallComponent.ColorScheme, shape: RevenueCat.PaywallComponent.IconBackgroundShape, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil)
      #endif
      final public func hash(into hasher: inout Swift.Hasher)
      public static func == (lhs: RevenueCat.PaywallComponent.IconComponent.IconBackground, rhs: RevenueCat.PaywallComponent.IconComponent.IconBackground) -> Swift.Bool
      @objc deinit
      final public func encode(to encoder: any Swift.Encoder) throws
      final public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    final public let visible: Swift.Bool?
    final public let baseUrl: Swift.String
    final public let iconName: Swift.String
    final public let formats: RevenueCat.PaywallComponent.IconComponent.Formats
    final public let size: RevenueCat.PaywallComponent.Size
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let color: RevenueCat.PaywallComponent.ColorScheme
    final public let iconBackground: RevenueCat.PaywallComponent.IconComponent.IconBackground?
    final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialIconComponent>?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(visible: Swift.Bool? = nil, baseUrl: Swift.String, iconName: Swift.String, formats: RevenueCat.PaywallComponent.IconComponent.Formats, size: RevenueCat.PaywallComponent.Size, padding: RevenueCat.PaywallComponent.Padding?, margin: RevenueCat.PaywallComponent.Padding?, color: RevenueCat.PaywallComponent.ColorScheme, iconBackground: RevenueCat.PaywallComponent.IconComponent.IconBackground?, overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialIconComponent>? = nil)
    #endif
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.IconComponent, rhs: RevenueCat.PaywallComponent.IconComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class PartialIconComponent : RevenueCat.PaywallPartialComponent {
    final public let visible: Swift.Bool?
    final public let baseUrl: Swift.String?
    final public let iconName: Swift.String?
    final public let formats: RevenueCat.PaywallComponent.IconComponent.Formats?
    final public let size: RevenueCat.PaywallComponent.Size?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let color: RevenueCat.PaywallComponent.ColorScheme?
    final public let iconBackground: RevenueCat.PaywallComponent.IconComponent.IconBackground?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(visible: Swift.Bool? = true, baseUrl: Swift.String? = nil, iconName: Swift.String? = nil, formats: RevenueCat.PaywallComponent.IconComponent.Formats? = nil, size: RevenueCat.PaywallComponent.Size? = nil, padding: RevenueCat.PaywallComponent.Padding? = nil, margin: RevenueCat.PaywallComponent.Padding? = nil, color: RevenueCat.PaywallComponent.ColorScheme? = nil, iconBackground: RevenueCat.PaywallComponent.IconComponent.IconBackground? = nil)
    #endif
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PartialIconComponent, rhs: RevenueCat.PaywallComponent.PartialIconComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension RevenueCat.PaywallComponent {
  public struct Animation : RevenueCat.PaywallComponentBase {
    public let type: RevenueCat.PaywallComponent.AnimationType
    public let msDelay: Swift.Int
    public let msDuration: Swift.Int
    public static func == (a: RevenueCat.PaywallComponent.Animation, b: RevenueCat.PaywallComponent.Animation) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum AnimationType : Swift.String, RevenueCat.PaywallComponentBase {
    case easeIn
    case easeInOut
    case easeOut
    case linear
    public init(from decoder: any Swift.Decoder) throws
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
public typealias SK1Product = StoreKit.SKProduct
@available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
public typealias SK2Product = StoreKit.Product
@_hasMissingDesignatedInitializers @objc(RCStoreProduct) final public class StoreProduct : ObjectiveC.NSObject {
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  #endif
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc final public var productType: RevenueCat.StoreProduct.ProductType {
    @objc get
  }
  @objc final public var productCategory: RevenueCat.StoreProduct.ProductCategory {
    @objc get
  }
  @objc final public var localizedDescription: Swift.String {
    @objc get
  }
  @objc final public var localizedTitle: Swift.String {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var currencyCode: Swift.String? {
    @objc get
  }
  #endif
  final public var price: Foundation.Decimal {
    get
  }
  @objc final public var localizedPriceString: Swift.String {
    @objc get
  }
  @objc final public var productIdentifier: Swift.String {
    @objc get
  }
  @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
  @objc final public var isFamilyShareable: Swift.Bool {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var subscriptionGroupIdentifier: Swift.String? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var priceFormatter: Foundation.NumberFormatter? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var subscriptionPeriod: RevenueCat.SubscriptionPeriod? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var introductoryDiscount: RevenueCat.StoreProductDiscount? {
    @objc get
  }
  #endif
  @objc final public var discounts: [RevenueCat.StoreProductDiscount] {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.StoreProduct {
  @objc(price) final public var priceDecimalNumber: Foundation.NSDecimalNumber {
    @objc get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerDay: Foundation.NSDecimalNumber? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerWeek: Foundation.NSDecimalNumber? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerMonth: Foundation.NSDecimalNumber? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerYear: Foundation.NSDecimalNumber? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var localizedIntroductoryPriceString: Swift.String? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var localizedPricePerDay: Swift.String? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var localizedPricePerWeek: Swift.String? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var localizedPricePerMonth: Swift.String? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var localizedPricePerYear: Swift.String? {
    @objc get
  }
  #endif
}
extension RevenueCat.StoreProduct {
  final public func eligiblePromotionalOffers() async -> [RevenueCat.PromotionalOffer]
}
extension RevenueCat.StoreProduct {
  @objc convenience dynamic public init(sk1Product: RevenueCat.SK1Product)
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  convenience public init(sk2Product: RevenueCat.SK2Product)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public var sk1Product: RevenueCat.SK1Product? {
    @objc get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  final public var sk2Product: RevenueCat.SK2Product? {
    get
  }
  #endif
}
extension RevenueCat.StoreProduct {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS, unavailable, introduced: 11.2, renamed: "introductoryDiscount", message: "Use StoreProductDiscount instead")
  @available(tvOS, unavailable, introduced: 11.2, renamed: "introductoryDiscount", message: "Use StoreProductDiscount instead")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "introductoryDiscount", message: "Use StoreProductDiscount instead")
  @available(macOS, unavailable, introduced: 10.13.2, renamed: "introductoryDiscount", message: "Use StoreProductDiscount instead")
  @objc final public var introductoryPrice: StoreKit.SKProductDiscount? {
    @objc get
  }
  #endif
  @available(iOS, unavailable, message: "Use localizedPriceString instead")
  @available(tvOS, unavailable, message: "Use localizedPriceString instead")
  @available(watchOS, unavailable, message: "Use localizedPriceString instead")
  @available(macOS, unavailable, message: "Use localizedPriceString instead")
  @objc final public var priceLocale: Foundation.Locale {
    @objc get
  }
}
extension RevenueCat.PaywallComponent {
  final public class TabControlButtonComponent : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    final public let tabId: Swift.String
    final public let stack: RevenueCat.PaywallComponent.StackComponent
    public init(tabId: Swift.String, stack: RevenueCat.PaywallComponent.StackComponent)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.TabControlButtonComponent, rhs: RevenueCat.PaywallComponent.TabControlButtonComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class TabControlToggleComponent : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    final public let thumbColorOn: RevenueCat.PaywallComponent.ColorScheme
    final public let thumbColorOff: RevenueCat.PaywallComponent.ColorScheme
    final public let trackColorOn: RevenueCat.PaywallComponent.ColorScheme
    final public let trackColorOff: RevenueCat.PaywallComponent.ColorScheme
    public init(defaultValue: Swift.Bool, thumbColorOn: RevenueCat.PaywallComponent.ColorScheme, thumbColorOff: RevenueCat.PaywallComponent.ColorScheme, trackColorOn: RevenueCat.PaywallComponent.ColorScheme, trackColorOff: RevenueCat.PaywallComponent.ColorScheme)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.TabControlToggleComponent, rhs: RevenueCat.PaywallComponent.TabControlToggleComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class TabControlComponent : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public init()
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.TabControlComponent, rhs: RevenueCat.PaywallComponent.TabControlComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class TabsComponent : RevenueCat.PaywallComponentBase {
    final public class Tab : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      final public let id: Swift.String
      final public let stack: RevenueCat.PaywallComponent.StackComponent
      public init(id: Swift.String, stack: RevenueCat.PaywallComponent.StackComponent)
      final public func hash(into hasher: inout Swift.Hasher)
      public static func == (lhs: RevenueCat.PaywallComponent.TabsComponent.Tab, rhs: RevenueCat.PaywallComponent.TabsComponent.Tab) -> Swift.Bool
      @objc deinit
      final public func encode(to encoder: any Swift.Encoder) throws
      final public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    final public class TabControl : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      public enum TabControlType : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
        case buttons
        case toggle
        #if compiler(>=5.3) && $NonescapableTypes
        public init?(rawValue: Swift.String)
        #endif
        public typealias RawValue = Swift.String
        public var rawValue: Swift.String {
          get
        }
      }
      final public let type: RevenueCat.PaywallComponent.TabsComponent.TabControl.TabControlType
      final public let stack: RevenueCat.PaywallComponent.StackComponent
      public init(type: RevenueCat.PaywallComponent.TabsComponent.TabControl.TabControlType, stack: RevenueCat.PaywallComponent.StackComponent)
      final public func hash(into hasher: inout Swift.Hasher)
      public static func == (lhs: RevenueCat.PaywallComponent.TabsComponent.TabControl, rhs: RevenueCat.PaywallComponent.TabsComponent.TabControl) -> Swift.Bool
      @objc deinit
      final public func encode(to encoder: any Swift.Encoder) throws
      final public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    final public let visible: Swift.Bool?
    final public let size: RevenueCat.PaywallComponent.Size
    final public let padding: RevenueCat.PaywallComponent.Padding
    final public let margin: RevenueCat.PaywallComponent.Padding
    final public let background: RevenueCat.PaywallComponent.Background?
    final public let shape: RevenueCat.PaywallComponent.Shape?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    final public let control: RevenueCat.PaywallComponent.TabsComponent.TabControl
    final public let tabs: [RevenueCat.PaywallComponent.TabsComponent.Tab]
    final public let defaultTabId: Swift.String?
    final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialTabsComponent>?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(visible: Swift.Bool? = nil, size: RevenueCat.PaywallComponent.Size = .init(width: .fill, height: .fit), padding: RevenueCat.PaywallComponent.Padding = .zero, margin: RevenueCat.PaywallComponent.Padding = .zero, background: RevenueCat.PaywallComponent.Background? = nil, shape: RevenueCat.PaywallComponent.Shape? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil, control: RevenueCat.PaywallComponent.TabsComponent.TabControl, tabs: [RevenueCat.PaywallComponent.TabsComponent.Tab], defaultTabId: Swift.String? = nil, overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialTabsComponent>? = nil)
    #endif
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.TabsComponent, rhs: RevenueCat.PaywallComponent.TabsComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class PartialTabsComponent : RevenueCat.PaywallPartialComponent {
    final public let visible: Swift.Bool?
    final public let size: RevenueCat.PaywallComponent.Size?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let background: RevenueCat.PaywallComponent.Background?
    final public let shape: RevenueCat.PaywallComponent.Shape?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(visible: Swift.Bool? = true, size: RevenueCat.PaywallComponent.Size? = nil, padding: RevenueCat.PaywallComponent.Padding? = nil, margin: RevenueCat.PaywallComponent.Padding? = nil, background: RevenueCat.PaywallComponent.Background? = nil, shape: RevenueCat.PaywallComponent.Shape? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil)
    #endif
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PartialTabsComponent, rhs: RevenueCat.PaywallComponent.PartialTabsComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension StoreKit.SKRequest : @unchecked @retroactive Swift.Sendable {
}
extension StoreKit.SKProductsRequest : @unchecked @retroactive Swift.Sendable {
}
extension RevenueCat.PaywallComponent {
  final public class CarouselComponent : RevenueCat.PaywallComponentBase {
    public struct AutoAdvanceSlides : RevenueCat.PaywallComponentBase {
      public let msTimePerPage: Swift.Int
      public let msTransitionTime: Swift.Int
      public let transitionType: RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceTransitionType?
      #if compiler(>=5.3) && $NonescapableTypes
      public init(msTimePerPage: Swift.Int, msTransitionTime: Swift.Int, transitionType: RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceTransitionType?)
      #endif
      public static func == (a: RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceSlides, b: RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceSlides) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public enum AutoAdvanceTransitionType : Swift.String, RevenueCat.PaywallComponentBase {
      case fade
      case slide
      #if compiler(>=5.3) && $NonescapableTypes
      public init?(rawValue: Swift.String)
      #endif
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public struct PageControl : RevenueCat.PaywallComponentBase {
      public enum Position : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
        case top
        case bottom
        public init(from decoder: any Swift.Decoder) throws
        #if compiler(>=5.3) && $NonescapableTypes
        public init?(rawValue: Swift.String)
        #endif
        public typealias RawValue = Swift.String
        public var rawValue: Swift.String {
          get
        }
      }
      public let position: RevenueCat.PaywallComponent.CarouselComponent.PageControl.Position
      public let padding: RevenueCat.PaywallComponent.Padding?
      public let margin: RevenueCat.PaywallComponent.Padding?
      public let backgroundColor: RevenueCat.PaywallComponent.ColorScheme?
      public let shape: RevenueCat.PaywallComponent.Shape?
      public let border: RevenueCat.PaywallComponent.Border?
      public let shadow: RevenueCat.PaywallComponent.Shadow?
      public let spacing: Swift.Int
      public let `default`: RevenueCat.PaywallComponent.CarouselComponent.PageControlIndicator
      public let active: RevenueCat.PaywallComponent.CarouselComponent.PageControlIndicator
      #if compiler(>=5.3) && $NonescapableTypes
      public init(position: RevenueCat.PaywallComponent.CarouselComponent.PageControl.Position, padding: RevenueCat.PaywallComponent.Padding?, margin: RevenueCat.PaywallComponent.Padding?, backgroundColor: RevenueCat.PaywallComponent.ColorScheme?, shape: RevenueCat.PaywallComponent.Shape?, border: RevenueCat.PaywallComponent.Border?, shadow: RevenueCat.PaywallComponent.Shadow?, spacing: Swift.Int, default: RevenueCat.PaywallComponent.CarouselComponent.PageControlIndicator, active: RevenueCat.PaywallComponent.CarouselComponent.PageControlIndicator)
      #endif
      public static func == (a: RevenueCat.PaywallComponent.CarouselComponent.PageControl, b: RevenueCat.PaywallComponent.CarouselComponent.PageControl) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct PageControlIndicator : RevenueCat.PaywallComponentBase {
      public let width: Swift.Int
      public let height: Swift.Int
      public let color: RevenueCat.PaywallComponent.ColorScheme
      public let strokeColor: RevenueCat.PaywallComponent.ColorScheme?
      public let strokeWidth: CoreFoundation.CGFloat?
      #if compiler(>=5.3) && $NonescapableTypes
      public init(width: Swift.Int, height: Swift.Int, color: RevenueCat.PaywallComponent.ColorScheme, strokeColor: RevenueCat.PaywallComponent.ColorScheme? = nil, strokeWidth: CoreFoundation.CGFloat? = nil)
      #endif
      public static func == (a: RevenueCat.PaywallComponent.CarouselComponent.PageControlIndicator, b: RevenueCat.PaywallComponent.CarouselComponent.PageControlIndicator) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    final public let visible: Swift.Bool?
    final public let size: RevenueCat.PaywallComponent.Size?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let background: RevenueCat.PaywallComponent.Background?
    final public let shape: RevenueCat.PaywallComponent.Shape?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    final public let pages: [RevenueCat.PaywallComponent.StackComponent]
    final public let pageAlignment: RevenueCat.PaywallComponent.VerticalAlignment
    final public let pageSpacing: Swift.Int
    final public let pagePeek: Swift.Int
    final public let initialPageIndex: Swift.Int
    final public let loop: Swift.Bool
    final public let autoAdvance: RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceSlides?
    final public let pageControl: RevenueCat.PaywallComponent.CarouselComponent.PageControl?
    final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialCarouselComponent>?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(visible: Swift.Bool? = nil, size: RevenueCat.PaywallComponent.Size? = nil, padding: RevenueCat.PaywallComponent.Padding? = .zero, margin: RevenueCat.PaywallComponent.Padding? = .zero, background: RevenueCat.PaywallComponent.Background? = nil, shape: RevenueCat.PaywallComponent.Shape? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil, pages: [RevenueCat.PaywallComponent.StackComponent], pageAlignment: RevenueCat.PaywallComponent.VerticalAlignment = .center, pageSpacing: Swift.Int = 0, pagePeek: Swift.Int = 20, initialPageIndex: Swift.Int = 0, loop: Swift.Bool = false, autoAdvance: RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceSlides? = nil, pageControl: RevenueCat.PaywallComponent.CarouselComponent.PageControl? = nil, overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialCarouselComponent>? = nil)
    #endif
    public static func == (lhs: RevenueCat.PaywallComponent.CarouselComponent, rhs: RevenueCat.PaywallComponent.CarouselComponent) -> Swift.Bool
    final public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class PartialCarouselComponent : RevenueCat.PaywallPartialComponent {
    final public let visible: Swift.Bool?
    final public let size: RevenueCat.PaywallComponent.Size?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let background: RevenueCat.PaywallComponent.Background?
    final public let shape: RevenueCat.PaywallComponent.Shape?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    final public let pageAlignment: RevenueCat.PaywallComponent.VerticalAlignment?
    final public let pageSpacing: Swift.Int?
    final public let pagePeek: Swift.Int?
    final public let initialPageIndex: Swift.Int?
    final public let loop: Swift.Bool?
    final public let autoAdvance: RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceSlides?
    final public let pageControl: RevenueCat.PaywallComponent.CarouselComponent.PageControl?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(visible: Swift.Bool? = true, size: RevenueCat.PaywallComponent.Size? = nil, padding: RevenueCat.PaywallComponent.Padding? = nil, margin: RevenueCat.PaywallComponent.Padding? = nil, background: RevenueCat.PaywallComponent.Background? = nil, shape: RevenueCat.PaywallComponent.Shape? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil, pageAlignment: RevenueCat.PaywallComponent.VerticalAlignment? = nil, pageSpacing: Swift.Int? = nil, pagePeek: Swift.Int? = nil, initialPageIndex: Swift.Int? = nil, loop: Swift.Bool? = nil, autoAdvance: RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceSlides? = nil, pageControl: RevenueCat.PaywallComponent.CarouselComponent.PageControl? = nil)
    #endif
    public static func == (lhs: RevenueCat.PaywallComponent.PartialCarouselComponent, rhs: RevenueCat.PaywallComponent.PartialCarouselComponent) -> Swift.Bool
    final public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension RevenueCat.PaywallComponent {
  final public class CountdownComponent : RevenueCat.PaywallComponentBase {
    final public let name: Swift.String?
    final public let style: RevenueCat.PaywallComponent.CountdownComponent.CountdownStyle
    final public let countFrom: RevenueCat.PaywallComponent.CountdownComponent.CountFrom
    final public let countdownStack: RevenueCat.PaywallComponent.StackComponent
    final public let endStack: RevenueCat.PaywallComponent.StackComponent?
    final public let fallback: RevenueCat.PaywallComponent.StackComponent?
    final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialCountdownComponent>?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(id: Swift.String? = nil, name: Swift.String? = nil, style: RevenueCat.PaywallComponent.CountdownComponent.CountdownStyle, countFrom: RevenueCat.PaywallComponent.CountdownComponent.CountFrom, countdownStack: RevenueCat.PaywallComponent.StackComponent, endStack: RevenueCat.PaywallComponent.StackComponent? = nil, fallback: RevenueCat.PaywallComponent.StackComponent? = nil, overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialCountdownComponent>? = nil)
    #endif
    required public init(from decoder: any Swift.Decoder) throws
    final public func encode(to encoder: any Swift.Encoder) throws
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.CountdownComponent, rhs: RevenueCat.PaywallComponent.CountdownComponent) -> Swift.Bool
    public enum CountdownStyle : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      case date(Foundation.Date)
      public var date: Foundation.Date {
        get
      }
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
      public static func == (a: RevenueCat.PaywallComponent.CountdownComponent.CountdownStyle, b: RevenueCat.PaywallComponent.CountdownComponent.CountdownStyle) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum CountFrom : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      case days
      case hours
      case minutes
      #if compiler(>=5.3) && $NonescapableTypes
      public init?(rawValue: Swift.String)
      #endif
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    @objc deinit
    final public var hashValue: Swift.Int {
      get
    }
  }
  final public class PartialCountdownComponent : RevenueCat.PaywallPartialComponent {
    final public let style: RevenueCat.PaywallComponent.CountdownComponent.CountdownStyle?
    #if compiler(>=5.3) && $NonescapableTypes
    public init(style: RevenueCat.PaywallComponent.CountdownComponent.CountdownStyle? = nil)
    #endif
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PartialCountdownComponent, rhs: RevenueCat.PaywallComponent.PartialCountdownComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
public struct ExitOffer : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
  public let offeringId: Swift.String
  public init(offeringId: Swift.String)
  public static func == (a: RevenueCat.ExitOffer, b: RevenueCat.ExitOffer) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct ExitOffers : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
  public let dismiss: RevenueCat.ExitOffer?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(dismiss: RevenueCat.ExitOffer? = nil)
  #endif
  public static func == (a: RevenueCat.ExitOffers, b: RevenueCat.ExitOffers) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.VerificationResult : Swift.Equatable {}
extension RevenueCat.VerificationResult : Swift.Hashable {}
extension RevenueCat.VerificationResult : Swift.RawRepresentable {}
extension RevenueCat.ExitOfferType : Swift.Equatable {}
extension RevenueCat.ExitOfferType : Swift.Hashable {}
extension RevenueCat.ExitOfferType : Swift.RawRepresentable {}
extension RevenueCat.StoreProduct : Swift.Sendable {}
extension RevenueCat.StoreProduct.ProductCategory : Swift.Equatable {}
extension RevenueCat.StoreProduct.ProductCategory : Swift.Hashable {}
extension RevenueCat.StoreProduct.ProductCategory : Swift.RawRepresentable {}
extension RevenueCat.StoreProduct.ProductType : Swift.Equatable {}
extension RevenueCat.StoreProduct.ProductType : Swift.Hashable {}
extension RevenueCat.StoreProduct.ProductType : Swift.RawRepresentable {}
extension RevenueCat.StoreTransaction : Swift.Sendable {}
extension RevenueCat.StoreProductDiscount.PaymentMode : Swift.Equatable {}
extension RevenueCat.StoreProductDiscount.PaymentMode : Swift.Hashable {}
extension RevenueCat.StoreProductDiscount.PaymentMode : Swift.RawRepresentable {}
extension RevenueCat.PurchasesDiagnostics.ProductStatus : Swift.Equatable {}
extension RevenueCat.PurchasesDiagnostics.ProductStatus : Swift.Hashable {}
extension RevenueCat.PurchasesDiagnostics.SDKHealthCheckStatus : Swift.Equatable {}
extension RevenueCat.PurchasesDiagnostics.SDKHealthCheckStatus : Swift.Hashable {}
extension RevenueCat.ErrorCode : Swift.Equatable {}
extension RevenueCat.ErrorCode : Swift.Hashable {}
extension RevenueCat.ErrorCode : Swift.RawRepresentable {}
extension RevenueCat.ErrorCode : Swift.CustomStringConvertible {}
extension RevenueCat.PurchasesAreCompletedBy : Swift.Equatable {}
extension RevenueCat.PurchasesAreCompletedBy : Swift.Hashable {}
extension RevenueCat.PurchasesAreCompletedBy : Swift.RawRepresentable {}
extension RevenueCat.RefundRequestStatus : Swift.Equatable {}
extension RevenueCat.RefundRequestStatus : Swift.Hashable {}
extension RevenueCat.RefundRequestStatus : Swift.RawRepresentable {}
extension RevenueCat.CustomerCenterPresentationMode : Swift.Hashable {}
extension RevenueCat.CacheFetchPolicy : Swift.Equatable {}
extension RevenueCat.CacheFetchPolicy : Swift.Hashable {}
extension RevenueCat.CacheFetchPolicy : Swift.RawRepresentable {}
extension RevenueCat.AppleReceipt.InAppPurchase.ProductType : Swift.Equatable {}
extension RevenueCat.AppleReceipt.InAppPurchase.ProductType : Swift.Hashable {}
extension RevenueCat.AppleReceipt.InAppPurchase.ProductType : Swift.RawRepresentable {}
extension RevenueCat.Store : Swift.Equatable {}
extension RevenueCat.Store : Swift.Hashable {}
extension RevenueCat.Store : Swift.RawRepresentable {}
extension RevenueCat.PeriodType : Swift.Equatable {}
extension RevenueCat.PeriodType : Swift.Hashable {}
extension RevenueCat.PeriodType : Swift.RawRepresentable {}
extension RevenueCat.LogLevel : Swift.Hashable {}
extension RevenueCat.LogLevel : Swift.RawRepresentable {}
extension RevenueCat.Checksum.Algorithm : Swift.Equatable {}
extension RevenueCat.Checksum.Algorithm : Swift.Hashable {}
extension RevenueCat.Checksum.Algorithm : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.DisplacementStrategy : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.TransitionType : Swift.RawRepresentable {}
extension RevenueCat.PackageType : Swift.Equatable {}
extension RevenueCat.PackageType : Swift.Hashable {}
extension RevenueCat.PackageType : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.StackComponent.Overflow : Swift.RawRepresentable {}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.Equatable {}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.Hashable {}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.RawRepresentable {}
extension RevenueCat.PurchaseOwnershipType : Swift.Equatable {}
extension RevenueCat.PurchaseOwnershipType : Swift.Hashable {}
extension RevenueCat.PurchaseOwnershipType : Swift.RawRepresentable {}
extension RevenueCat.TestStoreProduct : Swift.Sendable {}
extension RevenueCat.StoreProductDiscount.DiscountType : Swift.Equatable {}
extension RevenueCat.StoreProductDiscount.DiscountType : Swift.Hashable {}
extension RevenueCat.StoreProductDiscount.DiscountType : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.PurchaseButtonComponent.Action : Swift.RawRepresentable {}
extension RevenueCat.AppleReceipt.Environment : Swift.Equatable {}
extension RevenueCat.AppleReceipt.Environment : Swift.Hashable {}
extension RevenueCat.AppleReceipt.Environment : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.TimelineComponent.IconAlignment : Swift.RawRepresentable {}
extension RevenueCat.StoreMessageType : Swift.Equatable {}
extension RevenueCat.StoreMessageType : Swift.Hashable {}
extension RevenueCat.StoreMessageType : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.ButtonComponent.URLMethod : Swift.RawRepresentable {}
extension RevenueCat.Configuration.EntitlementVerificationMode : Swift.Equatable {}
extension RevenueCat.Configuration.EntitlementVerificationMode : Swift.Hashable {}
extension RevenueCat.Configuration.EntitlementVerificationMode : Swift.RawRepresentable {}
extension RevenueCat.IntroEligibilityStatus : Swift.Equatable {}
extension RevenueCat.IntroEligibilityStatus : Swift.Hashable {}
extension RevenueCat.IntroEligibilityStatus : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.FontSize : Swift.RawRepresentable {}
extension RevenueCat.PaywallColor.ColorScheme : Swift.Hashable {}
extension RevenueCat.PaywallColor.ColorScheme : Swift.RawRepresentable {}
extension RevenueCat.PaywallColor.ColorScheme : Swift.BitwiseCopyable {}
extension RevenueCat.PaywallComponent.Condition : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.FlexDistribution : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.HorizontalAlignment : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.VerticalAlignment : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.TwoDimensionAlignment : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.FontWeight : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.FitMode : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.BadgeStyle : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.ComponentType : Swift.Equatable {}
extension RevenueCat.PaywallComponent.ComponentType : Swift.Hashable {}
extension RevenueCat.PaywallComponent.ComponentType : Swift.RawRepresentable {}
extension RevenueCat.AttributionNetwork : Swift.Equatable {}
extension RevenueCat.AttributionNetwork : Swift.Hashable {}
extension RevenueCat.AttributionNetwork : Swift.RawRepresentable {}
extension RevenueCat.StoreKitVersion : Swift.Equatable {}
extension RevenueCat.StoreKitVersion : Swift.Hashable {}
extension RevenueCat.StoreKitVersion : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.AnimationType : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.TabsComponent.TabControl.TabControlType : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceTransitionType : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.CarouselComponent.PageControl.Position : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.CountdownComponent.CountFrom : Swift.RawRepresentable {}
