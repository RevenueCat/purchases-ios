// Generated by Apple Swift version 5.5 (swiftlang-1300.0.31.1 clang-1300.0.29.1)
#ifndef REVENUECAT_SWIFT_H
#define REVENUECAT_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
@import StoreKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="RevenueCat",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

typedef SWIFT_ENUM_NAMED(NSInteger, RCAttributionNetwork, "AttributionNetwork", open) {
/// Apple’s search ads
  RCAttributionNetworkAppleSearchAds = 0,
/// Adjust https://www.adjust.com/
  RCAttributionNetworkAdjust = 1,
/// AppsFlyer https://www.appsflyer.com/
  RCAttributionNetworkAppsFlyer = 2,
/// Branch https://www.branch.io/
  RCAttributionNetworkBranch = 3,
/// Tenjin https://www.tenjin.io/
  RCAttributionNetworkTenjin = 4,
/// Facebook https://developers.facebook.com/
  RCAttributionNetworkFacebook = 5,
/// mParticle https://www.mparticle.com/
  RCAttributionNetworkMParticle = 6,
};

/// Error codes sent by the RevenueCat backend. This only includes the errors that matter to the SDK
typedef SWIFT_ENUM_NAMED(NSInteger, RCBackendErrorCode, "BackendErrorCode", open) {
  RCBackendUnknownError SWIFT_COMPILE_NAME("unknownError") = 0,
  RCBackendInvalidPlatform SWIFT_COMPILE_NAME("invalidPlatform") = 7000,
  RCBackendStoreProblem SWIFT_COMPILE_NAME("storeProblem") = 7101,
  RCBackendCannotTransferPurchase SWIFT_COMPILE_NAME("cannotTransferPurchase") = 7102,
  RCBackendInvalidReceiptToken SWIFT_COMPILE_NAME("invalidReceiptToken") = 7103,
  RCBackendInvalidAppStoreSharedSecret SWIFT_COMPILE_NAME("invalidAppStoreSharedSecret") = 7104,
  RCBackendInvalidPaymentModeOrIntroPriceNotProvided SWIFT_COMPILE_NAME("invalidPaymentModeOrIntroPriceNotProvided") = 7105,
  RCBackendProductIdForGoogleReceiptNotProvided SWIFT_COMPILE_NAME("productIdForGoogleReceiptNotProvided") = 7106,
  RCBackendInvalidPlayStoreCredentials SWIFT_COMPILE_NAME("invalidPlayStoreCredentials") = 7107,
  RCBackendInternalServerError SWIFT_COMPILE_NAME("internalServerError") = 7110,
  RCBackendEmptyAppUserId SWIFT_COMPILE_NAME("emptyAppUserId") = 7220,
  RCBackendInvalidAuthToken SWIFT_COMPILE_NAME("invalidAuthToken") = 7224,
  RCBackendInvalidAPIKey SWIFT_COMPILE_NAME("invalidAPIKey") = 7225,
  RCBackendBadRequest SWIFT_COMPILE_NAME("badRequest") = 7226,
  RCBackendPlayStoreQuotaExceeded SWIFT_COMPILE_NAME("playStoreQuotaExceeded") = 7229,
  RCBackendPlayStoreInvalidPackageName SWIFT_COMPILE_NAME("playStoreInvalidPackageName") = 7230,
  RCBackendPlayStoreGenericError SWIFT_COMPILE_NAME("playStoreGenericError") = 7231,
  RCBackendUserIneligibleForPromoOffer SWIFT_COMPILE_NAME("userIneligibleForPromoOffer") = 7232,
  RCBackendInvalidAppleSubscriptionKey SWIFT_COMPILE_NAME("invalidAppleSubscriptionKey") = 7234,
  RCBackendInvalidSubscriberAttributes SWIFT_COMPILE_NAME("invalidSubscriberAttributes") = 7263,
  RCBackendInvalidSubscriberAttributesBody SWIFT_COMPILE_NAME("invalidSubscriberAttributesBody") = 7264,
};
static NSString * _Nonnull const RCBackendErrorCodeDomain = @"RevenueCat.BackendErrorCode";



@class NSString;
@class NSNumber;
enum RCPeriodType : NSInteger;
@class NSDate;
enum RCStore : NSInteger;
enum RCPurchaseOwnershipType : NSInteger;

SWIFT_CLASS_NAMED("EntitlementInfo")
@interface RCEntitlementInfo : NSObject
/// The entitlement identifier configured in the RevenueCat dashboard
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
/// True if the user has access to this entitlement
@property (nonatomic, readonly) BOOL isActive;
/// True if the underlying subscription is set to renew at the end of
/// the billing period (<code>expirationDate</code>). Will always be <code>true</code> if entitlement
/// is for lifetime access.
@property (nonatomic, readonly) BOOL willRenew;
/// The last period type this entitlement was in
/// Either: <code>PeriodType/normal</code>, <code>PeriodType/intro</code>, <code>PeriodType/trial</code>
@property (nonatomic, readonly) enum RCPeriodType periodType;
/// The latest purchase or renewal date for the entitlement.
@property (nonatomic, readonly, copy) NSDate * _Nullable latestPurchaseDate;
/// The first date this entitlement was purchased
@property (nonatomic, readonly, copy) NSDate * _Nullable originalPurchaseDate;
/// The expiration date for the entitlement, can be <code>nil</code> for lifetime access.
/// If the <code>periodType</code> is <code>PeriodType/trial</code>, this is the trial expiration date.
@property (nonatomic, readonly, copy) NSDate * _Nullable expirationDate;
/// The store where this entitlement was unlocked from either: <code>Store/appStore</code>, <code>Store/macAppStore</code>,
/// <code>Store/playStore</code>, <code>Store/stripe</code>, <code>Store/promotional</code>, or <code>Store/unknownStore</code>.
@property (nonatomic, readonly) enum RCStore store;
/// The product identifier that unlocked this entitlement
@property (nonatomic, readonly, copy) NSString * _Nonnull productIdentifier;
/// False if this entitlement is unlocked via a production purchase
@property (nonatomic, readonly) BOOL isSandbox;
/// The date an unsubscribe was detected. Can be <code>nil</code>.
/// Note: Entitlement may still be active even if user has unsubscribed. Check the <code>isActive</code> property.
@property (nonatomic, readonly, copy) NSDate * _Nullable unsubscribeDetectedAt;
/// The date a billing issue was detected. Can be <code>nil</code> if there is no
/// billing issue or an issue has been resolved.
/// Note: Entitlement may still be active even if there is a billing issue.
/// Check the <code>isActive</code> property.
@property (nonatomic, readonly, copy) NSDate * _Nullable billingIssueDetectedAt;
/// Use this property to determine whether a purchase was made by the current user
/// or shared to them by a family member. This can be useful for onboarding users who have had
/// an entitlement shared with them, but might not be entirely aware of the benefits they now have.
@property (nonatomic, readonly) enum RCPurchaseOwnershipType ownershipType;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




/// This class contains all the entitlements associated to the user.
SWIFT_CLASS_NAMED("EntitlementInfos")
@interface RCEntitlementInfos : NSObject
/// Dictionary of all EntitlementInfo (<code>EntitlementInfo</code>) objects (active and inactive) keyed by entitlement
/// identifier. This dictionary can also be accessed by using an index subscript on <code>EntitlementInfos</code>, e.g.
/// <code>entitlementInfos["pro_entitlement_id"]</code>.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, RCEntitlementInfo *> * _Nonnull all;
/// Dictionary of active <code>EntitlementInfo</code> (<code>RCEntitlementInfo</code>) objects keyed by entitlement identifier.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, RCEntitlementInfo *> * _Nonnull active;
- (RCEntitlementInfo * _Nullable)objectForKeyedSubscript:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Error codes used by the Purchases SDK
typedef SWIFT_ENUM_NAMED(NSInteger, RCPurchasesErrorCode, "ErrorCode", open) {
  RCUnknownError SWIFT_COMPILE_NAME("unknownError") = 0,
  RCPurchaseCancelledError SWIFT_COMPILE_NAME("purchaseCancelledError") = 1,
  RCStoreProblemError SWIFT_COMPILE_NAME("storeProblemError") = 2,
  RCPurchaseNotAllowedError SWIFT_COMPILE_NAME("purchaseNotAllowedError") = 3,
  RCPurchaseInvalidError SWIFT_COMPILE_NAME("purchaseInvalidError") = 4,
  RCProductNotAvailableForPurchaseError SWIFT_COMPILE_NAME("productNotAvailableForPurchaseError") = 5,
  RCProductAlreadyPurchasedError SWIFT_COMPILE_NAME("productAlreadyPurchasedError") = 6,
  RCReceiptAlreadyInUseError SWIFT_COMPILE_NAME("receiptAlreadyInUseError") = 7,
  RCInvalidReceiptError SWIFT_COMPILE_NAME("invalidReceiptError") = 8,
  RCMissingReceiptFileError SWIFT_COMPILE_NAME("missingReceiptFileError") = 9,
  RCNetworkError SWIFT_COMPILE_NAME("networkError") = 10,
  RCInvalidCredentialsError SWIFT_COMPILE_NAME("invalidCredentialsError") = 11,
  RCUnexpectedBackendResponseError SWIFT_COMPILE_NAME("unexpectedBackendResponseError") = 12,
  RCReceiptInUseByOtherSubscriberError SWIFT_COMPILE_NAME("receiptInUseByOtherSubscriberError") = 13,
  RCInvalidAppUserIdError SWIFT_COMPILE_NAME("invalidAppUserIdError") = 14,
  RCOperationAlreadyInProgressForProductError SWIFT_COMPILE_NAME("operationAlreadyInProgressForProductError") = 15,
  RCUnknownBackendError SWIFT_COMPILE_NAME("unknownBackendError") = 16,
  RCInvalidAppleSubscriptionKeyError SWIFT_COMPILE_NAME("invalidAppleSubscriptionKeyError") = 17,
  RCIneligibleError SWIFT_COMPILE_NAME("ineligibleError") = 18,
  RCInsufficientPermissionsError SWIFT_COMPILE_NAME("insufficientPermissionsError") = 19,
  RCPaymentPendingError SWIFT_COMPILE_NAME("paymentPendingError") = 20,
  RCInvalidSubscriberAttributesError SWIFT_COMPILE_NAME("invalidSubscriberAttributesError") = 21,
  RCLogOutAnonymousUserError SWIFT_COMPILE_NAME("logOutAnonymousUserError") = 22,
  RCConfigurationError SWIFT_COMPILE_NAME("configurationError") = 23,
  RCEmptySubscriberAttributesError SWIFT_COMPILE_NAME("emptySubscriberAttributes") = 24,
  RCProductDiscountMissingIdentifierError SWIFT_COMPILE_NAME("productDiscountMissingIdentifierError") = 25,
  RCMissingAppUserIDForAliasCreationError SWIFT_COMPILE_NAME("missingAppUserIDForAliasCreationError") = 26,
  RCProductDiscountMissingSubscriptionGroupIdentifierError SWIFT_COMPILE_NAME("productDiscountMissingSubscriptionGroupIdentifierError") = 27,
};
static NSString * _Nonnull const RCPurchasesErrorCodeDomain = @"RevenueCat.ErrorCode";


SWIFT_CLASS_NAMED("ErrorDetails")
@interface RCErrorDetails : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NSErrorUserInfoKey _Nonnull RCFinishableKey;)
+ (NSErrorUserInfoKey _Nonnull)RCFinishableKey SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) NSErrorUserInfoKey _Nonnull RCReadableErrorCodeKey;)
+ (NSErrorUserInfoKey _Nonnull)RCReadableErrorCodeKey SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("ErrorUtils")
@interface RCPurchasesErrorUtils : NSObject
/// Constructs an NSError with the <code>ErrorCode/networkError</code> code and a populated <code>NSUnderlyingErrorKey</code> in
/// the <code>NSError.userInfo</code> dictionary.
/// note:
/// This error is used when there is an error performing network request returns an error or when there
/// is an <code>NSJSONSerialization</code> error.
/// \param underlyingError The value of the <code>NSUnderlyingErrorKey</code> key.
///
+ (NSError * _Nonnull)networkErrorWithUnderlyingError:(NSError * _Nonnull)underlyingError SWIFT_WARN_UNUSED_RESULT;
/// Maps an <code>BackendErrorCode</code> code to a <code>ErrorCode</code>. code. Constructs an Error with the mapped code and adds a
/// <code>NSUnderlyingErrorKey</code> in the <code>NSError.userInfo</code> dictionary. The backend error code will be mapped using
/// <code>BackendErrorCode/toPurchasesErrorCode()</code>.
/// note:
/// This error is used when an network request returns an error. The backend error returned is wrapped in
/// this internal error code.
/// \param backendCode The numerical value of the error.
///
/// \param backendMessage The message of the errror contained under the <code>NSUnderlyingErrorKey</code> key.
///
+ (NSError * _Nonnull)backendErrorWithBackendCode:(NSNumber * _Nullable)backendCode backendMessage:(NSString * _Nullable)backendMessage SWIFT_WARN_UNUSED_RESULT;
/// Maps an <code>BackendErrorCode</code> code to an <code>ErrorCode</code>. code. Constructs an Error with the mapped code and adds a
/// <code>RCUnderlyingErrorKey</code> in the <code>NSError.userInfo</code> dictionary. The backend error code will be mapped using
/// <code>BackendErrorCode/toPurchasesErrorCode()</code>.
/// note:
/// This error is used when an network request returns an error. The backend error returned is wrapped in
/// this internal error code.
/// \param backendCode The numerical value of the error.
///
/// \param backendMessage The message of the errror contained under the <code>NSUnderlyingErrorKey</code> key in the
/// UserInfo dictionary.
///
/// \param finishable Will be added to the UserInfo dictionary under the <code>ErrorDetails/finishableKey</code> to
/// indicate if the transaction should be finished after this error.
///
+ (NSError * _Nonnull)backendErrorWithBackendCode:(NSNumber * _Nullable)backendCode backendMessage:(NSString * _Nullable)backendMessage finishable:(BOOL)finishable SWIFT_WARN_UNUSED_RESULT;
/// Constructs an Error with the <code>ErrorCode/unexpectedBackendResponseError</code> code.
/// note:
/// This error is used when an network request returns an unexpected response.
+ (NSError * _Nonnull)unexpectedBackendResponseError SWIFT_WARN_UNUSED_RESULT;
/// Constructs an Error with the <code>ErrorCode/missingReceiptFileError</code> code.
/// note:
/// This error is used when the receipt is missing in the device. This can happen if the user is in
/// sandbox or if there are no previous purchases.
+ (NSError * _Nonnull)missingReceiptFileError SWIFT_WARN_UNUSED_RESULT;
/// Constructs an Error with the <code>ErrorCode/invalidAppUserIdError</code> code.
/// note:
/// This error is used when the appUserID can’t be found in user defaults. This can happen if user defaults
/// are removed manually or if the OS deletes entries when running out of space.
+ (NSError * _Nonnull)missingAppUserIDError SWIFT_WARN_UNUSED_RESULT;
/// Constructs an Error with the <code>ErrorCode/productDiscountMissingIdentifierError</code> code.
/// note:
/// This error code is used when attemping to post data about product discounts but the discount is
/// missing an indentifier.
+ (NSError * _Nonnull)productDiscountMissingIdentifierError SWIFT_WARN_UNUSED_RESULT;
/// Constructs an Error with the <code>ErrorCode/productDiscountMissingSubscriptionGroupIdentifierError</code> code.
/// note:
/// This error code is used when attemping to post data about product discounts but the discount is
/// missing a subscriptionGroupIndentifier.
+ (NSError * _Nonnull)productDiscountMissingSubscriptionGroupIdentifierError SWIFT_WARN_UNUSED_RESULT;
/// Constructs an Error with the <code>ErrorCode/invalidAppUserIdError</code> code.
/// note:
/// This error is used when the appUserID can’t be found in user defaults. This can happen if user defaults
/// are removed manually or if the OS deletes entries when running out of space.
+ (NSError * _Nonnull)missingAppUserIDForAliasCreationError SWIFT_WARN_UNUSED_RESULT;
/// Constructs an Error with the <code>ErrorCode/logOutAnonymousUserError</code> code.
/// note:
/// This error is used when logOut is called but the current user is anonymous,
/// as noted by <code>Purchases/isAnonymous</code> property.
+ (NSError * _Nonnull)logOutAnonymousUserError SWIFT_WARN_UNUSED_RESULT;
/// Constructs an Error with the <code>ErrorCode/paymentPendingError</code> code.
/// note:
/// This error is used during an “ask to buy” flow for a payment. The completion block of the purchasing
/// function will get this error to indicate the guardian has to complete the purchase.
+ (NSError * _Nonnull)paymentDeferredError SWIFT_WARN_UNUSED_RESULT;
/// Constructs an Error with the <code>ErrorCode/unknownError</code> code and optional message.
+ (NSError * _Nonnull)unknownErrorWithMessage:(NSString * _Nullable)message SWIFT_WARN_UNUSED_RESULT;
/// Constructs an Error with the <code>ErrorCode/unknownError</code> code.
+ (NSError * _Nonnull)unknownError SWIFT_WARN_UNUSED_RESULT;
/// Constructs an Error with the <code>ErrorCode/operationAlreadyInProgressForProductError</code> code.
/// note:
/// This error is used when a purchase is initiated for a product, but there’s already a purchase for the
/// same product in progress.
+ (NSError * _Nonnull)operationAlreadyInProgressError SWIFT_WARN_UNUSED_RESULT;
/// Maps an <code>SKError</code> to a Error with a <code>ErrorCode</code>. Adds a underlying error in the <code>NSError.userInfo</code> dictionary.
/// \param skError The originating <code>SKError</code>.
///
+ (NSError * _Nonnull)purchasesErrorWithSKError:(NSError * _Nonnull)skError SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end




SWIFT_CLASS("_TtC10RevenueCat23FakeASIdentifierManager")
@interface FakeASIdentifierManager : NSObject
+ (FakeASIdentifierManager * _Nonnull)sharedManager SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC10RevenueCat12FakeAdClient")
@interface FakeAdClient : NSObject
+ (FakeAdClient * _Nonnull)sharedClient SWIFT_WARN_UNUSED_RESULT;
- (void)requestAttributionDetailsWithBlock:(void (^ _Nonnull)(NSDictionary<NSString *, NSObject *> * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC10RevenueCat19FakeTrackingManager")
@interface FakeTrackingManager : NSObject
+ (NSInteger)trackingAuthorizationStatus SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, FakeTrackingManagerAuthorizationStatus, closed) {
  FakeTrackingManagerAuthorizationStatusNotDetermined = 0,
  FakeTrackingManagerAuthorizationStatusRestricted = 1,
  FakeTrackingManagerAuthorizationStatusDenied = 2,
  FakeTrackingManagerAuthorizationStatusAuthorized = 3,
};

enum RCIntroEligibilityStatus : NSInteger;

/// Holds the introductory price status
SWIFT_CLASS_NAMED("IntroEligibility")
@interface RCIntroEligibility : NSObject
/// The introductory price eligibility status
@property (nonatomic, readonly) enum RCIntroEligibilityStatus status;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Enum of different possible states for intro price eligibility status.
/// <ul>
///   <li>
///     <code>IntroEligibilityStatus/unknown</code> RevenueCat doesn’t have enough information to determine eligibility.
///   </li>
///   <li>
///     <code>IntroEligibilityStatus/ineligible</code> The user is not eligible for a free trial or intro pricing for this
///     product.
///   </li>
///   <li>
///     <code>IntroEligibilityStatus/eligible</code> The user is eligible for a free trial or intro pricing for this product.
///   </li>
/// </ul>
typedef SWIFT_ENUM_NAMED(NSInteger, RCIntroEligibilityStatus, "IntroEligibilityStatus", open) {
/// RevenueCat doesn’t have enough information to determine eligibility.
  RCIntroEligibilityStatusUnknown = 0,
/// The user is not eligible for a free trial or intro pricing for this product.
  RCIntroEligibilityStatusIneligible = 1,
/// The user is eligible for a free trial or intro pricing for this product.
  RCIntroEligibilityStatusEligible = 2,
};

typedef SWIFT_ENUM_NAMED(NSInteger, RCLogLevel, "LogLevel", open) {
  RCLogLevelDebug = 0,
  RCLogLevelInfo = 1,
  RCLogLevelWarn = 2,
  RCLogLevelError = 3,
};




@class RCPackage;

SWIFT_CLASS_NAMED("Offering")
@interface RCOffering : NSObject
/// Unique identifier defined in RevenueCat dashboard.
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
/// Offering description defined in RevenueCat dashboard.
@property (nonatomic, readonly, copy) NSString * _Nonnull serverDescription;
/// Array of <code>Package</code> objects available for purchase.
@property (nonatomic, readonly, copy) NSArray<RCPackage *> * _Nonnull availablePackages;
/// Lifetime <code>Package</code> type configured in the RevenueCat dashboard, if available.
@property (nonatomic, readonly, strong) RCPackage * _Nullable lifetime;
/// Annual <code>Package</code> type configured in the RevenueCat dashboard, if available.
@property (nonatomic, readonly, strong) RCPackage * _Nullable annual;
/// Six month <code>Package</code> type configured in the RevenueCat dashboard, if available.
@property (nonatomic, readonly, strong) RCPackage * _Nullable sixMonth;
/// Three month <code>Package</code> type configured in the RevenueCat dashboard, if available.
@property (nonatomic, readonly, strong) RCPackage * _Nullable threeMonth;
/// Two month <code>Package</code> type configured in the RevenueCat dashboard, if available.
@property (nonatomic, readonly, strong) RCPackage * _Nullable twoMonth;
/// Monthly <code>Package</code> type configured in the RevenueCat dashboard, if available.
@property (nonatomic, readonly, strong) RCPackage * _Nullable monthly;
/// Weekly <code>Package</code> type configured in the RevenueCat dashboard, if available.
@property (nonatomic, readonly, strong) RCPackage * _Nullable weekly;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Retrieves a specific <code>Package</code> by identifier, use this to access custom package types configured in the
/// RevenueCat dashboard, e.g. <code>offering.package(identifier: "custom_package_id")</code> or
/// <code>offering["custom_package_id"]</code>.
- (RCPackage * _Nullable)packageWithIdentifier:(NSString * _Nullable)identifier SWIFT_WARN_UNUSED_RESULT;
- (RCPackage * _Nullable)objectForKeyedSubscript:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// This class contains all the offerings configured in RevenueCat dashboard.
/// For more info see https://docs.revenuecat.com/docs/entitlements
SWIFT_CLASS_NAMED("Offerings")
@interface RCOfferings : NSObject
/// Dictionary of all Offerings (<code>Offering</code>) objects keyed by their identifier. This dictionary can also be accessed
/// by using an index subscript on <code>Offerings</code>, e.g. <code>offerings["offering_id"]</code>. To access the current offering use
/// <code>Offerings/current</code>.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, RCOffering *> * _Nonnull all;
/// Current <code>Offering</code> configured in the RevenueCat dashboard.
@property (nonatomic, readonly, strong) RCOffering * _Nullable current;
/// Retrieves a specific offering by its identifier, use this to access additional offerings configured in the
/// RevenueCat dashboard, e.g. <code>offerings.offering(identifier: "offering_id")</code> or <code>offerings[@"offering_id"]</code>.
/// To access the current offering use <code>Offerings/current</code>.
- (RCOffering * _Nullable)offeringWithIdentifier:(NSString * _Nullable)identifier SWIFT_WARN_UNUSED_RESULT;
- (RCOffering * _Nullable)objectForKeyedSubscript:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum RCPackageType : NSInteger;
@class SKProduct;

SWIFT_CLASS_NAMED("Package")
@interface RCPackage : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
@property (nonatomic, readonly) enum RCPackageType packageType;
@property (nonatomic, readonly, strong) SKProduct * _Nonnull product;
@property (nonatomic, readonly, copy) NSString * _Nonnull offeringIdentifier;
@property (nonatomic, readonly, copy) NSString * _Nonnull localizedPriceString;
@property (nonatomic, readonly, copy) NSString * _Nonnull localizedIntroductoryPriceString;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@interface RCPackage (SWIFT_EXTENSION(RevenueCat))
/// \param packageType A <code>PackageType</code>.
///
///
/// returns:
/// an optional description of the packageType.
+ (NSString * _Nullable)stringFrom:(enum RCPackageType)packageType SWIFT_WARN_UNUSED_RESULT;
/// \param string A string that maps to a enumeration value of type <code>PackageType</code>
///
///
/// returns:
/// a <code>PackageType</code> for the given string.
+ (enum RCPackageType)packageTypeFrom:(NSString * _Nonnull)string SWIFT_WARN_UNUSED_RESULT;
@end

typedef SWIFT_ENUM_NAMED(NSInteger, RCPackageType, "PackageType", open) {
/// A package that was defined with an unknown identifier.
  RCPackageTypeUnknown = -2,
/// A package that was defined with an unknown identifier.
  RCPackageTypeCustom = -1,
/// A package that was defined with an unknown identifier.
  RCPackageTypeLifetime = 0,
/// A package that was defined with an unknown identifier.
  RCPackageTypeAnnual = 1,
/// A package that was defined with an unknown identifier.
  RCPackageTypeSixMonth = 2,
/// A package that was defined with an unknown identifier.
  RCPackageTypeThreeMonth = 3,
/// A package that was defined with an unknown identifier.
  RCPackageTypeTwoMonth = 4,
/// A package that was defined with an unknown identifier.
  RCPackageTypeMonthly = 5,
/// A package that was defined with an unknown identifier.
  RCPackageTypeWeekly = 6,
};

/// Enum of supported period types for an entitlement.
typedef SWIFT_ENUM_NAMED(NSInteger, RCPeriodType, "PeriodType", open) {
/// If the entitlement is not under an introductory or trial period.
  RCNormal SWIFT_COMPILE_NAME("normal") = 0,
/// If the entitlement is under a introductory price period.
  RCIntro SWIFT_COMPILE_NAME("intro") = 1,
/// If the entitlement is under a trial period.
  RCTrial SWIFT_COMPILE_NAME("trial") = 2,
};


SWIFT_CLASS("_TtC10RevenueCat15ProductsManager")
@interface ProductsManager : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@class SKProductsRequest;
@class SKProductsResponse;
@class SKRequest;

@interface ProductsManager (SWIFT_EXTENSION(RevenueCat)) <SKProductsRequestDelegate>
- (void)productsRequest:(SKProductsRequest * _Nonnull)request didReceiveResponse:(SKProductsResponse * _Nonnull)response;
- (void)requestDidFinish:(SKRequest * _Nonnull)request;
- (void)request:(SKRequest * _Nonnull)request didFailWithError:(NSError * _Nonnull)error;
@end

typedef SWIFT_ENUM_NAMED(NSInteger, RCPurchaseOwnershipType, "PurchaseOwnershipType", open) {
/// The purchase was made directly by this user.
  RCPurchaseOwnershipTypePurchased = 0,
/// The purchase has been shared to this user by a family member.
  RCPurchaseOwnershipTypeFamilyShared = 1,
  RCPurchaseOwnershipTypeUnknown = 2,
};

@class RCTransaction;
@class NSURL;

SWIFT_CLASS_NAMED("PurchaserInfo")
@interface RCPurchaserInfo : NSObject
/// <code>EntitlementInfos</code> attached to this purchaser info.
@property (nonatomic, readonly, strong) RCEntitlementInfos * _Nonnull entitlements;
/// All <em>subscription</em> product identifiers with expiration dates in the future.
@property (nonatomic, readonly, copy) NSSet<NSString *> * _Nonnull activeSubscriptions;
/// All product identifiers purchases by the user regardless of expiration.
@property (nonatomic, copy) NSSet<NSString *> * _Nonnull allPurchasedProductIdentifiers;
/// Returns the latest expiration date of all products, nil if there are none.
@property (nonatomic, readonly, copy) NSDate * _Nullable latestExpirationDate;
/// Returns all product IDs of the non-subscription purchases a user has made.
@property (nonatomic, readonly, copy) NSSet<NSString *> * _Nonnull nonConsumablePurchases SWIFT_DEPRECATED_MSG("use nonSubscriptionTransactions");
/// Returns all the non-subscription purchases a user has made.
/// The purchases are ordered by purchase date in ascending order.
@property (nonatomic, readonly, copy) NSArray<RCTransaction *> * _Nonnull nonSubscriptionTransactions;
/// Returns the fetch date of this Purchaser info.
@property (nonatomic, readonly, copy) NSDate * _Nonnull requestDate;
/// The date this user was first seen in RevenueCat.
@property (nonatomic, readonly, copy) NSDate * _Nonnull firstSeen;
/// The original App User Id recorded for this user.
@property (nonatomic, readonly, copy) NSString * _Nonnull originalAppUserId;
/// URL to manage the active subscription of the user.
/// <ul>
///   <li>
///     If this user has an active iOS subscription, this will point to the App Store.
///   </li>
///   <li>
///     If the user has an active Play Store subscription it will point there.
///   </li>
///   <li>
///     If there are no active subscriptions it will be null.
///   </li>
///   <li>
///     If there are multiple for different platforms, it will point to the App Store.
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSURL * _Nullable managementURL;
/// Returns the purchase date for the version of the application when the user bought the app.
/// Use this for grandfathering users when migrating to subscriptions.
/// Note: This can be <code>nil</code>, see <code>Purchases/restoreTransactions(completion:)</code>
@property (nonatomic, readonly, copy) NSDate * _Nullable originalPurchaseDate;
/// The build number (in iOS) or the marketing version (in macOS) for the version of the application when the user
/// bought the app. This corresponds to the value of CFBundleVersion (in iOS) or CFBundleShortVersionString
/// (in macOS) in the Info.plist file when the purchase was originally made. Use this for grandfathering users
/// when migrating to subscriptions.
/// note:
/// This can be nil, see -<code>Purchases.restoreTransactions(completion:)</code>
@property (nonatomic, readonly, copy) NSString * _Nullable originalApplicationVersion;
/// Get the expiration date for a given product identifier. You should use Entitlements though!
/// \param productIdentifier Product identifier for product
///
///
/// returns:
/// The expiration date for <code>productIdentifier</code>, <code>nil</code> if product never purchased
- (NSDate * _Nullable)expirationDateForProductIdentifier:(NSString * _Nonnull)productIdentifier SWIFT_WARN_UNUSED_RESULT;
/// Get the latest purchase or renewal date for a given product identifier. You should use Entitlements though!
/// \param productIdentifier Product identifier for subscription product
///
///
/// returns:
/// The purchase date for <code>productIdentifier</code>, <code>nil</code> if product never purchased
- (NSDate * _Nullable)purchaseDateForProductIdentifier:(NSString * _Nonnull)productIdentifier SWIFT_WARN_UNUSED_RESULT;
/// Get the expiration date for a given entitlement.
/// \param entitlementIdentifier The ID of the entitlement
///
///
/// returns:
/// The expiration date for the passed in <code>entitlementIdentifier</code>, or <code>nil</code>
- (NSDate * _Nullable)expirationDateForEntitlement:(NSString * _Nonnull)entitlementIdentifier SWIFT_WARN_UNUSED_RESULT;
/// Get the latest purchase or renewal date for a given entitlement identifier.
/// \param entitlementIdentifier Entitlement identifier for entitlement
///
///
/// returns:
/// The purchase date for <code>entitlementIdentifier</code>, <code>nil</code> if product never purchased
- (NSDate * _Nullable)purchaseDateForEntitlement:(NSString * _Nonnull)entitlementIdentifier SWIFT_WARN_UNUSED_RESULT;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@protocol RCPurchasesDelegate;

/// <code>Purchases</code> is the entry point for RevenueCat.framework. It should be instantiated as soon as your app has a unique
/// user id for your user. This can be when a user logs in if you have accounts or on launch if you can generate a random
/// user identifier.
/// warning:
/// Only one instance of Purchases should be instantiated at a time! Use a configure method to let the
/// framework handle the singleton instance for you.
SWIFT_CLASS_NAMED("Purchases")
@interface RCPurchases : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) RCPurchases * _Nonnull sharedPurchases;)
+ (RCPurchases * _Nonnull)sharedPurchases SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL isConfigured;)
+ (BOOL)isConfigured SWIFT_WARN_UNUSED_RESULT;
/// Delegate for <code>Purchases</code> instance. The delegate is responsible for handling promotional product purchases and
/// changes to purchaser information.
@property (nonatomic, strong) id <RCPurchasesDelegate> _Nullable delegate;
/// Enable automatic collection of Apple Search Ads attribution. Disabled by default
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL automaticAppleSearchAdsAttributionCollection;)
+ (BOOL)automaticAppleSearchAdsAttributionCollection SWIFT_WARN_UNUSED_RESULT;
+ (void)setAutomaticAppleSearchAdsAttributionCollection:(BOOL)value;
/// Used to set the log level. Useful for debugging issues with the lovely team @RevenueCat
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) enum RCLogLevel logLevel;)
+ (enum RCLogLevel)logLevel SWIFT_WARN_UNUSED_RESULT;
+ (void)setLogLevel:(enum RCLogLevel)newValue;
/// Enable debug logging. Useful for debugging issues with the lovely team @RevenueCat.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL debugLogsEnabled SWIFT_DEPRECATED_MSG("use Purchases.logLevel instead");)
+ (BOOL)debugLogsEnabled SWIFT_WARN_UNUSED_RESULT;
+ (void)setDebugLogsEnabled:(BOOL)newValue;
/// Set this property to your proxy URL before configuring Purchases <em>only</em> if you’ve received a proxy key value
/// from your RevenueCat contact.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSURL * _Nullable proxyURL;)
+ (NSURL * _Nullable)proxyURL SWIFT_WARN_UNUSED_RESULT;
+ (void)setProxyURL:(NSURL * _Nullable)newValue;
/// Set this property to true <em>only</em> if you’re transitioning an existing Mac app from the Legacy
/// Mac App Store into the Universal Store, and you’ve configured your RevenueCat app accordingly.
/// Contact support before using this.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL forceUniversalAppStore;)
+ (BOOL)forceUniversalAppStore SWIFT_WARN_UNUSED_RESULT;
+ (void)setForceUniversalAppStore:(BOOL)newValue;
/// Set this property to true <em>only</em> when testing the ask-to-buy / SCA purchases flow. More information:
/// http://errors.rev.cat/ask-to-buy
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL simulatesAskToBuyInSandbox SWIFT_AVAILABILITY(maccatalyst,introduced=13.0) SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(macos,introduced=10.14) SWIFT_AVAILABILITY(ios,introduced=8.0);)
+ (BOOL)simulatesAskToBuyInSandbox SWIFT_WARN_UNUSED_RESULT;
+ (void)setSimulatesAskToBuyInSandbox:(BOOL)newValue;
/// Indicates whether the user is allowed to make payments.
+ (BOOL)canMakePayments SWIFT_WARN_UNUSED_RESULT;
/// Set a custom log handler for redirecting logs to your own logging system.
/// By default, this sends Info, Warn, and Error messages. If you wish to receive Debug level messages,
/// you must enable debug logs.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) void (^ _Nonnull logHandler)(enum RCLogLevel, NSString * _Nonnull);)
+ (void (^ _Nonnull)(enum RCLogLevel, NSString * _Nonnull))logHandler SWIFT_WARN_UNUSED_RESULT;
+ (void)setLogHandler:(void (^ _Nonnull)(enum RCLogLevel, NSString * _Nonnull))newValue;
/// Current version of the Purchases framework.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull frameworkVersion;)
+ (NSString * _Nonnull)frameworkVersion SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic) BOOL allowSharingAppStoreAccount SWIFT_DEPRECATED_MSG("Configure behavior through the RevenueCat dashboard instead");
@property (nonatomic) BOOL finishTransactions;
/// Automatically collect subscriber attributes associated with the device identifiers
/// $idfa, $idfv, $ip
- (void)collectDeviceIdentifiers;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class SKPaymentTransaction;

SWIFT_PROTOCOL("_TtP10RevenueCat29PurchasesOrchestratorDelegate_")
@protocol PurchasesOrchestratorDelegate
- (void)shouldPurchasePromoProduct:(SKProduct * _Nonnull)product defermentBlock:(void (^ _Nonnull)(void (^ _Nonnull)(SKPaymentTransaction * _Nullable, RCPurchaserInfo * _Nullable, NSError * _Nullable, BOOL)))defermentBlock;
@end


@interface RCPurchases (SWIFT_EXTENSION(RevenueCat)) <PurchasesOrchestratorDelegate>
/// Called when a user initiates a promotional in-app purchase from the App Store.
/// If your app is able to handle a purchase at the current time, run the deferment block in this method.
/// If the app is not in a state to make a purchase: cache the defermentBlock, then call the defermentBlock
/// when the app is ready to make the promotional purchase.
/// If the purchase should never be made, you don’t need to ever call the defermentBlock and <code>Purchases</code>
/// will not proceed with promotional purchases.
/// \param product <code>SKProduct</code> the product that was selected from the app store.
///
- (void)shouldPurchasePromoProduct:(SKProduct * _Nonnull)product defermentBlock:(void (^ _Nonnull)(void (^ _Nonnull)(SKPaymentTransaction * _Nullable, RCPurchaserInfo * _Nullable, NSError * _Nullable, BOOL)))defermentBlock;
@end



@interface RCPurchases (SWIFT_EXTENSION(RevenueCat))
/// Send your attribution data to RevenueCat so you can track the revenue generated by your different campaigns.
/// \param data Dictionary provided by the network. See https://docs.revenuecat.com/docs/attribution
///
/// \param network Enum for the network the data is coming from, see <code>AttributionNetwork</code> for supported
/// networks.
///
+ (void)addAttributionData:(NSDictionary<NSString *, id> * _Nonnull)data fromNetwork:(enum RCAttributionNetwork)network SWIFT_DEPRECATED_MSG("Use the set<NetworkId> functions instead");
/// Send your attribution data to RevenueCat so you can track the revenue generated by your different campaigns.
/// \param data Dictionary provided by the network. See https://docs.revenuecat.com/docs/attribution
///
/// \param network Enum for the network the data is coming from, see <code>AttributionNetwork</code> for supported
/// networks.
///
/// \param networkUserId User Id that should be sent to the network. Default is the current App User Id.
///
+ (void)addAttributionData:(NSDictionary<NSString *, id> * _Nonnull)data fromNetwork:(enum RCAttributionNetwork)network forNetworkUserId:(NSString * _Nullable)networkUserId SWIFT_DEPRECATED_MSG("Use the set<NetworkId> functions instead");
@end

@class NSUserDefaults;

@interface RCPurchases (SWIFT_EXTENSION(RevenueCat))
/// Configures an instance of the Purchases SDK with a specified API key. The instance will be set as a singleton.
/// You should access the singleton instance using <code>Purchases/shared</code>
/// note:
/// Use this initializer if your app does not have an account system.
/// <code>Purchases</code> will generate a unique identifier for the current device and persist it to <code>NSUserDefaults</code>.
/// This also affects the behavior of <code>Purchases/restoreTransactions(completion:)</code>.
/// \param apiKey The API Key generated for your app from https://app.revenuecat.com/
///
///
/// returns:
/// An instantiated <code>Purchases</code> object that has been set as a singleton.
+ (RCPurchases * _Nonnull)configureWithAPIKey:(NSString * _Nonnull)apiKey;
/// Configures an instance of the Purchases SDK with a specified API key and app user ID.
/// The instance will be set as a singleton.
/// You should access the singleton instance using <code>Purchases/shared</code>
/// note:
/// Best practice is to use a salted hash of your unique app user ids.
/// warning:
/// Use this initializer if you have your own user identifiers that you manage.
/// \param apiKey The API Key generated for your app from https://app.revenuecat.com/
///
/// \param appUserID The unique app user id for this user. This user id will allow users to share their
/// purchases and subscriptions across devices. Pass nil if you want <code>Purchases</code> to generate this for you.
///
///
/// returns:
/// An instantiated <code>Purchases</code> object that has been set as a singleton.
+ (RCPurchases * _Nonnull)configureWithAPIKey:(NSString * _Nonnull)apiKey appUserID:(NSString * _Nullable)appUserID;
/// Configures an instance of the Purchases SDK with a custom userDefaults. Use this constructor if you want to
/// sync status across a shared container, such as between a host app and an extension. The instance of the
/// Purchases SDK will be set as a singleton.
/// You should access the singleton instance using <code>Purchases.shared</code>
/// \param apiKey The API Key generated for your app from https://app.revenuecat.com/
///
/// \param appUserID The unique app user id for this user. This user id will allow users to share their
/// purchases and subscriptions across devices. Pass nil if you want <code>Purchases</code> to generate this for you.
///
/// \param observerMode Set this to <code>true</code> if you have your own IAP implementation and want to use only
/// RevenueCat’s backend. Default is <code>false</code>.
///
///
/// returns:
/// An instantiated <code>Purchases</code> object that has been set as a singleton.
+ (RCPurchases * _Nonnull)configureWithAPIKey:(NSString * _Nonnull)apiKey appUserID:(NSString * _Nullable)appUserID observerMode:(BOOL)observerMode;
/// Configures an instance of the Purchases SDK with a custom userDefaults. Use this constructor if you want to
/// sync status across a shared container, such as between a host app and an extension. The instance of the
/// Purchases SDK will be set as a singleton.
/// You should access the singleton instance using <code>Purchases.shared</code>
/// \param apiKey The API Key generated for your app from https://app.revenuecat.com/
///
/// \param appUserID The unique app user id for this user. This user id will allow users to share their
/// purchases and subscriptions across devices. Pass nil if you want <code>Purchases</code> to generate this for you.
///
/// \param observerMode Set this to <code>true</code> if you have your own IAP implementation and want to use only
/// RevenueCat’s backend. Default is <code>false</code>.
///
/// \param userDefaults Custom userDefaults to use
///
///
/// returns:
/// An instantiated <code>Purchases</code> object that has been set as a singleton.
+ (RCPurchases * _Nonnull)configureWithAPIKey:(NSString * _Nonnull)apiKey appUserID:(NSString * _Nullable)appUserID observerMode:(BOOL)observerMode userDefaults:(NSUserDefaults * _Nullable)userDefaults;
@end



@interface RCPurchases (SWIFT_EXTENSION(RevenueCat))
/// <ul>
///   <li>
///     The <code>appUserID</code> used by <code>Purchases</code>.
///   </li>
///   <li>
///     If not passed on initialization this will be generated and cached by <code>Purchases</code>.
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSString * _Nonnull appUserID;
/// If the <code>appUserID</code> has been generated by RevenueCat
@property (nonatomic, readonly) BOOL isAnonymous;
/// This function will alias two appUserIDs together.
/// \param alias The new appUserID that should be linked to the currently identified appUserID
///
/// \param completion An optional completion block called when the aliasing has been successful.
/// This completion block will receive an error if there’s been one.
///
- (void)createAlias:(NSString * _Nonnull)alias completion:(void (^ _Nullable)(RCPurchaserInfo * _Nullable, NSError * _Nullable))completion SWIFT_DEPRECATED_MSG("use logIn instead", "logIn:completion:");
/// This function will identify the current user with an appUserID. Typically this would be used after a
/// logout to identify a new user without calling configure.
/// \param appUserID The appUserID that should be linked to the current user.
///
/// \param completion An optional completion block called when the identify call has completed.
/// This completion block will receive an error if there’s been one.
///
- (void)identify:(NSString * _Nonnull)appUserID completion:(void (^ _Nullable)(RCPurchaserInfo * _Nullable, NSError * _Nullable))completion SWIFT_DEPRECATED_MSG("use logIn instead");
/// This function will logIn the current user with an appUserID.
/// The callback will be called with the latest PurchaserInfo for the user, as well as a boolean
/// indicating whether the user was created for the first time in the RevenueCat backend.
/// See https://docs.revenuecat.com/docs/user-ids
/// \param appUserID The appUserID that should be linked to the current user.
///
- (void)logIn:(NSString * _Nonnull)appUserID completion:(void (^ _Nonnull)(RCPurchaserInfo * _Nullable, BOOL, NSError * _Nullable))completion;
/// Logs out the Purchases client clearing the saved appUserID.
/// This will generate a random user id and save it in the cache.
/// If this method is called and the current user is anonymous, it will return an error.
/// See https://docs.revenuecat.com/docs/user-ids
- (void)logOutWithCompletion:(void (^ _Nullable)(RCPurchaserInfo * _Nullable, NSError * _Nullable))completion;
/// Resets the Purchases client clearing the saved appUserID.
/// This will generate a random user id and save it in the cache.
- (void)resetWithCompletion:(void (^ _Nullable)(RCPurchaserInfo * _Nullable, NSError * _Nullable))completion SWIFT_DEPRECATED_MSG("use logOut instead", "logOutWithCompletion:");
/// Fetch the configured offerings for this users. <code>Offerings</code> allows you to configure your in-app products
/// via RevenueCat and greatly simplifies management.
/// See the guide (https://docs.revenuecat.com/entitlements) for more info.
/// <code>Offerings</code> will be fetched and cached on instantiation so that, by the time they are needed,
/// your prices are loaded for your purchase flow. Time is money.
/// \param completion A completion block called when offerings are available.
/// Called immediately if offerings are cached. Offerings will be nil if an error occurred.
///
- (void)offeringsWithCompletion:(void (^ _Nonnull)(RCOfferings * _Nullable, NSError * _Nullable))completion;
@end

@class SKPaymentDiscount;
@class SKProductDiscount;

@interface RCPurchases (SWIFT_EXTENSION(RevenueCat))
/// Get latest available purchaser info.
/// \param completion A completion block called when purchaser info is available and not stale.
/// Called immediately if <code>PurchaserInfo</code> is cached. Purchaser info can be nil * if an error occurred.
///
- (void)purchaserInfoWithCompletion:(void (^ _Nonnull)(RCPurchaserInfo * _Nullable, NSError * _Nullable))completion;
/// Fetches the <code>SKProducts</code> for your IAPs for given <code>productIdentifiers</code>.
/// Use this method if you aren’t using <code>offerings(completion:)</code>.
/// You should use offerings though.
/// note:
/// <code>completion</code> may be called without <code>SKProduct</code>s that you are expecting. This is usually caused by
/// iTunesConnect configuration errors. Ensure your IAPs have the “Ready to Submit” status in iTunesConnect.
/// Also ensure that you have an active developer program subscription and you have signed the latest paid
/// application agreements.
/// If you’re having trouble see: https://www.revenuecat.com/2018/10/11/configuring-in-app-products-is-hard
/// \param productIdentifiers A set of product identifiers for in app purchases setup via AppStoreConnect:
/// https://appstoreconnect.apple.com/
/// This should be either hard coded in your application, from a file, or from a custom endpoint if you want
/// to be able to deploy new IAPs without an app update.
///
/// \param completion An @escaping callback that is called with the loaded products.
/// If the fetch fails for any reason it will return an empty array.
///
- (void)productsWithIdentifiers:(NSArray<NSString *> * _Nonnull)productIdentifiers completion:(void (^ _Nonnull)(NSArray<SKProduct *> * _Nonnull))completion;
/// Use this function if you are not using the Offerings system to purchase an <code>SKProduct</code>.
/// If you are using the Offerings system, use <code>Purchases/purchase(package:completion:)</code> instead.
/// Call this method when a user has decided to purchase a product. Only call this in direct response to user input.
/// From here <code>Purchases</code> will handle the purchase with <code>StoreKit</code> and call the <code>PurchaseCompletedBlock</code>.
/// note:
/// You do not need to finish the transaction yourself in the completion callback, Purchases will
/// handle this for you.
/// If the purchase was successful there will be a <code>SKPaymentTransaction</code> and a <code>PurchaserInfo</code>.
/// If the purchase was not successful, there will be an <code>NSError</code>.
/// If the user cancelled, <code>userCancelled</code> will be <code>YES</code>.
/// \param product The <code>SKProduct</code> the user intends to purchase
///
/// \param completion A completion block that is called when the purchase completes.
///
- (void)purchaseProduct:(SKProduct * _Nonnull)product withCompletion:(void (^ _Nonnull)(SKPaymentTransaction * _Nullable, RCPurchaserInfo * _Nullable, NSError * _Nullable, BOOL))completion;
/// Purchase the passed <code>Package</code>.
/// Call this method when a user has decided to purchase a product. Only call this in direct response to user input.
/// From here <code>Purchases</code> will handle the purchase with <code>StoreKit</code> and call the <code>PurchaseCompletedBlock</code>.
/// note:
/// You do not need to finish the transaction yourself in the completion callback, Purchases will
/// handle this for you.
/// If the purchase was successful there will be a <code>SKPaymentTransaction</code> and a <code>PurchaserInfo</code>.
/// If the purchase was not successful, there will be an <code>Error</code>.
/// If the user cancelled, <code>userCancelled</code> will be <code>true</code>.
/// \param package The <code>Package</code> the user intends to purchase
///
/// \param completion A completion block that is called when the purchase completes.
///
- (void)purchasePackage:(RCPackage * _Nonnull)package withCompletion:(void (^ _Nonnull)(SKPaymentTransaction * _Nullable, RCPurchaserInfo * _Nullable, NSError * _Nullable, BOOL))completion;
/// Use this function if you are not using the Offerings system to purchase an <code>SKProduct</code> with an
/// applied <code>SKPaymentDiscount</code>.
/// If you are using the Offerings system, use <code>Purchases/purchase(package:discount:completion:)</code> instead.
/// Call this method when a user has decided to purchase a product with an applied discount.
/// Only call this in direct response to user input.
/// From here <code>Purchases</code> will handle the purchase with <code>StoreKit</code> and call the <code>PurchaseCompletedBlock</code>.
/// note:
/// You do not need to finish the transaction yourself in the completion callback, Purchases will handle
/// this for you.
/// If the purchase was successful there will be a <code>SKPaymentTransaction</code> and a <code>PurchaserInfo</code>.
/// If the purchase was not successful, there will be an <code>Error</code>.
/// If the user cancelled, <code>userCancelled</code> will be <code>true</code>.
/// \param product The <code>SKProduct</code> the user intends to purchase
///
/// \param discount The <code>SKPaymentDiscount</code> to apply to the purchase
///
/// \param completion A completion block that is called when the purchase completes.
///
- (void)purchaseProduct:(SKProduct * _Nonnull)product withDiscount:(SKPaymentDiscount * _Nonnull)discount completion:(void (^ _Nonnull)(SKPaymentTransaction * _Nullable, RCPurchaserInfo * _Nullable, NSError * _Nullable, BOOL))completion SWIFT_AVAILABILITY(tvos,introduced=12.2) SWIFT_AVAILABILITY(maccatalyst,introduced=13.0) SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(macos,introduced=10.14.4) SWIFT_AVAILABILITY(ios,introduced=12.2);
/// Purchase the passed <code>Package</code>.
/// Call this method when a user has decided to purchase a product with an applied discount. Only call this in
/// direct response to user input. From here <code>Purchases</code> will handle the purchase with <code>StoreKit</code> and call the
/// <code>PurchaseCompletedBlock</code>.
/// note:
/// You do not need to finish the transaction yourself in the completion callback, Purchases will handle
/// this for you.
/// If the purchase was successful there will be a <code>SKPaymentTransaction</code> and a <code>PurchaserInfo</code>.
/// If the purchase was not successful, there will be an <code>Error</code>.
/// If the user cancelled, <code>userCancelled</code> will be <code>true</code>.
/// \param package The <code>Package</code> the user intends to purchase
///
/// \param discount The <code>SKPaymentDiscount</code> to apply to the purchase
///
/// \param completion A completion block that is called when the purchase completes.
///
- (void)purchasePackage:(RCPackage * _Nonnull)package withDiscount:(SKPaymentDiscount * _Nonnull)discount completion:(void (^ _Nonnull)(SKPaymentTransaction * _Nullable, RCPurchaserInfo * _Nullable, NSError * _Nullable, BOOL))completion SWIFT_AVAILABILITY(tvos,introduced=12.2) SWIFT_AVAILABILITY(maccatalyst,introduced=13.0) SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(macos,introduced=10.14.4) SWIFT_AVAILABILITY(ios,introduced=12.2);
/// This method will post all purchases associated with the current App Store account to RevenueCat and
/// become associated with the current <code>appUserID</code>.
/// If the receipt is being used by an existing user, the current <code>appUserID</code> will be aliased together with
/// the <code>appUserID</code> of the existing user.
/// Going forward, either <code>appUserID</code> will be able to reference the same user.
/// warning:
/// This function should only be called if you’re not calling any purchase method.
/// note:
/// This method will not trigger a login prompt from App Store. However, if the receipt currently
/// on the device does not contain subscriptions, but the user has made subscription purchases, this method
/// won’t be able to restore them. Use <code>restoreTransactions(completion:)</code> to cover those cases.
- (void)syncPurchasesWithCompletion:(void (^ _Nullable)(RCPurchaserInfo * _Nullable, NSError * _Nullable))completion;
/// This method will post all purchases associated with the current App Store account to RevenueCat and become
/// associated with the current <code>appUserID</code>. If the receipt is being used by an existing user, the current
/// <code>appUserID</code> will be aliased together with the <code>appUserID</code> of the existing user.
/// Going forward, either <code>appUserID</code> will be able to reference the same user.
/// You shouldn’t use this method if you have your own account system. In that case “restoration” is provided
/// by your app passing the same <code>appUserId</code> used to purchase originally.
/// note:
/// This may force your users to enter the App Store password so should only be performed on request of
/// the user. Typically with a button in settings or near your purchase UI. Use
/// <code>Purchases/syncPurchases(completion:)</code> if you need to restore transactions programmatically.
- (void)restoreTransactionsWithCompletion:(void (^ _Nullable)(RCPurchaserInfo * _Nullable, NSError * _Nullable))completion;
/// Computes whether or not a user is eligible for the introductory pricing period of a given product.
/// You should use this method to determine whether or not you show the user the normal product price or
/// the introductory price. This also applies to trials (trials are considered a type of introductory pricing).
/// note:
/// Subscription groups are automatically collected for determining eligibility. If RevenueCat can’t
/// definitively compute the eligibilty, most likely because of missing group information, it will return
/// <code>IntroEligibilityStatus/unknown</code>. The best course of action on unknown status is to display the non-intro
/// pricing, to not create a misleading situation. To avoid this, make sure you are testing with the latest
/// version of iOS so that the subscription group can be collected by the SDK.
/// \param productIdentifiers Array of product identifiers for which you want to compute eligibility
///
/// \param completion A block that receives a dictionary of product_id -> <code>IntroEligibility</code>.
///
- (void)checkTrialOrIntroductoryPriceEligibility:(NSArray<NSString *> * _Nonnull)productIdentifiers completion:(void (^ _Nonnull)(NSDictionary<NSString *, RCIntroEligibility *> * _Nonnull))completion;
/// Invalidates the cache for purchaser information.
/// Most apps will not need to use this method; invalidating the cache can leave your app in an invalid state.
/// Refer to https://docs.revenuecat.com/docs/purchaserinfo#section-get-user-information for more information on
/// using the cache properly.
/// This is useful for cases where purchaser information might have been updated outside of the app, like if a
/// promotional subscription is granted through the RevenueCat dashboard.
- (void)invalidatePurchaserInfoCache;
/// Displays a sheet that enables users to redeem subscription offer codes that you generated in App Store Connect.
- (void)presentCodeRedemptionSheet SWIFT_AVAILABILITY(ios,introduced=14.0);
/// Use this function to retrieve the <code>SKPaymentDiscount</code> for a given <code>SKProduct</code>.
/// \param discount The <code>SKProductDiscount</code> to apply to the product.
///
/// \param product The <code>SKProduct</code> the user intends to purchase.
///
/// \param completion A completion block that is called when the <code>SKPaymentDiscount</code> is returned.
/// If it was not successful, there will be an <code>Error</code>.
///
- (void)paymentDiscountForProductDiscount:(SKProductDiscount * _Nonnull)discount product:(SKProduct * _Nonnull)product completion:(void (^ _Nonnull)(SKPaymentDiscount * _Nullable, NSError * _Nullable))completion SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=12.2) SWIFT_AVAILABILITY(maccatalyst,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.14.4) SWIFT_AVAILABILITY(ios,introduced=12.2);
@end

@class NSData;

@interface RCPurchases (SWIFT_EXTENSION(RevenueCat))
/// Subscriber attributes are useful for storing additional, structured information on a user.
/// Since attributes are writable using a public key they should not be used for
/// managing secure or sensitive information such as subscription status, coins, etc.
/// Key names starting with “$” are reserved names used by RevenueCat. For a full list of key
/// restrictions refer to our guide: https://docs.revenuecat.com/docs/subscriber-attributes
/// \param attributes Map of attributes by key. Set the value as an empty string to delete an attribute.
///
- (void)setAttributes:(NSDictionary<NSString *, NSString *> * _Nonnull)attributes;
/// Subscriber attribute associated with the email address for the user
/// \param email Empty String or nil will delete the subscriber attribute.
///
- (void)setEmail:(NSString * _Nullable)email;
/// Subscriber attribute associated with the phone number for the user
/// \param phoneNumber Empty String or nil will delete the subscriber attribute.
///
- (void)setPhoneNumber:(NSString * _Nullable)phoneNumber;
/// Subscriber attribute associated with the display name for the user
/// \param displayName Empty String or nil will delete the subscriber attribute.
///
- (void)setDisplayName:(NSString * _Nullable)displayName;
/// Subscriber attribute associated with the push token for the user
/// \param pushToken nil will delete the subscriber attribute.
///
- (void)setPushToken:(NSData * _Nullable)pushToken;
/// Subscriber attribute associated with the Adjust Id for the user
/// Required for the RevenueCat Adjust integration
/// \param adjustID nil will delete the subscriber attribute
///
- (void)setAdjustID:(NSString * _Nullable)adjustID;
/// Subscriber attribute associated with the Appsflyer Id for the user
/// Required for the RevenueCat Appsflyer integration
/// \param appsflyerID nil will delete the subscriber attribute
///
- (void)setAppsflyerID:(NSString * _Nullable)appsflyerID;
/// Subscriber attribute associated with the Facebook SDK Anonymous Id for the user
/// Recommended for the RevenueCat Facebook integration
/// \param fbAnonymousID nil will delete the subscriber attribute
///
- (void)setFBAnonymousID:(NSString * _Nullable)fbAnonymousID;
/// Subscriber attribute associated with the mParticle Id for the user
/// Recommended for the RevenueCat mParticle integration
/// \param mparticleID nil will delete the subscriber attribute
///
- (void)setMparticleID:(NSString * _Nullable)mparticleID;
/// Subscriber attribute associated with the OneSignal Player Id for the user
/// Required for the RevenueCat OneSignal integration
/// \param onesignalID nil will delete the subscriber attribute
///
- (void)setOnesignalID:(NSString * _Nullable)onesignalID;
/// Subscriber attribute associated with the install media source for the user
/// \param mediaSource nil will delete the subscriber attribute.
///
- (void)setMediaSource:(NSString * _Nullable)mediaSource;
/// Subscriber attribute associated with the install campaign for the user
/// \param campaign nil will delete the subscriber attribute.
///
- (void)setCampaign:(NSString * _Nullable)campaign;
/// Subscriber attribute associated with the install ad group for the user
/// \param adGroup nil will delete the subscriber attribute.
///
- (void)setAdGroup:(NSString * _Nullable)adGroup;
/// Subscriber attribute associated with the install ad for the user
/// \param installAd nil will delete the subscriber attribute.
///
- (void)setAd:(NSString * _Nullable)installAd;
/// Subscriber attribute associated with the install keyword for the user
/// \param keyword nil will delete the subscriber attribute.
///
- (void)setKeyword:(NSString * _Nullable)keyword;
/// Subscriber attribute associated with the install ad creative for the user.
/// \param creative nil will delete the subscriber attribute.
///
- (void)setCreative:(NSString * _Nullable)creative;
@end


/// Delegate for <code>Purchases</code> responsible for handling updating your app’s state in response to updated purchaser info
/// or promotional product purchases.
/// note:
/// Delegate methods can be called at any time after the <code>delegate</code> is set, not just in response to
/// <code>purchaserInfo:</code> calls. Ensure your app is capable of handling these calls at anytime if <code>delegate</code> is set.
SWIFT_PROTOCOL_NAMED("PurchasesDelegate")
@protocol RCPurchasesDelegate <NSObject>
@optional
/// Called whenever <code>Purchases</code> receives updated purchaser info. This may happen periodically
/// throughout the life of the app if new information becomes available (e.g. UIApplicationDidBecomeActive).*
/// \param purchases Related <code>Purchases</code> object
///
/// \param purchaserInfo Updated <code>PurchaserInfo</code>
///
- (void)purchases:(RCPurchases * _Nonnull)purchases didReceiveUpdatedPurchaserInfo:(RCPurchaserInfo * _Nonnull)purchaserInfo;
/// Called when a user initiates a promotional in-app purchase from the App Store.
/// If your app is able to handle a purchase at the current time, run the deferment block in this method.
/// If the app is not in a state to make a purchase: cache the defermentBlock,
/// then call the defermentBlock when the app is ready to make the promotional purchase.
/// If the purchase should never be made, you don’t need to ever call the defermentBlock and
/// <code>Purchases</code> will not proceed with promotional purchases.
/// \param product <code>SKProduct</code> the product that was selected from the app store
///
- (void)purchases:(RCPurchases * _Nonnull)purchases shouldPurchasePromoProduct:(SKProduct * _Nonnull)product defermentBlock:(void (^ _Nonnull)(void (^ _Nonnull)(SKPaymentTransaction * _Nullable, RCPurchaserInfo * _Nullable, NSError * _Nullable, BOOL)))makeDeferredPurchase;
@end



/// Enum of supported stores
typedef SWIFT_ENUM_NAMED(NSInteger, RCStore, "Store", open) {
/// For entitlements granted via Apple App Store.
  RCAppStore SWIFT_COMPILE_NAME("appStore") = 0,
/// For entitlements granted via Apple Mac App Store.
  RCMacAppStore SWIFT_COMPILE_NAME("macAppStore") = 1,
/// For entitlements granted via Google Play Store.
  RCPlayStore SWIFT_COMPILE_NAME("playStore") = 2,
/// For entitlements granted via Stripe.
  RCStripe SWIFT_COMPILE_NAME("stripe") = 3,
/// For entitlements granted via a promo in RevenueCat.
  RCPromotional SWIFT_COMPILE_NAME("promotional") = 4,
/// For entitlements granted via an unknown store.
  RCUnknownStore SWIFT_COMPILE_NAME("unknownStore") = 5,
};


SWIFT_CLASS("_TtC10RevenueCat22StoreKitRequestFetcher")
@interface StoreKitRequestFetcher : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@interface StoreKitRequestFetcher (SWIFT_EXTENSION(RevenueCat)) <SKRequestDelegate>
- (void)requestDidFinish:(SKRequest * _Nonnull)request;
- (void)request:(SKRequest * _Nonnull)request didFailWithError:(NSError * _Nonnull)error;
@end


SWIFT_CLASS("_TtC10RevenueCat15StoreKitWrapper")
@interface StoreKitWrapper : NSObject <SKPaymentTransactionObserver>
- (nonnull instancetype)init;
@end

@class SKPaymentQueue;
@class SKPayment;

@interface StoreKitWrapper (SWIFT_EXTENSION(RevenueCat)) <SKPaymentQueueDelegate>
- (void)paymentQueue:(SKPaymentQueue * _Nonnull)queue updatedTransactions:(NSArray<SKPaymentTransaction *> * _Nonnull)transactions;
- (void)paymentQueue:(SKPaymentQueue * _Nonnull)queue removedTransactions:(NSArray<SKPaymentTransaction *> * _Nonnull)transactions;
- (BOOL)paymentQueue:(SKPaymentQueue * _Nonnull)queue shouldAddStorePayment:(SKPayment * _Nonnull)payment forProduct:(SKProduct * _Nonnull)product SWIFT_WARN_UNUSED_RESULT SWIFT_AVAILABILITY(watchos,unavailable) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(maccatalyst,introduced=14.0) SWIFT_AVAILABILITY(macos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0);
- (void)paymentQueue:(SKPaymentQueue * _Nonnull)queue didRevokeEntitlementsForProductIdentifiers:(NSArray<NSString *> * _Nonnull)productIdentifiers SWIFT_AVAILABILITY(watchos,introduced=7.0) SWIFT_AVAILABILITY(tvos,introduced=14.0) SWIFT_AVAILABILITY(macos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=14.0);
@end


SWIFT_CLASS("_TtC10RevenueCat20TrackingManagerProxy")
@interface TrackingManagerProxy : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull authorizationStatusPropertyName;
- (NSInteger)trackingAuthorizationStatus SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSDateFormatter;

SWIFT_CLASS_NAMED("Transaction")
@interface RCTransaction : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull revenueCatId;
@property (nonatomic, readonly, copy) NSString * _Nonnull productId;
@property (nonatomic, readonly, copy) NSDate * _Nonnull purchaseDate;
- (nonnull instancetype)initWithTransactionId:(NSString * _Nonnull)transactionId productId:(NSString * _Nonnull)productId purchaseDate:(NSDate * _Nonnull)purchaseDate OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWith:(NSDictionary<NSString *, id> * _Nonnull)serverResponse productId:(NSString * _Nonnull)productId dateFormatter:(NSDateFormatter * _Nonnull)dateFormatter OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif
