// Generated by Apple Swift version 5.8.1 (swiftlang-5.8.0.124.5 clang-1403.0.22.11.100)
#ifndef REVENUECAT_SWIFT_H
#define REVENUECAT_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
@import StoreKit;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="RevenueCat",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)

/// This class is responsible for all explicit attribution APIs as well as subscriber attributes that RevenueCat offers.
/// The attributes are additional structured information on a user. Since attributes are writable using a public key
/// they should not be used for managing secure or sensitive information such as subscription status, coins, etc.
/// Key names starting with “$” are reserved names used by RevenueCat. For a full list of key restrictions refer
/// <a href="https://docs.revenuecat.com/docs/subscriber-attributes">to our guide</a>
SWIFT_CLASS_NAMED("Attribution")
@interface RCAttribution : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




SWIFT_AVAILABILITY(watchos,unavailable) SWIFT_AVAILABILITY(tvos,unavailable) SWIFT_AVAILABILITY(maccatalyst,introduced=14.3) SWIFT_AVAILABILITY(macos,introduced=11.1) SWIFT_AVAILABILITY(ios,introduced=14.3)
@interface RCAttribution (SWIFT_EXTENSION(RevenueCat))
/// Enable automatic collection of AdServices attribution token.
- (void)enableAdServicesAttributionTokenCollection;
@end


@class NSString;
@class NSData;

@interface RCAttribution (SWIFT_EXTENSION(RevenueCat))
/// Automatically collect subscriber attributes associated with the device identifiers
/// <ul>
///   <li>
///     <code>$idfa</code>
///   </li>
///   <li>
///     <code>$idfv</code>
///   </li>
///   <li>
///     <code>$ip</code>
///   </li>
/// </ul>
- (void)collectDeviceIdentifiers;
/// Subscriber attributes are useful for storing additional, structured information on a user.
/// Since attributes are writable using a public key they should not be used for
/// managing secure or sensitive information such as subscription status, coins, etc.
/// Key names starting with “$” are reserved names used by RevenueCat. For a full list of key
/// restrictions refer <a href="https://docs.revenuecat.com/docs/subscriber-attributes">to our guide</a>
/// \param attributes Map of attributes by key. Set the value as an empty string to delete an attribute.
///
- (void)setAttributes:(NSDictionary<NSString *, NSString *> * _Nonnull)attributes;
/// Subscriber attribute associated with the email address for the user.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/subscriber-attributes">Subscriber attributes</a>
///   </li>
/// </ul>
/// \param email Empty String or <code>nil</code> will delete the subscriber attribute.
///
- (void)setEmail:(NSString * _Nullable)email;
/// Subscriber attribute associated with the phone number for the user.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/subscriber-attributes">Subscriber attributes</a>
///   </li>
/// </ul>
/// \param phoneNumber Empty String or <code>nil</code> will delete the subscriber attribute.
///
- (void)setPhoneNumber:(NSString * _Nullable)phoneNumber;
/// Subscriber attribute associated with the display name for the user.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/subscriber-attributes">Subscriber attributes</a>
///   </li>
/// </ul>
/// \param displayName Empty String or <code>nil</code> will delete the subscriber attribute.
///
- (void)setDisplayName:(NSString * _Nullable)displayName;
/// Subscriber attribute associated with the push token for the user.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/subscriber-attributes">Subscriber attributes</a>
///   </li>
/// </ul>
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>Attribution/setPushTokenString(_:)</code>
///   </li>
/// </ul>
/// \param pushToken <code>nil</code> will delete the subscriber attribute.
///
- (void)setPushToken:(NSData * _Nullable)pushToken;
/// Subscriber attribute associated with the push token for the user.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/subscriber-attributes">Subscriber attributes</a>
///   </li>
/// </ul>
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>Attribution/setPushToken(_:)</code>
///   </li>
/// </ul>
/// \param pushToken <code>nil</code> will delete the subscriber attribute.
///
- (void)setPushTokenString:(NSString * _Nullable)pushToken;
/// Subscriber attribute associated with the Adjust Id for the user.
/// Required for the RevenueCat Adjust integration.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/adjust">Adjust RevenueCat Integration</a>
///     *- Parameter adjustID: Empty String or <code>nil</code> will delete the subscriber attribute.
///   </li>
/// </ul>
- (void)setAdjustID:(NSString * _Nullable)adjustID;
/// Subscriber attribute associated with the Appsflyer Id for the user.
/// Required for the RevenueCat Appsflyer integration.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/appsflyer">AppsFlyer RevenueCat Integration</a>
///     *- Parameter appsflyerID: Empty String or <code>nil</code> will delete the subscriber attribute.
///   </li>
/// </ul>
- (void)setAppsflyerID:(NSString * _Nullable)appsflyerID;
/// Subscriber attribute associated with the Facebook SDK Anonymous Id for the user.
/// Recommended for the RevenueCat Facebook integration.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/facebook-ads">Facebook Ads RevenueCat Integration</a>
///     *- Parameter fbAnonymousID: Empty String or <code>nil</code> will delete the subscriber attribute.
///   </li>
/// </ul>
- (void)setFBAnonymousID:(NSString * _Nullable)fbAnonymousID;
/// Subscriber attribute associated with the mParticle Id for the user.
/// Recommended for the RevenueCat mParticle integration.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/mparticle">mParticle RevenueCat Integration</a>
///     *- Parameter mparticleID: Empty String or <code>nil</code> will delete the subscriber attribute.
///   </li>
/// </ul>
- (void)setMparticleID:(NSString * _Nullable)mparticleID;
/// Subscriber attribute associated with the OneSignal Player ID for the user.
/// Required for the RevenueCat OneSignal integration. Deprecated for OneSignal versions above v9.0.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/onesignal">OneSignal RevenueCat Integration</a>
///     *- Parameter onesignalID: Empty String or <code>nil</code> will delete the subscriber attribute.
///   </li>
/// </ul>
- (void)setOnesignalID:(NSString * _Nullable)onesignalID;
/// Subscriber attribute associated with the OneSignal User ID for the user.
/// Required for the RevenueCat OneSignal integration with versions v11.0 and above.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/onesignal">OneSignal RevenueCat Integration</a>
///     *- Parameter onesignalUserID: Empty String or <code>nil</code> will delete the subscriber attribute.
///   </li>
/// </ul>
- (void)setOnesignalUserID:(NSString * _Nullable)onesignalUserID;
/// Subscriber attribute associated with the Airship Channel ID for the user.
/// Required for the RevenueCat Airship integration.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/airship">AirShip RevenueCat Integration</a>
///     *- Parameter airshipChannelID: Empty String or <code>nil</code> will delete the subscriber attribute.
///   </li>
/// </ul>
- (void)setAirshipChannelID:(NSString * _Nullable)airshipChannelID;
/// Subscriber attribute associated with the CleverTap ID for the user.
/// Required for the RevenueCat CleverTap integration.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/clevertap">CleverTap RevenueCat Integration</a>
///     *- Parameter cleverTapID: Empty String or <code>nil</code> will delete the subscriber attribute.
///   </li>
/// </ul>
- (void)setCleverTapID:(NSString * _Nullable)cleverTapID;
/// Subscriber attribute associated with the Mixpanel Distinct ID for the user.
/// Optional for the RevenueCat Mixpanel integration.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/mixpanel">Mixpanel RevenueCat Integration</a>
///     *- Parameter mixpanelDistinctID: Empty String or <code>nil</code> will delete the subscriber attribute.
///   </li>
/// </ul>
- (void)setMixpanelDistinctID:(NSString * _Nullable)mixpanelDistinctID;
/// Subscriber attribute associated with the Firebase App Instance ID for the user.
/// Required for the RevenueCat Firebase integration.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/firebase-integration">Firebase RevenueCat Integration</a>
///     *- Parameter firebaseAppInstanceID: Empty String or <code>nil</code> will delete the subscriber attribute.
///   </li>
/// </ul>
- (void)setFirebaseAppInstanceID:(NSString * _Nullable)firebaseAppInstanceID;
/// Subscriber attribute associated with the install media source for the user.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/subscriber-attributes">Subscriber attributes</a>
///   </li>
/// </ul>
/// \param mediaSource Empty String or <code>nil</code> will delete the subscriber attribute.
///
- (void)setMediaSource:(NSString * _Nullable)mediaSource;
/// Subscriber attribute associated with the install campaign for the user.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/subscriber-attributes">Subscriber attributes</a>
///   </li>
/// </ul>
/// \param campaign Empty String or <code>nil</code> will delete the subscriber attribute.
///
- (void)setCampaign:(NSString * _Nullable)campaign;
/// Subscriber attribute associated with the install ad group for the user
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/subscriber-attributes">Subscriber attributes</a>
///   </li>
/// </ul>
/// \param adGroup Empty String or <code>nil</code> will delete the subscriber attribute.
///
- (void)setAdGroup:(NSString * _Nullable)adGroup;
/// Subscriber attribute associated with the install ad for the user
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/subscriber-attributes">Subscriber attributes</a>
///   </li>
/// </ul>
/// \param installAd Empty String or <code>nil</code> will delete the subscriber attribute.
///
- (void)setAd:(NSString * _Nullable)installAd;
/// Subscriber attribute associated with the install keyword for the user
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/subscriber-attributes">Subscriber attributes</a>
///   </li>
/// </ul>
/// \param keyword Empty String or <code>nil</code> will delete the subscriber attribute.
///
- (void)setKeyword:(NSString * _Nullable)keyword;
/// Subscriber attribute associated with the install ad creative for the user.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/subscriber-attributes">Subscriber attributes</a>
///   </li>
/// </ul>
/// \param creative Empty String or <code>nil</code> will delete the subscriber attribute.
///
- (void)setCreative:(NSString * _Nullable)creative;
@end

/// Enum of supported attribution networks
typedef SWIFT_ENUM_NAMED(NSInteger, RCAttributionNetwork, "AttributionNetwork", open) {
/// Apple’s search ads
  RCAttributionNetworkAppleSearchAds = 0,
/// Adjust https://www.adjust.com/
  RCAttributionNetworkAdjust = 1,
/// AppsFlyer https://www.appsflyer.com/
  RCAttributionNetworkAppsFlyer = 2,
/// Branch https://www.branch.io/
  RCAttributionNetworkBranch = 3,
/// Tenjin https://www.tenjin.io/
  RCAttributionNetworkTenjin = 4,
/// Facebook https://developers.facebook.com/
  RCAttributionNetworkFacebook = 5,
/// mParticle https://www.mparticle.com/
  RCAttributionNetworkMParticle = 6,
/// AdServices token
  RCAttributionNetworkAdServices = 7,
};

@class NSUserDefaults;
@class RCDangerousSettings;
@class RCPlatformInfo;
enum RCEntitlementVerificationMode : NSInteger;
@class RCConfiguration;

/// The Builder for <code>Configuration</code>.
SWIFT_CLASS_NAMED("Builder")
@interface RCConfigurationBuilder : NSObject
/// Create a new builder with your API key.
/// \param apiKey The API Key generated for your app from https://app.revenuecat.com/
///
- (nonnull instancetype)initWithAPIKey:(NSString * _Nonnull)apiKey OBJC_DESIGNATED_INITIALIZER;
/// Update your API key.
- (RCConfigurationBuilder * _Nonnull)withApiKey:(NSString * _Nonnull)apiKey SWIFT_WARN_UNUSED_RESULT;
/// Set an <code>appUserID</code>.
/// note:
/// Best practice is to use a salted hash of your unique app user ids.
/// important:
/// Set this property if you have your own user identifiers that you manage.
/// \param appUserID The unique app user id for this user. This user id will allow users to share their
/// purchases and subscriptions across devices. Pass <code>nil</code> or an empty string if you want <code>Purchases</code>
/// to generate this for you.
///
- (RCConfigurationBuilder * _Nonnull)withAppUserID:(NSString * _Nullable)appUserID SWIFT_WARN_UNUSED_RESULT;
/// Set <code>observerMode</code>.
/// warning:
/// This assumes your IAP implementation uses StoreKit 1.
/// Observer mode is not compatible with StoreKit 2.
/// \param observerMode Set this to <code>true</code> if you have your own IAP implementation and want to use only
/// RevenueCat’s backend. Default is <code>false</code>.
///
- (RCConfigurationBuilder * _Nonnull)withObserverMode:(BOOL)observerMode SWIFT_WARN_UNUSED_RESULT;
/// Set <code>userDefaults</code>.
/// \param userDefaults Custom <code>UserDefaults</code> to use
///
- (RCConfigurationBuilder * _Nonnull)withUserDefaults:(NSUserDefaults * _Nonnull)userDefaults SWIFT_WARN_UNUSED_RESULT;
/// Set <code>dangerousSettings</code>.
/// \param dangerousSettings Only use if suggested by RevenueCat support team.
///
- (RCConfigurationBuilder * _Nonnull)withDangerousSettings:(RCDangerousSettings * _Nonnull)dangerousSettings SWIFT_WARN_UNUSED_RESULT;
/// Set <code>networkTimeout</code>.
- (RCConfigurationBuilder * _Nonnull)withNetworkTimeout:(NSTimeInterval)networkTimeout SWIFT_WARN_UNUSED_RESULT;
/// Set <code>storeKit1Timeout</code>.
- (RCConfigurationBuilder * _Nonnull)withStoreKit1Timeout:(NSTimeInterval)storeKit1Timeout SWIFT_WARN_UNUSED_RESULT;
/// Set <code>platformInfo</code>.
- (RCConfigurationBuilder * _Nonnull)withPlatformInfo:(RCPlatformInfo * _Nonnull)platformInfo SWIFT_WARN_UNUSED_RESULT;
/// Set <code>showStoreMessagesAutomatically</code>. Enabled by default.
/// If enabled, if the user has billing issues, has yet to accept a price increase consent or
/// there are other messages from StoreKit, they will be displayed automatically when the app is initialized.
/// If you want to disable this behavior so that you can customize when these messages are shown, make sure
/// you configure the SDK as early as possible in the app’s lifetime, otherwise messages will be displayed
/// automatically.
/// Then use the <code>Purchases/showStoreMessages(for:)</code> method to display the messages.
/// More information:  https://rev.cat/storekit-message
/// important:
/// Set this property only if you’re using Swift. If you’re using ObjC, you won’t be able to call
/// the related methods
- (RCConfigurationBuilder * _Nonnull)withShowStoreMessagesAutomatically:(BOOL)showStoreMessagesAutomatically SWIFT_WARN_UNUSED_RESULT;
/// Set <code>Configuration/EntitlementVerificationMode</code>.
/// Defaults to <code>Configuration/EntitlementVerificationMode/disabled</code>.
/// The result of the verification can be obtained from <code>EntitlementInfos/verification</code> or
/// <code>EntitlementInfo/verification</code>.
/// note:
/// This feature requires iOS 13+.
/// warning:
/// When changing from <code>Configuration/EntitlementVerificationMode/disabled</code>
/// to <code>Configuration/EntitlementVerificationMode/informational</code>
/// the SDK will clear the <code>CustomerInfo</code> cache.
/// This means that users will need to connect to the internet to get back their entitlements.
/// <h3>Related Articles</h3>
/// <ul>
///   <li>
///     <a href="https://rev.cat/trusted-entitlements">Documentation</a>
///   </li>
/// </ul>
/// <h3>Related Symbols</h3>
/// <ul>
///   <li>
///     <code>Configuration/EntitlementVerificationMode</code>
///   </li>
///   <li>
///     <code>VerificationResult</code>
///   </li>
/// </ul>
- (RCConfigurationBuilder * _Nonnull)withEntitlementVerificationMode:(enum RCEntitlementVerificationMode)mode SWIFT_WARN_UNUSED_RESULT SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
/// Generate a <code>Configuration</code> object given the values configured by this builder.
- (RCConfiguration * _Nonnull)build SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@interface RCConfigurationBuilder (SWIFT_EXTENSION(RevenueCat))
/// Set <code>storeKit2Setting</code>. If <code>true</code>, the SDK will use StoreKit 2 APIs internally. If disabled, it will use StoreKit 1 APIs instead.
/// important:
/// This configuration flag has been deprecated, and will be replaced by automatic remote configuration in the future.
/// However, apps using it should work correctly.
/// \param usesStoreKit2IfAvailable enable StoreKit 2 on devices that support it.
/// Defaults to  <code>false</code>.
///
- (RCConfigurationBuilder * _Nonnull)withUsesStoreKit2IfAvailable:(BOOL)usesStoreKit2IfAvailable SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("\n    RevenueCat currently uses StoreKit 1 for purchases, as its stability in production scenarios has\n    proven to be more performant than StoreKit 2.\n\n    We're collecting more data on the best approach, but StoreKit 1 vs StoreKit 2 is an implementation detail\n    that you shouldn't need to care about.\n\n    Simply remove this method call to let RevenueCat decide for you which StoreKit implementation to use.\n    ");
@end

/// Specifies the behavior for a caching API.
typedef SWIFT_ENUM_NAMED(NSInteger, RCCacheFetchPolicy, "CacheFetchPolicy", open) {
/// Returns values from the cache, or throws an error if not available.
  RCCacheFetchPolicyFromCacheOnly = 0,
/// Always fetch the most up-to-date data.
  RCCacheFetchPolicyFetchCurrent = 1,
/// Returns the cached data if available and not stale, or fetches up-to-date data.
/// warning:
/// if the cached data is stale, and fetching up-to-date data fails (if offline, for example)
/// an error will be returned instead of the outdated cached data.
  RCCacheFetchPolicyNotStaleCachedOrFetched = 2,
/// Default behavior: returns the cached data if available (even if stale), or fetches up-to-date data.
  RCCacheFetchPolicyCachedOrFetched = 3,
};


SWIFT_CLASS("_TtC10RevenueCat16NetworkOperation")
@interface NetworkOperation : NSOperation
@property (nonatomic, readonly, getter=isExecuting) BOOL executing;
@property (nonatomic, readonly, getter=isFinished) BOOL finished;
@property (nonatomic, readonly, getter=isCancelled) BOOL cancelled;
- (void)main;
- (void)cancel;
@property (nonatomic, readonly, getter=isAsynchronous) BOOL asynchronous;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC10RevenueCat25CacheableNetworkOperation")
@interface CacheableNetworkOperation : NetworkOperation
@end


/// <code>Configuration</code> can be used when configuring the <code>Purchases</code> instance. It is not required to be used, but
/// highly recommended. This class follows a builder pattern.
/// To configure your <code>Purchases</code> instance using this object, follow these steps.
/// <em>Steps:</em>
/// <ol>
///   <li>
///     Call <code>Configuration/builder(withAPIKey:)</code> To obtain a <code>Configuration/Builder</code> object.
///   </li>
///   <li>
///     Set this builder’s properties using the “<code>with(</code>” functions.
///   </li>
///   <li>
///     Call <code>Configuration/Builder/build()</code> to obtain the <code>Configuration</code> object.
///   </li>
///   <li>
///     Pass the <code>Configuration</code> object into <code>Purchases/configure(with:)-6oipy</code>.
///   </li>
/// </ol>
/// \code
/// let configuration = Configuration.Builder(withAPIKey: "MyKey")
///                                  .with(appUserID: "SomeAppUserID")
///                                  .with(userDefaults: myUserDefaults)
///                                  .with(networkTimeout: 15)
///                                  .with(storeKit1Timeout: 15)
///                                  .build()
///  Purchases.configure(with: configuration)
///
/// \endcode
SWIFT_CLASS_NAMED("Configuration")
@interface RCConfiguration : NSObject
/// Factory method for the <code>Configuration/Builder</code> object that is required to create a <code>Configuration</code>
+ (RCConfigurationBuilder * _Nonnull)builderWithAPIKey:(NSString * _Nonnull)apiKey SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@interface RCConfiguration (SWIFT_EXTENSION(RevenueCat))
@end

/// Defines how strict <code>EntitlementInfo</code> verification ought to be.
/// <h3>Related Articles</h3>
/// <ul>
///   <li>
///     <a href="https://rev.cat/trusted-entitlements">Documentation</a>
///   </li>
/// </ul>
/// <h3>Related Symbols</h3>
/// <ul>
///   <li>
///     <code>VerificationResult</code>
///   </li>
///   <li>
///     <code>Configuration/Builder/with(entitlementVerificationMode:)</code>
///   </li>
///   <li>
///     <code>EntitlementInfos/verification</code>
///   </li>
/// </ul>
typedef SWIFT_ENUM_NAMED(NSInteger, RCEntitlementVerificationMode, "EntitlementVerificationMode", open) {
/// The SDK will not perform any entitlement verification.
  RCEntitlementVerificationModeDisabled = 0,
/// Enable entitlement verification.
/// If verification fails, this will be indicated with <code>VerificationResult/failed</code>
/// but parsing will not fail.
/// This can be useful if you want to handle validation failures but still grant access.
  RCEntitlementVerificationModeInformational = 1,
/// Enable entitlement verification.
/// If verification fails when fetching <code>CustomerInfo</code> and/or <code>EntitlementInfos</code>
/// <code>ErrorCode/signatureVerificationFailed</code> will be thrown.
  RCEntitlementVerificationModeEnforced = 2,
};



@class RCEntitlementInfos;
@class NSDate;
@class RCNonSubscriptionTransaction;
@class NSURL;

/// A container for the most recent customer info returned from <code>Purchases</code>.
/// These objects are non-mutable and do not update automatically.
SWIFT_CLASS_NAMED("CustomerInfo")
@interface RCCustomerInfo : NSObject
/// <code>EntitlementInfos</code> attached to this customer info.
@property (nonatomic, readonly, strong) RCEntitlementInfos * _Nonnull entitlements;
/// All <em>subscription</em> product identifiers with expiration dates in the future.
@property (nonatomic, readonly, copy) NSSet<NSString *> * _Nonnull activeSubscriptions;
/// All product identifiers purchases by the user regardless of expiration.
@property (nonatomic, readonly, copy) NSSet<NSString *> * _Nonnull allPurchasedProductIdentifiers;
/// Returns the latest expiration date of all products, nil if there are none.
@property (nonatomic, readonly, copy) NSDate * _Nullable latestExpirationDate;
/// Returns all the non-subscription purchases a user has made.
/// The purchases are ordered by purchase date in ascending order.
/// This includes:
/// <ul>
///   <li>
///     Consumables
///   </li>
///   <li>
///     Non-consumables
///   </li>
///   <li>
///     Non-renewing subscriptions
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSArray<RCNonSubscriptionTransaction *> * _Nonnull nonSubscriptions;
/// Returns the fetch date of this CustomerInfo.
@property (nonatomic, readonly, copy) NSDate * _Nonnull requestDate;
/// The date this user was first seen in RevenueCat.
@property (nonatomic, readonly, copy) NSDate * _Nonnull firstSeen;
/// The original App User Id recorded for this user.
@property (nonatomic, readonly, copy) NSString * _Nonnull originalAppUserId;
/// URL to manage the active subscription of the user.
/// <ul>
///   <li>
///     If this user has an active iOS subscription, this will point to the App Store.
///   </li>
///   <li>
///     If the user has an active Play Store subscription it will point there.
///   </li>
///   <li>
///     If there are no active subscriptions it will be null.
///   </li>
///   <li>
///     If there are multiple for different platforms, it will point to the App Store.
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSURL * _Nullable managementURL;
/// Returns the purchase date for the version of the application when the user bought the app.
/// Use this for grandfathering users when migrating to subscriptions.
/// note:
/// This can be <code>nil</code>, see <code>Purchases/restorePurchases(completion:)</code>
@property (nonatomic, readonly, copy) NSDate * _Nullable originalPurchaseDate;
/// The build number (in iOS) or the marketing version (in macOS) for the version of the application when the user
/// bought the app. This corresponds to the value of CFBundleVersion (in iOS) or CFBundleShortVersionString
/// (in macOS) in the Info.plist file when the purchase was originally made. Use this for grandfathering users
/// when migrating to subscriptions.
/// note:
/// This can be nil, see -<code>Purchases.restorePurchases(completion:)</code>
@property (nonatomic, readonly, copy) NSString * _Nullable originalApplicationVersion;
/// Get the expiration date for a given product identifier. You should use Entitlements though!
/// \param productIdentifier Product identifier for product
///
///
/// returns:
/// The expiration date for <code>productIdentifier</code>, <code>nil</code> if product never purchased
- (NSDate * _Nullable)expirationDateForProductIdentifier:(NSString * _Nonnull)productIdentifier SWIFT_WARN_UNUSED_RESULT;
/// Get the latest purchase or renewal date for a given product identifier. You should use Entitlements though!
/// \param productIdentifier Product identifier for subscription product
///
///
/// returns:
/// The purchase date for <code>productIdentifier</code>, <code>nil</code> if product never purchased
- (NSDate * _Nullable)purchaseDateForProductIdentifier:(NSString * _Nonnull)productIdentifier SWIFT_WARN_UNUSED_RESULT;
/// Get the expiration date for a given entitlement.
/// \param entitlementIdentifier The ID of the entitlement
///
///
/// returns:
/// The expiration date for the passed in <code>entitlementIdentifier</code>, or <code>nil</code>
- (NSDate * _Nullable)expirationDateForEntitlement:(NSString * _Nonnull)entitlementIdentifier SWIFT_WARN_UNUSED_RESULT;
/// Get the latest purchase or renewal date for a given entitlement identifier.
/// \param entitlementIdentifier Entitlement identifier for entitlement
///
///
/// returns:
/// The purchase date for <code>entitlementIdentifier</code>, <code>nil</code> if product never purchased
- (NSDate * _Nullable)purchaseDateForEntitlement:(NSString * _Nonnull)entitlementIdentifier SWIFT_WARN_UNUSED_RESULT;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end













@interface RCCustomerInfo (SWIFT_EXTENSION(RevenueCat))
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nonnull rawData;
@end

@class RCStoreTransaction;

@interface RCCustomerInfo (SWIFT_EXTENSION(RevenueCat))
/// Returns all product IDs of the non-subscription purchases a user has made.
@property (nonatomic, readonly, copy) NSSet<NSString *> * _Nonnull nonConsumablePurchases SWIFT_DEPRECATED_MSG("use nonSubscriptionTransactions");
/// Returns all the non-subscription purchases a user has made.
/// The purchases are ordered by purchase date in ascending order.
@property (nonatomic, readonly, copy) NSArray<RCStoreTransaction *> * _Nonnull nonSubscriptionTransactions SWIFT_DEPRECATED_MSG("", "nonSubscriptions");
@end




/// Only use a Dangerous Setting if suggested by RevenueCat support team.
SWIFT_CLASS_NAMED("DangerousSettings")
@interface RCDangerousSettings : NSObject
/// Disable or enable subscribing to the StoreKit queue. If this is disabled, RevenueCat won’t observe
/// the StoreKit queue, and it will not sync any purchase automatically.
/// Call syncPurchases whenever a new transaction is completed so the receipt is sent to RevenueCat’s backend.
/// Consumables disappear from the receipt after the transaction is finished, so make sure purchases are
/// synced before finishing any consumable transaction, otherwise RevenueCat won’t register the purchase.
/// Auto syncing of purchases is enabled by default.
@property (nonatomic, readonly) BOOL autoSyncPurchases;
/// A property meant for apps that do their own entitlements computation, separated from RevenueCat.
/// It:
/// important:
/// This is a dangerous setting and should only be used if you intend to do your own entitlement
/// granting, separate from RevenueCat.
/// <ul>
///   <li>
///     disables automatic CustomerInfo cache updates
///   </li>
///   <li>
///     disables <code>Purchases/logOut()</code> and <code>Purchases/logOut(completion:)</code>
///   </li>
///   <li>
///     disallows configuration of the SDK without an appUserID
///   </li>
///   <li>
///     disables automatic firing of the PurchasesDelegate’s CustomerInfo listener when setting the delegate.
///     It will only be called when the SDK posts a receipt or after customerInfo on device changes.
///   </li>
/// </ul>
@property (nonatomic, readonly) BOOL customEntitlementComputation;
- (nonnull instancetype)init;
/// Only use a Dangerous Setting if suggested by RevenueCat support team.
/// \param autoSyncPurchases Disable or enable subscribing to the StoreKit queue.
/// If this is disabled, RevenueCat won’t observe the StoreKit queue, and it will not sync any purchase
/// automatically.
///
- (nonnull instancetype)initWithAutoSyncPurchases:(BOOL)autoSyncPurchases;
/// note:
/// this is <code>internal</code> only so the only <code>public</code> way to enable <code>customEntitlementComputation</code>
/// is through <code>Purchases/configureInCustomEntitlementsComputationMode(apiKey:appUserID:)</code>.
- (nonnull instancetype)initWithAutoSyncPurchases:(BOOL)autoSyncPurchases customEntitlementComputation:(BOOL)customEntitlementComputation;
@end



enum RCPeriodType : NSInteger;
enum RCStore : NSInteger;
enum RCPurchaseOwnershipType : NSInteger;
enum RCVerificationResult : NSInteger;

/// The EntitlementInfo object gives you access to all of the information about the status of a user entitlement.
SWIFT_CLASS_NAMED("EntitlementInfo")
@interface RCEntitlementInfo : NSObject
/// The entitlement identifier configured in the RevenueCat dashboard
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
/// True if the user has access to this entitlement
/// warning:
/// this is equivalent to <code>isActiveInAnyEnvironment</code>
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>isActiveInCurrentEnvironment</code>
///   </li>
/// </ul>
@property (nonatomic, readonly) BOOL isActive;
/// True if the underlying subscription is set to renew at the end of
/// the billing period (<code>expirationDate</code>).
@property (nonatomic, readonly) BOOL willRenew;
/// The last period type this entitlement was in
/// Either: <code>PeriodType/normal</code>, <code>PeriodType/intro</code>, <code>PeriodType/trial</code>
@property (nonatomic, readonly) enum RCPeriodType periodType;
/// The latest purchase or renewal date for the entitlement.
@property (nonatomic, readonly, copy) NSDate * _Nullable latestPurchaseDate;
/// The first date this entitlement was purchased
@property (nonatomic, readonly, copy) NSDate * _Nullable originalPurchaseDate;
/// The expiration date for the entitlement, can be <code>nil</code> for lifetime access.
/// If the <code>periodType</code> is <code>PeriodType/trial</code>, this is the trial expiration date.
@property (nonatomic, readonly, copy) NSDate * _Nullable expirationDate;
/// The store where this entitlement was unlocked from either: <code>Store/appStore</code>, <code>Store/macAppStore</code>,
/// <code>Store/playStore</code>, <code>Store/stripe</code>, <code>Store/promotional</code>, or <code>Store/unknownStore</code>.
@property (nonatomic, readonly) enum RCStore store;
/// The product identifier that unlocked this entitlement
@property (nonatomic, readonly, copy) NSString * _Nonnull productIdentifier;
/// The product plan identifier that unlocked this entitlement (for a Google Play subscription purchase)
@property (nonatomic, readonly, copy) NSString * _Nullable productPlanIdentifier;
/// False if this entitlement is unlocked via a production purchase
@property (nonatomic, readonly) BOOL isSandbox;
/// The date an unsubscribe was detected. Can be <code>nil</code>.
/// note:
/// Entitlement may still be active even if user has unsubscribed. Check the <code>isActive</code> property.
@property (nonatomic, readonly, copy) NSDate * _Nullable unsubscribeDetectedAt;
/// The date a billing issue was detected. Can be <code>nil</code> if there is no
/// billing issue or an issue has been resolved.
/// note:
/// Entitlement may still be active even if there is a billing issue.
/// Check the <code>isActive</code> property.
@property (nonatomic, readonly, copy) NSDate * _Nullable billingIssueDetectedAt;
/// Use this property to determine whether a purchase was made by the current user
/// or shared to them by a family member. This can be useful for onboarding users who have had
/// an entitlement shared with them, but might not be entirely aware of the benefits they now have.
@property (nonatomic, readonly) enum RCPurchaseOwnershipType ownershipType;
/// Whether this entitlement was verified.
/// <h3>Related Articles</h3>
/// <ul>
///   <li>
///     <a href="https://rev.cat/trusted-entitlements">Documentation</a>
///   </li>
/// </ul>
/// <h3>Related Symbols</h3>
/// <ul>
///   <li>
///     <code>VerificationResult</code>
///   </li>
/// </ul>
@property (nonatomic, readonly) enum RCVerificationResult verification SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nonnull rawData;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end







@interface RCEntitlementInfo (SWIFT_EXTENSION(RevenueCat))
/// True if the user has access to this entitlement,
/// note:
/// When queried from the sandbox environment, it only returns true if active in sandbox.
/// When queried from production, this only returns true if active in production.
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>isActiveInAnyEnvironment</code>
///   </li>
/// </ul>
@property (nonatomic, readonly) BOOL isActiveInCurrentEnvironment;
/// True if the user has access to this entitlement in any environment.
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>isActiveInCurrentEnvironment</code>
///   </li>
/// </ul>
@property (nonatomic, readonly) BOOL isActiveInAnyEnvironment;
@end


/// This class contains all the entitlements associated to the user.
SWIFT_CLASS_NAMED("EntitlementInfos")
@interface RCEntitlementInfos : NSObject
/// Dictionary of all EntitlementInfo (<code>EntitlementInfo</code>) objects (active and inactive) keyed by entitlement
/// identifier. This dictionary can also be accessed by using an index subscript on <code>EntitlementInfos</code>, e.g.
/// <code>entitlementInfos["pro_entitlement_id"]</code>.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, RCEntitlementInfo *> * _Nonnull all;
- (RCEntitlementInfo * _Nullable)objectForKeyedSubscript:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
/// Whether these entitlements were verified.
/// <h3>Related Articles</h3>
/// <ul>
///   <li>
///     <a href="https://rev.cat/trusted-entitlements">Documentation</a>
///   </li>
/// </ul>
/// <h3>Related Symbols</h3>
/// <ul>
///   <li>
///     <code>VerificationResult</code>
///   </li>
/// </ul>
@property (nonatomic, readonly) enum RCVerificationResult verification SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




@interface RCEntitlementInfos (SWIFT_EXTENSION(RevenueCat))
/// Dictionary of active <code>EntitlementInfo</code> objects keyed by their identifiers.
/// warning:
/// this is equivalent to <code>activeInAnyEnvironment</code>
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>activeInCurrentEnvironment</code>
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSDictionary<NSString *, RCEntitlementInfo *> * _Nonnull active;
/// Dictionary of active <code>EntitlementInfo</code> objects keyed by their identifiers.
/// note:
/// When queried from the sandbox environment, it only returns entitlements active in sandbox.
/// When queried from production, this only returns entitlements active in production.
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>activeInAnyEnvironment</code>
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSDictionary<NSString *, RCEntitlementInfo *> * _Nonnull activeInCurrentEnvironment;
/// Dictionary of active <code>EntitlementInfo</code> objects keyed by their identifiers.
/// note:
/// these can be active on any environment.
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>activeInCurrentEnvironment</code>
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSDictionary<NSString *, RCEntitlementInfo *> * _Nonnull activeInAnyEnvironment;
@end

/// Error codes used by the Purchases SDK
typedef SWIFT_ENUM_NAMED(NSInteger, RCPurchasesErrorCode, "ErrorCode", open) {
  RCUnknownError SWIFT_COMPILE_NAME("unknownError") = 0,
  RCPurchaseCancelledError SWIFT_COMPILE_NAME("purchaseCancelledError") = 1,
  RCStoreProblemError SWIFT_COMPILE_NAME("storeProblemError") = 2,
  RCPurchaseNotAllowedError SWIFT_COMPILE_NAME("purchaseNotAllowedError") = 3,
  RCPurchaseInvalidError SWIFT_COMPILE_NAME("purchaseInvalidError") = 4,
  RCProductNotAvailableForPurchaseError SWIFT_COMPILE_NAME("productNotAvailableForPurchaseError") = 5,
  RCProductAlreadyPurchasedError SWIFT_COMPILE_NAME("productAlreadyPurchasedError") = 6,
  RCReceiptAlreadyInUseError SWIFT_COMPILE_NAME("receiptAlreadyInUseError") = 7,
  RCInvalidReceiptError SWIFT_COMPILE_NAME("invalidReceiptError") = 8,
  RCMissingReceiptFileError SWIFT_COMPILE_NAME("missingReceiptFileError") = 9,
  RCNetworkError SWIFT_COMPILE_NAME("networkError") = 10,
  RCInvalidCredentialsError SWIFT_COMPILE_NAME("invalidCredentialsError") = 11,
  RCUnexpectedBackendResponseError SWIFT_COMPILE_NAME("unexpectedBackendResponseError") = 12,
  RCReceiptInUseByOtherSubscriberError SWIFT_COMPILE_NAME("receiptInUseByOtherSubscriberError") = 13,
  RCInvalidAppUserIdError SWIFT_COMPILE_NAME("invalidAppUserIdError") = 14,
  RCOperationAlreadyInProgressForProductError SWIFT_COMPILE_NAME("operationAlreadyInProgressForProductError") = 15,
  RCUnknownBackendError SWIFT_COMPILE_NAME("unknownBackendError") = 16,
  RCInvalidAppleSubscriptionKeyError SWIFT_COMPILE_NAME("invalidAppleSubscriptionKeyError") = 17,
  RCIneligibleError SWIFT_COMPILE_NAME("ineligibleError") = 18,
  RCInsufficientPermissionsError SWIFT_COMPILE_NAME("insufficientPermissionsError") = 19,
  RCPaymentPendingError SWIFT_COMPILE_NAME("paymentPendingError") = 20,
  RCInvalidSubscriberAttributesError SWIFT_COMPILE_NAME("invalidSubscriberAttributesError") = 21,
  RCLogOutAnonymousUserError SWIFT_COMPILE_NAME("logOutAnonymousUserError") = 22,
  RCConfigurationError SWIFT_COMPILE_NAME("configurationError") = 23,
  RCUnsupportedError SWIFT_COMPILE_NAME("unsupportedError") = 24,
  RCEmptySubscriberAttributesError SWIFT_COMPILE_NAME("emptySubscriberAttributes") = 25,
  RCProductDiscountMissingIdentifierError SWIFT_COMPILE_NAME("productDiscountMissingIdentifierError") = 26,
  RCProductDiscountMissingSubscriptionGroupIdentifierError SWIFT_COMPILE_NAME("productDiscountMissingSubscriptionGroupIdentifierError") = 28,
  RCCustomerInfoError SWIFT_COMPILE_NAME("customerInfoError") = 29,
  RCSystemInfoError SWIFT_COMPILE_NAME("systemInfoError") = 30,
  RCBeginRefundRequestError SWIFT_COMPILE_NAME("beginRefundRequestError") = 31,
  RCProductRequestTimedOut SWIFT_COMPILE_NAME("productRequestTimedOut") = 32,
  RCAPIEndpointBlocked SWIFT_COMPILE_NAME("apiEndpointBlockedError") = 33,
  RCInvalidPromotionalOfferError SWIFT_COMPILE_NAME("invalidPromotionalOfferError") = 34,
  RCOfflineConnectionError SWIFT_COMPILE_NAME("offlineConnectionError") = 35,
  RCFeatureNotAvailableInCustomEntitlementsComputationMode SWIFT_COMPILE_NAME("featureNotAvailableInCustomEntitlementsComputationMode") = 36,
  RCSignatureVerificationFailed SWIFT_COMPILE_NAME("signatureVerificationFailed") = 37,
};
static NSString * _Nonnull const RCPurchasesErrorCodeDomain = @"RevenueCat.ErrorCode";


SWIFT_CLASS("_TtC10RevenueCat15FakeASIdManager")
@interface FakeASIdManager : NSObject
+ (FakeASIdManager * _Nonnull)sharedManager SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC10RevenueCat17FakeAfficheClient")
@interface FakeAfficheClient : NSObject
+ (FakeAfficheClient * _Nonnull)sharedClient SWIFT_WARN_UNUSED_RESULT;
- (void)requestAttributionDetailsWithBlock:(void (^ _Nonnull)(NSDictionary<NSString *, NSObject *> * _Nullable, NSError * _Nullable))completionHandler;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC10RevenueCat19FakeTrackingManager")
@interface FakeTrackingManager : NSObject
+ (NSInteger)trackingAuthorizationStatus SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, FakeTrackingManagerAuthorizationStatus, closed) {
  FakeTrackingManagerAuthorizationStatusNotDetermined = 0,
  FakeTrackingManagerAuthorizationStatusRestricted = 1,
  FakeTrackingManagerAuthorizationStatusDenied = 2,
  FakeTrackingManagerAuthorizationStatusAuthorized = 3,
};



SWIFT_CLASS("_TtC10RevenueCat24GetCustomerInfoOperation")
@interface GetCustomerInfoOperation : CacheableNetworkOperation
@end



SWIFT_CLASS("_TtC10RevenueCat28GetIntroEligibilityOperation")
@interface GetIntroEligibilityOperation : NetworkOperation
@end




SWIFT_CLASS("_TtC10RevenueCat21GetOfferingsOperation")
@interface GetOfferingsOperation : CacheableNetworkOperation
@end



SWIFT_CLASS("_TtC10RevenueCat37GetProductEntitlementMappingOperation")
@interface GetProductEntitlementMappingOperation : CacheableNetworkOperation
@end



SWIFT_CLASS("_TtC10RevenueCat15HealthOperation")
@interface HealthOperation : CacheableNetworkOperation
@end




enum RCIntroEligibilityStatus : NSInteger;

/// Holds the introductory price status
SWIFT_CLASS_NAMED("IntroEligibility")
@interface RCIntroEligibility : NSObject
/// The introductory price eligibility status
@property (nonatomic, readonly) enum RCIntroEligibilityStatus status;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
@end




@interface RCIntroEligibility (SWIFT_EXTENSION(RevenueCat))
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@property (nonatomic, readonly, copy) NSString * _Nonnull debugDescription;
@end

/// Enum of different possible states for intro price eligibility status.
/// <ul>
///   <li>
///     <code>IntroEligibilityStatus/unknown</code> RevenueCat doesn’t have enough information to determine eligibility.
///   </li>
///   <li>
///     <code>IntroEligibilityStatus/ineligible</code> The user is not eligible for a free trial or intro pricing for this
///     product.
///   </li>
///   <li>
///     <code>IntroEligibilityStatus/eligible</code> The user is eligible for a free trial or intro pricing for this product.
///   </li>
/// </ul>
typedef SWIFT_ENUM_NAMED(NSInteger, RCIntroEligibilityStatus, "IntroEligibilityStatus", open) {
/// RevenueCat doesn’t have enough information to determine eligibility.
  RCIntroEligibilityStatusUnknown = 0,
/// The user is not eligible for a free trial or intro pricing for this product.
  RCIntroEligibilityStatusIneligible = 1,
/// The user is eligible for a free trial or intro pricing for this product.
  RCIntroEligibilityStatusEligible = 2,
/// There is no free trial or intro pricing for this product.
  RCIntroEligibilityStatusNoIntroOfferExists = 3,
};


SWIFT_CLASS("_TtC10RevenueCat14LogInOperation")
@interface LogInOperation : CacheableNetworkOperation
@end



/// Enumeration of the different verbosity levels.
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>Purchases/logLevel</code>
///   </li>
/// </ul>
typedef SWIFT_ENUM_NAMED(NSInteger, RCLogLevel, "LogLevel", open) {
  RCLogLevelVerbose = 4,
  RCLogLevelDebug = 0,
  RCLogLevelInfo = 1,
  RCLogLevelWarn = 2,
  RCLogLevelError = 3,
};





/// Information that represents a non-subscription purchase made by a user.
/// This can be one of these types of product:
/// <ul>
///   <li>
///     Consumables
///   </li>
///   <li>
///     Non-consumables
///   </li>
///   <li>
///     Non-renewing subscriptions
///   </li>
/// </ul>
SWIFT_CLASS_NAMED("NonSubscriptionTransaction")
@interface RCNonSubscriptionTransaction : NSObject
/// The product identifier.
@property (nonatomic, readonly, copy) NSString * _Nonnull productIdentifier;
/// The date that App Store charged the user’s account.
@property (nonatomic, readonly, copy) NSDate * _Nonnull purchaseDate;
/// The unique identifier for the transaction created by RevenueCat.
@property (nonatomic, readonly, copy) NSString * _Nonnull transactionIdentifier;
/// The unique identifier for the transaction created by the Store.
@property (nonatomic, readonly, copy) NSString * _Nonnull storeTransactionIdentifier;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@class RCPackage;

/// An offering is a collection of <code>Package</code>s, and they let you control which products
/// are shown to users without requiring an app update.
/// Building paywalls that are dynamic and can react to different product
/// configurations gives you maximum flexibility to make remote updates.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/displaying-products">Displaying Products</a>
///   </li>
///   <li>
///     <code>Offerings</code>
///   </li>
///   <li>
///     <code>Package</code>
///   </li>
/// </ul>
SWIFT_CLASS_NAMED("Offering")
@interface RCOffering : NSObject
/// Unique identifier defined in RevenueCat dashboard.
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
/// Offering description defined in RevenueCat dashboard.
@property (nonatomic, readonly, copy) NSString * _Nonnull serverDescription;
/// Offering metadata defined in RevenueCat dashboard.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nonnull metadata;
/// Array of <code>Package</code> objects available for purchase.
@property (nonatomic, readonly, copy) NSArray<RCPackage *> * _Nonnull availablePackages;
/// Lifetime <code>Package</code> type configured in the RevenueCat dashboard, if available.
@property (nonatomic, readonly, strong) RCPackage * _Nullable lifetime;
/// Annual <code>Package</code> type configured in the RevenueCat dashboard, if available.
@property (nonatomic, readonly, strong) RCPackage * _Nullable annual;
/// Six month <code>Package</code> type configured in the RevenueCat dashboard, if available.
@property (nonatomic, readonly, strong) RCPackage * _Nullable sixMonth;
/// Three month <code>Package</code> type configured in the RevenueCat dashboard, if available.
@property (nonatomic, readonly, strong) RCPackage * _Nullable threeMonth;
/// Two month <code>Package</code> type configured in the RevenueCat dashboard, if available.
@property (nonatomic, readonly, strong) RCPackage * _Nullable twoMonth;
/// Monthly <code>Package</code> type configured in the RevenueCat dashboard, if available.
@property (nonatomic, readonly, strong) RCPackage * _Nullable monthly;
/// Weekly <code>Package</code> type configured in the RevenueCat dashboard, if available.
@property (nonatomic, readonly, strong) RCPackage * _Nullable weekly;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Retrieves a specific <code>Package</code> by identifier, use this to access custom package types configured in the
/// RevenueCat dashboard, e.g. <code>offering.package(identifier: "custom_package_id")</code> or
/// <code>offering["custom_package_id"]</code>.
- (RCPackage * _Nullable)packageWithIdentifier:(NSString * _Nullable)identifier SWIFT_WARN_UNUSED_RESULT;
- (RCPackage * _Nullable)objectForKeyedSubscript:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
/// Initialize an <code>Offering</code> given a list of <code>Package</code>s.
- (nonnull instancetype)initWithIdentifier:(NSString * _Nonnull)identifier serverDescription:(NSString * _Nonnull)serverDescription metadata:(NSDictionary<NSString *, id> * _Nonnull)metadata availablePackages:(NSArray<RCPackage *> * _Nonnull)availablePackages;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end








/// This class contains all the offerings configured in RevenueCat dashboard.
/// Offerings let you control which products are shown to users without requiring an app update.
/// Building paywalls that are dynamic and can react to different product
/// configurations gives you maximum flexibility to make remote updates.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/displaying-products">Displaying Products</a>
///   </li>
///   <li>
///     <code>Offering</code>
///   </li>
///   <li>
///     <code>Package</code>
///   </li>
/// </ul>
SWIFT_CLASS_NAMED("Offerings")
@interface RCOfferings : NSObject
/// Dictionary of all Offerings (<code>Offering</code>) objects keyed by their identifier. This dictionary can also be accessed
/// by using an index subscript on <code>Offerings</code>, e.g. <code>offerings["offering_id"]</code>. To access the current offering use
/// <code>Offerings/current</code>.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, RCOffering *> * _Nonnull all;
/// Current <code>Offering</code> configured in the RevenueCat dashboard.
@property (nonatomic, readonly, strong) RCOffering * _Nullable current;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@interface RCOfferings (SWIFT_EXTENSION(RevenueCat))
/// Retrieves a specific offering by its identifier, use this to access additional offerings configured in the
/// RevenueCat dashboard, e.g. <code>offerings.offering(identifier: "offering_id")</code> or <code>offerings[@"offering_id"]</code>.
/// To access the current offering use <code>Offerings/current</code>.
- (RCOffering * _Nullable)offeringWithIdentifier:(NSString * _Nullable)identifier SWIFT_WARN_UNUSED_RESULT;
- (RCOffering * _Nullable)objectForKeyedSubscript:(NSString * _Nonnull)key SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end



enum RCPackageType : NSInteger;
@class RCStoreProduct;

/// Packages help abstract platform-specific products by grouping equivalent products across iOS, Android, and web.
/// A package is made up of three parts: <code>identifier</code>, <code>packageType</code>, and underlying <code>StoreProduct</code>.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/displaying-products#displaying-packages">Displaying Packages</a>
///   </li>
///   <li>
///     <code>Offering</code>
///   </li>
///   <li>
///     <code>Offerings</code>
///   </li>
/// </ul>
SWIFT_CLASS_NAMED("Package")
@interface RCPackage : NSObject
/// The identifier for this Package.
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
/// The type configured for this package.
@property (nonatomic, readonly) enum RCPackageType packageType;
/// The underlying <code>storeProduct</code>
@property (nonatomic, readonly, strong) RCStoreProduct * _Nonnull storeProduct;
/// The identifier of the <code>Offering</code> containing this Package.
@property (nonatomic, readonly, copy) NSString * _Nonnull offeringIdentifier;
/// The price of this product using <code>StoreProduct/priceFormatter</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull localizedPriceString;
/// The price of the <code>StoreProduct/introductoryDiscount</code> formatted using <code>StoreProduct/priceFormatter</code>.
///
/// returns:
/// <code>nil</code> if there is no <code>introductoryDiscount</code>.
@property (nonatomic, readonly, copy) NSString * _Nullable localizedIntroductoryPriceString;
/// Initialize a <code>Package</code>.
- (nonnull instancetype)initWithIdentifier:(NSString * _Nonnull)identifier packageType:(enum RCPackageType)packageType storeProduct:(RCStoreProduct * _Nonnull)storeProduct offeringIdentifier:(NSString * _Nonnull)offeringIdentifier OBJC_DESIGNATED_INITIALIZER;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




@interface RCPackage (SWIFT_EXTENSION(RevenueCat))
/// \param packageType A <code>PackageType</code>.
///
///
/// returns:
/// an optional description of the packageType.
+ (NSString * _Nullable)stringFrom:(enum RCPackageType)packageType SWIFT_WARN_UNUSED_RESULT;
/// \param string A string that maps to a enumeration value of type <code>PackageType</code>
///
///
/// returns:
/// a <code>PackageType</code> for the given string.
+ (enum RCPackageType)packageTypeFrom:(NSString * _Nonnull)string SWIFT_WARN_UNUSED_RESULT;
@end

@class SKProduct;

@interface RCPackage (SWIFT_EXTENSION(RevenueCat))
/// <code>SKProduct</code> assigned to this package. https://developer.apple.com/documentation/storekit/skproduct
@property (nonatomic, readonly, strong) SKProduct * _Nonnull product SWIFT_AVAILABILITY(maccatalyst,obsoleted=1,message="'product' has been renamed to 'storeProduct': Use StoreProduct instead") SWIFT_AVAILABILITY(macos,obsoleted=1,message="'product' has been renamed to 'storeProduct': Use StoreProduct instead") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'product' has been renamed to 'storeProduct': Use StoreProduct instead") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'product' has been renamed to 'storeProduct': Use StoreProduct instead") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'product' has been renamed to 'storeProduct': Use StoreProduct instead");
@end


/// Enumeration of all possible <code>Package</code> types, as configured on the package.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <code>Package</code>
///   </li>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/displaying-products">Displaying Products</a>
///   </li>
/// </ul>
typedef SWIFT_ENUM_NAMED(NSInteger, RCPackageType, "PackageType", open) {
/// A package that was defined with an unknown identifier.
  RCPackageTypeUnknown = -2,
/// A package that was defined with an unknown identifier.
  RCPackageTypeCustom = -1,
/// A package that was defined with an unknown identifier.
  RCPackageTypeLifetime = 0,
/// A package that was defined with an unknown identifier.
  RCPackageTypeAnnual = 1,
/// A package that was defined with an unknown identifier.
  RCPackageTypeSixMonth = 2,
/// A package that was defined with an unknown identifier.
  RCPackageTypeThreeMonth = 3,
/// A package that was defined with an unknown identifier.
  RCPackageTypeTwoMonth = 4,
/// A package that was defined with an unknown identifier.
  RCPackageTypeMonthly = 5,
/// A package that was defined with an unknown identifier.
  RCPackageTypeWeekly = 6,
};

@class SKPaymentTransaction;
@class RCStorefront;

/// A wrapper for <code>SKPaymentQueue</code>
SWIFT_PROTOCOL("_TtP10RevenueCat23PaymentQueueWrapperType_")
@protocol PaymentQueueWrapperType
- (void)finishTransaction:(SKPaymentTransaction * _Nonnull)transaction completion:(void (^ _Nonnull)(void))completion;
- (void)presentCodeRedemptionSheet SWIFT_AVAILABILITY(maccatalyst,unavailable) SWIFT_AVAILABILITY(watchos,unavailable) SWIFT_AVAILABILITY(tvos,unavailable) SWIFT_AVAILABILITY(macos,unavailable) SWIFT_AVAILABILITY(ios,introduced=14.0);
@property (nonatomic, readonly, strong) RCStorefront * _Nullable currentStorefront;
@end


/// Implementation of <code>PaymentQueueWrapperType</code> used when SK1 is not enabled.
SWIFT_CLASS("_TtC10RevenueCat19PaymentQueueWrapper")
@interface PaymentQueueWrapper : NSObject <PaymentQueueWrapperType>
- (void)finishTransaction:(SKPaymentTransaction * _Nonnull)transaction completion:(void (^ _Nonnull)(void))completion;
@property (nonatomic, readonly, strong) RCStorefront * _Nullable currentStorefront;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@interface PaymentQueueWrapper (SWIFT_EXTENSION(RevenueCat)) <SKPaymentQueueDelegate>
@end

@class SKPaymentQueue;
@class SKPayment;

@interface PaymentQueueWrapper (SWIFT_EXTENSION(RevenueCat)) <SKPaymentTransactionObserver>
- (void)paymentQueue:(SKPaymentQueue * _Nonnull)queue updatedTransactions:(NSArray<SKPaymentTransaction *> * _Nonnull)transactions;
- (BOOL)paymentQueue:(SKPaymentQueue * _Nonnull)queue shouldAddStorePayment:(SKPayment * _Nonnull)payment forProduct:(SKProduct * _Nonnull)product SWIFT_WARN_UNUSED_RESULT;
@end


/// Enum of supported period types for an entitlement.
typedef SWIFT_ENUM_NAMED(NSInteger, RCPeriodType, "PeriodType", open) {
/// If the entitlement is not under an introductory or trial period.
  RCNormal SWIFT_COMPILE_NAME("normal") = 0,
/// If the entitlement is under a introductory price period.
  RCIntro SWIFT_COMPILE_NAME("intro") = 1,
/// If the entitlement is under a trial period.
  RCTrial SWIFT_COMPILE_NAME("trial") = 2,
};


SWIFT_CLASS("_TtC10RevenueCat28PostAdServicesTokenOperation")
@interface PostAdServicesTokenOperation : NetworkOperation
@end



SWIFT_CLASS("_TtC10RevenueCat28PostAttributionDataOperation")
@interface PostAttributionDataOperation : NetworkOperation
@end



SWIFT_CLASS("_TtC10RevenueCat28PostOfferForSigningOperation")
@interface PostOfferForSigningOperation : NetworkOperation
@end



/// A <code>NetworkOperation</code> for posting <code>PaywallEvent</code>s.
SWIFT_CLASS("_TtC10RevenueCat26PostPaywallEventsOperation")
@interface PostPaywallEventsOperation : NetworkOperation
@end


SWIFT_CLASS("_TtC10RevenueCat24PostReceiptDataOperation")
@interface PostReceiptDataOperation : CacheableNetworkOperation
@end




SWIFT_CLASS("_TtC10RevenueCat33PostSubscriberAttributesOperation")
@interface PostSubscriberAttributesOperation : NetworkOperation
@end



SWIFT_CLASS("_TtC10RevenueCat18ProductsFetcherSK1")
@interface ProductsFetcherSK1 : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




@class SKProductsRequest;
@class SKProductsResponse;
@class SKRequest;

@interface ProductsFetcherSK1 (SWIFT_EXTENSION(RevenueCat)) <SKProductsRequestDelegate>
- (void)productsRequest:(SKProductsRequest * _Nonnull)request didReceiveResponse:(SKProductsResponse * _Nonnull)response;
- (void)requestDidFinish:(SKRequest * _Nonnull)request;
- (void)request:(SKRequest * _Nonnull)request didFailWithError:(NSError * _Nonnull)error;
@end


/// Basic implemenation of a <code>ProductsManagerType</code>
SWIFT_CLASS("_TtC10RevenueCat15ProductsManager")
@interface ProductsManager : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@class RCStoreProductDiscount;
@class RCPromotionalOfferSignedData;

/// Represents a <code>StoreProductDiscount</code> that has been validated and
/// is ready to be used for a purchase.
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>Purchases/promotionalOffer(forProductDiscount:product:)</code>
///   </li>
///   <li>
///     <code>Purchases/getPromotionalOffer(forProductDiscount:product:completion:)</code>
///   </li>
///   <li>
///     <code>StoreProduct/eligiblePromotionalOffers()</code>
///   </li>
///   <li>
///     <code>Purchases/eligiblePromotionalOffers(forProduct:)</code>
///   </li>
///   <li>
///     <code>Purchases/purchase(package:promotionalOffer:)</code>
///   </li>
///   <li>
///     <code>Purchases/purchase(package:promotionalOffer:completion:)</code>
///   </li>
///   <li>
///     <code>Purchases/purchase(product:promotionalOffer:)</code>
///   </li>
///   <li>
///     <code>Purchases/purchase(product:promotionalOffer:completion:)</code>
///   </li>
/// </ul>
SWIFT_CLASS_NAMED("PromotionalOffer")
@interface RCPromotionalOffer : NSObject
/// The <code>StoreProductDiscount</code> in this offer.
@property (nonatomic, readonly, strong) RCStoreProductDiscount * _Nonnull discount;
/// The <code>PromotionalOffer/SignedData-swift.class</code> provides information about the <code>PromotionalOffer</code>’s signature.
@property (nonatomic, readonly, strong) RCPromotionalOfferSignedData * _Nonnull signedData;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@interface RCPromotionalOffer (SWIFT_EXTENSION(RevenueCat))
@end

@class NSUUID;

/// Contains the details of a promotional offer discount that you want to apply to a payment.
SWIFT_CLASS_NAMED("SignedData")
@interface RCPromotionalOfferSignedData : NSObject
/// The subscription offer identifier.
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
/// The key identifier of the subscription key.
@property (nonatomic, readonly, copy) NSString * _Nonnull keyIdentifier;
/// The nonce used in the signature.
@property (nonatomic, readonly, copy) NSUUID * _Nonnull nonce;
/// The cryptographic signature of the offer parameters, generated on RevenueCat’s server.
@property (nonatomic, readonly, copy) NSString * _Nonnull signature;
/// The UNIX time, in milliseconds, when the signature was generated.
@property (nonatomic, readonly) NSInteger timestamp;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS_NAMED("PromotionalOfferEligibility") SWIFT_AVAILABILITY(maccatalyst,obsoleted=1,message="Use PromotionalOffer instead") SWIFT_AVAILABILITY(macos,obsoleted=1,message="Use PromotionalOffer instead") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="Use PromotionalOffer instead") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="Use PromotionalOffer instead") SWIFT_AVAILABILITY(ios,obsoleted=1,message="Use PromotionalOffer instead")
@interface RCPromotionalOfferEligibility : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// The types used to describe whether a transaction was purchased by the user,
/// or is available to them through Family Sharing.
typedef SWIFT_ENUM_NAMED(NSInteger, RCPurchaseOwnershipType, "PurchaseOwnershipType", open) {
/// The purchase was made directly by this user.
  RCPurchaseOwnershipTypePurchased = 0,
/// The purchase has been shared to this user by a family member.
  RCPurchaseOwnershipTypeFamilyShared = 1,
/// The ownership type could not be determined.
  RCPurchaseOwnershipTypeUnknown = 2,
};


SWIFT_CLASS_NAMED("PurchaserInfo") SWIFT_AVAILABILITY(macos,obsoleted=1,message="'PurchaserInfo' has been renamed to 'RCCustomerInfo'") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'PurchaserInfo' has been renamed to 'RCCustomerInfo'") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'PurchaserInfo' has been renamed to 'RCCustomerInfo'") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'PurchaserInfo' has been renamed to 'RCCustomerInfo'")
@interface RCPurchaserInfo : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@protocol RCPurchasesDelegate;
@class NSError;

/// Interface for <code>Purchases</code>.
SWIFT_PROTOCOL_NAMED("PurchasesType")
@protocol RCPurchasesType
/// The <code>appUserID</code> used by <code>Purchases</code>.
/// If not passed on initialization this will be generated and cached by <code>Purchases</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull appUserID;
/// The <code>appUserID</code> used by <code>Purchases</code>.
/// If not passed on initialization this will be generated and cached by <code>Purchases</code>.
@property (nonatomic, readonly) BOOL isAnonymous;
/// Whether transactions should be finished automatically. <code>true</code> by default.
/// * - Warning: Setting this value to <code>false</code> will prevent the SDK from finishing transactions.
/// * In this case, you <em>must</em> finish transactions in your app, otherwise they will remain in the queue and
/// * will turn up every time the app is opened.
/// * More information on finishing transactions manually <a href="https://rev.cat/finish-transactions">is available here</a>.
@property (nonatomic) BOOL finishTransactions;
/// Delegate for <code>Purchases</code> instance. The delegate is responsible for handling promotional product purchases and
/// changes to customer information.
/// note:
/// this is not thread-safe.
@property (nonatomic, strong) id <RCPurchasesDelegate> _Nullable delegate;
/// This function will log in the current user with an <code>appUserID</code>.
/// The <code>completion</code> block will be called with the latest <code>CustomerInfo</code> and a <code>Bool</code> specifying
/// whether the user was created for the first time in the RevenueCat backend.
/// RevenueCat provides a source of truth for a subscriber’s status across different platforms.
/// To do this, each subscriber has an App User ID that uniquely identifies them within your application.
/// User identity is one of the most important components of many mobile applications,
/// and it’s extra important to make sure the subscription status RevenueCat is
/// tracking gets associated with the correct user.
/// The Purchases SDK allows you to specify your own user identifiers or use anonymous identifiers
/// generated by RevenueCat. Some apps will use a combination
/// of their own identifiers and RevenueCat anonymous Ids - that’s okay!
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/user-ids">Identifying Users</a>
///   </li>
///   <li>
///     <code>Purchases/logOut(completion:)</code>
///   </li>
///   <li>
///     <code>Purchases/isAnonymous</code>
///   </li>
///   <li>
///     <code>Purchases/appUserID</code>
///   </li>
/// </ul>
/// \param appUserID The <code>appUserID</code> that should be linked to the current user.
///
- (void)logIn:(NSString * _Nonnull)appUserID completion:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, BOOL, NSError * _Nullable))completion;
/// This function will log in the current user with an <code>appUserID</code>.
/// RevenueCat provides a source of truth for a subscriber’s status across different platforms.
/// To do this, each subscriber has an App User ID that uniquely identifies them within your application.
/// User identity is one of the most important components of many mobile applications,
/// and it’s extra important to make sure the subscription status RevenueCat is
/// tracking gets associated with the correct user.
/// The Purchases SDK allows you to specify your own user identifiers or use anonymous identifiers
/// generated by RevenueCat. Some apps will use a combination
/// of their own identifiers and RevenueCat anonymous Ids - that’s okay!
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/user-ids">Identifying Users</a>
///   </li>
///   <li>
///     <code>Purchases/logOut()</code>
///   </li>
///   <li>
///     <code>Purchases/isAnonymous</code>
///   </li>
///   <li>
///     <code>Purchases/appUserID</code>
///   </li>
/// </ul>
/// \param appUserID The <code>appUserID</code> that should be linked to the current user.
///
///
/// returns:
/// A tuple of: the latest <code>CustomerInfo</code> and a <code>Bool</code> specifying
/// whether the user was created for the first time in the RevenueCat backend.
- (void)logIn:(NSString * _Nonnull)appUserID completionHandler:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, BOOL, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
/// Logs out the <code>Purchases</code> client, clearing the saved <code>appUserID</code>.
/// This will generate a random user id and save it in the cache.
/// If this method is called and the current user is anonymous, it will return an error.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/user-ids">Identifying Users</a>
///   </li>
///   <li>
///     <code>Purchases/logIn(_:)-arja</code>
///   </li>
///   <li>
///     <code>Purchases/isAnonymous</code>
///   </li>
///   <li>
///     <code>Purchases/appUserID</code>
///   </li>
/// </ul>
- (void)logOutWithCompletion:(void (^ _Nullable)(RCCustomerInfo * _Nullable, NSError * _Nullable))completion;
/// Logs out the <code>Purchases</code> client, clearing the saved <code>appUserID</code>.
/// This will generate a random user id and save it in the cache.
/// If this method is called and the current user is anonymous, it will return an error.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/user-ids">Identifying Users</a>
///   </li>
///   <li>
///     <code>Purchases/logIn(_:)-arja</code>
///   </li>
///   <li>
///     <code>Purchases/isAnonymous</code>
///   </li>
///   <li>
///     <code>Purchases/appUserID</code>
///   </li>
/// </ul>
- (void)logOutWithCompletionHandler:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
/// Get latest available customer  info.
/// \param completion A completion block called when customer info is available and not stale.
/// Called immediately if <code>CustomerInfo</code> is cached. Customer info can be nil if an error occurred.
///
- (void)getCustomerInfoWithCompletion:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, NSError * _Nullable))completion;
/// Get latest available customer info.
/// \param fetchPolicy The behavior for what to do regarding caching.
///
/// \param completion A completion block called when customer info is available and not stale.
///
- (void)getCustomerInfoWithFetchPolicy:(enum RCCacheFetchPolicy)fetchPolicy completion:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, NSError * _Nullable))completion;
/// Get latest available customer info.
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>Purchases/customerInfo(fetchPolicy:)</code>
///   </li>
///   <li>
///     <code>Purchases/customerInfoStream</code>
///   </li>
/// </ul>
- (void)customerInfoWithCompletionHandler:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
/// Get latest available customer info.
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>Purchases/customerInfoStream</code>
///   </li>
/// </ul>
/// \param fetchPolicy The behavior for what to do regarding caching.
///
- (void)customerInfoWithFetchPolicy:(enum RCCacheFetchPolicy)fetchPolicy completionHandler:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
/// The currently cached <code>CustomerInfo</code> if one is available.
/// This is synchronous, and therefore useful for contexts where an app needs a <code>CustomerInfo</code>
/// right away without waiting for a callback, like a SwiftUI view.
/// This allows initializing state to ensure that UI can be loaded from the very first frame.
@property (nonatomic, readonly, strong) RCCustomerInfo * _Nullable cachedCustomerInfo;
/// Fetch the configured <code>Offerings</code> for this user.
/// <code>Offerings</code> allows you to configure your in-app products
/// via RevenueCat and greatly simplifies management.
/// <code>Offerings</code> will be fetched and cached on instantiation so that, by the time they are needed,
/// your prices are loaded for your purchase flow. Time is money.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/displaying-products">Displaying Products</a>
///   </li>
/// </ul>
/// \param completion A completion block called when offerings are available.
/// Called immediately if offerings are cached. <code>Offerings</code> will be <code>nil</code> if an error occurred.
///
- (void)getOfferingsWithCompletion:(void (^ _Nonnull)(RCOfferings * _Nullable, NSError * _Nullable))completion;
/// Fetch the configured <code>Offerings</code> for this user.
/// <code>Offerings</code> allows you to configure your in-app products
/// via RevenueCat and greatly simplifies management.
/// <code>Offerings</code> will be fetched and cached on instantiation so that, by the time they are needed,
/// your prices are loaded for your purchase flow. Time is money.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/displaying-products">Displaying Products</a>
///   </li>
/// </ul>
- (void)offeringsWithCompletionHandler:(void (^ _Nonnull)(RCOfferings * _Nullable, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
/// The currently cached <code>Offerings</code> if available.
/// This is synchronous, and therefore useful for contexts where an app needs an instance of <code>Offerings</code>
/// right away without waiting for a callback, like a SwiftUI view.
/// This allows initializing state to ensure that UI can be loaded from the very first frame.
@property (nonatomic, readonly, strong) RCOfferings * _Nullable cachedOfferings;
/// Fetches the <code>StoreProduct</code>s for your IAPs for given <code>productIdentifiers</code>.
/// Use this method if you aren’t using <code>Purchases/getOfferings(completion:)</code>.
/// You should use <code>Purchases/getOfferings(completion:)</code> though.
/// note:
/// <code>completion</code> may be called without <code>StoreProduct</code>s that you are expecting. This is usually caused by
/// iTunesConnect configuration errors. Ensure your IAPs have the “Ready to Submit” status in iTunesConnect.
/// Also ensure that you have an active developer program subscription and you have signed the latest paid
/// application agreements.
/// If you’re having trouble, see:
/// <a href="https://rev.cat/how-to-configure-products">App Store Connect In-App Purchase Configuration</a>
/// \param productIdentifiers A set of product identifiers for in-app purchases setup via
/// <a href="https://appstoreconnect.apple.com/">AppStoreConnect</a>
/// This should be either hard coded in your application, from a file, or from a custom endpoint if you want
/// to be able to deploy new IAPs without an app update.
///
/// \param completion An <code>@escaping</code> callback that is called with the loaded products.
/// If the fetch fails for any reason it will return an empty array.
///
- (void)getProductsWithIdentifiers:(NSArray<NSString *> * _Nonnull)productIdentifiers completion:(void (^ _Nonnull)(NSArray<RCStoreProduct *> * _Nonnull))completion;
/// Fetches the <code>StoreProduct</code>s for your IAPs for given <code>productIdentifiers</code>.
/// Use this method if you aren’t using <code>Purchases/getOfferings(completion:)</code>.
/// You should use <code>Purchases/getOfferings(completion:)</code> though.
/// note:
/// The result might not contain the <code>StoreProduct</code>s that you are expecting. This is usually caused by
/// iTunesConnect configuration errors. Ensure your IAPs have the “Ready to Submit” status in iTunesConnect.
/// Also ensure that you have an active developer program subscription and you have signed the latest paid
/// application agreements.
/// If you’re having trouble, see:
/// <a href="https://rev.cat/how-to-configure-products">App Store Connect In-App Purchase Configuration</a>
/// \param productIdentifiers A set of product identifiers for in-app purchases setup via
/// <a href="https://appstoreconnect.apple.com/">AppStoreConnect</a>
/// This should be either hard coded in your application, from a file, or from a custom endpoint if you want
/// to be able to deploy new IAPs without an app update.
///
- (void)products:(NSArray<NSString *> * _Nonnull)productIdentifiers completionHandler:(void (^ _Nonnull)(NSArray<RCStoreProduct *> * _Nonnull))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
/// Initiates a purchase of a <code>StoreProduct</code>.
/// Use this function if you are not using the <code>Offerings</code> system to purchase a <code>StoreProduct</code>.
/// If you are using the <code>Offerings</code> system, use <code>Purchases/purchase(package:completion:)</code> instead.
/// important:
/// Call this method when a user has decided to purchase a product.
/// Only call this in direct response to user input.
/// From here <code>Purchases</code> will handle the purchase with <code>StoreKit</code> and call the <code>PurchaseCompletedBlock</code>.
/// note:
/// You do not need to finish the transaction yourself in the completion callback, Purchases will
/// handle this for you.
/// If the purchase was successful there will be a <code>StoreTransaction</code> and a <code>CustomerInfo</code>.
/// If the purchase was not successful, there will be an <code>NSError</code>.
/// If the user cancelled, <code>userCancelled</code> will be <code>true</code>.
/// \param product The <code>StoreProduct</code> the user intends to purchase.
///
/// \param completion A completion block that is called when the purchase completes.
///
- (void)purchaseProduct:(RCStoreProduct * _Nonnull)product withCompletion:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, NSError * _Nullable, BOOL))completion;
/// Initiates a purchase of a <code>StoreProduct</code>.
/// Use this function if you are not using the <code>Offerings</code> system to purchase a <code>StoreProduct</code>.
/// If you are using the <code>Offerings</code> system, use <code>Purchases/purchase(package:completion:)</code> instead.
/// important:
/// Call this method when a user has decided to purchase a product.
/// Only call this in direct response to user input.
/// From here <code>Purchases</code> will handle the purchase with <code>StoreKit</code> and return <code>PurchaseResultData</code>.
/// note:
/// You do not need to finish the transaction yourself after this, <code>Purchases</code> will
/// handle this for you.
/// \param product The <code>StoreProduct</code> the user intends to purchase.
///
///
/// throws:
/// An error of type <code>ErrorCode</code> is thrown if a failure occurs while purchasing
///
/// returns:
/// A tuple with <code>StoreTransaction</code> and a <code>CustomerInfo</code> if the purchase was successful.
/// If the user cancelled the purchase, <code>userCancelled</code> will be <code>true</code>.
- (void)purchaseWithProduct:(RCStoreProduct * _Nonnull)product completionHandler:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, BOOL, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
/// Initiates a purchase of a <code>Package</code>.
/// important:
/// Call this method when a user has decided to purchase a product.
/// Only call this in direct response to user input.
/// From here <code>Purchases</code> will handle the purchase with <code>StoreKit</code> and call the <code>PurchaseCompletedBlock</code>.
/// note:
/// You do not need to finish the transaction yourself in the completion callback, Purchases will
/// handle this for you.
/// If the purchase was successful there will be a <code>StoreTransaction</code> and a <code>CustomerInfo</code>.
/// If the purchase was not successful, there will be an <code>NSError</code>.
/// If the user cancelled, <code>userCancelled</code> will be <code>true</code>.
/// \param package The <code>Package</code> the user intends to purchase
///
/// \param completion A completion block that is called when the purchase completes.
///
- (void)purchasePackage:(RCPackage * _Nonnull)package withCompletion:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, NSError * _Nullable, BOOL))completion;
/// Initiates a purchase of a <code>Package</code>.
/// important:
/// Call this method when a user has decided to purchase a product.
/// Only call this in direct response to user input.
/// From here <code>Purchases</code> will handle the purchase with <code>StoreKit</code> and return <code>PurchaseResultData</code>.
/// note:
/// You do not need to finish the transaction yourself after this, Purchases will
/// handle this for you.
/// \param package The <code>Package</code> the user intends to purchase
///
///
/// throws:
/// An error of type <code>ErrorCode</code> is thrown if a failure occurs while purchasing
///
/// returns:
/// A tuple with <code>StoreTransaction</code> and a <code>CustomerInfo</code> if the purchase was successful.
/// If the user cancelled the purchase, <code>userCancelled</code> will be <code>true</code>.
- (void)purchaseWithPackage:(RCPackage * _Nonnull)package completionHandler:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, BOOL, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
/// Invalidates the cache for customer information.
/// Most apps will not need to use this method; invalidating the cache can leave your app in an invalid state.
/// Refer to
/// <a href="https://docs.revenuecat.com/docs/purchaserinfo#section-get-user-information">Get User Information</a>
/// for more information on using the cache properly.
/// This is useful for cases where customer information might have been updated outside of the app, like if a
/// promotional subscription is granted through the RevenueCat dashboard.
- (void)invalidateCustomerInfoCache;
/// This method will post all purchases associated with the current App Store account to RevenueCat and become
/// associated with the current <code>appUserID</code>. If the receipt is being used by an existing user, the current
/// <code>appUserID</code> will be aliased together with the <code>appUserID</code> of the existing user.
/// Going forward, either <code>appUserID</code> will be able to reference the same user.
/// You shouldn’t use this method if you have your own account system. In that case “restoration” is provided
/// by your app passing the same <code>appUserID</code> used to purchase originally.
/// note:
/// This may force your users to enter the App Store password so should only be performed on request of
/// the user. Typically with a button in settings or near your purchase UI. Use
/// <code>Purchases/syncPurchases(completion:)</code> if you need to restore transactions programmatically.
/// warning:
/// Receiving a <code>CustomerInfo</code> instead of an error does not imply that the user has any
/// entitlements, simply that the process was successful. You must verify the <code>CustomerInfo/entitlements</code>
/// to confirm that they are active.
- (void)restorePurchasesWithCompletion:(void (^ _Nullable)(RCCustomerInfo * _Nullable, NSError * _Nullable))completion;
/// This method will post all purchases associated with the current App Store account to RevenueCat and become
/// associated with the current <code>appUserID</code>. If the receipt is being used by an existing user, the current
/// <code>appUserID</code> will be aliased together with the <code>appUserID</code> of the existing user.
/// Going forward, either <code>appUserID</code> will be able to reference the same user.
/// You shouldn’t use this method if you have your own account system. In that case “restoration” is provided
/// by your app passing the same <code>appUserID</code> used to purchase originally.
/// note:
/// This may force your users to enter the App Store password so should only be performed on request of
/// the user. Typically with a button in settings or near your purchase UI. Use
/// <code>Purchases/syncPurchases(completion:)</code> if you need to restore transactions programmatically.
/// warning:
/// Receiving a <code>CustomerInfo</code> instead of an error does not imply that the user has any
/// entitlements, simply that the process was successful. You must verify the <code>CustomerInfo/entitlements</code>
/// to confirm that they are active.
- (void)restorePurchasesWithCompletionHandler:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
/// This method will post all purchases associated with the current App Store account to RevenueCat and
/// become associated with the current <code>appUserID</code>.
/// If the receipt is being used by an existing user, the current <code>appUserID</code> will be aliased together with
/// the <code>appUserID</code> of the existing user.
/// Going forward, either <code>appUserID</code> will be able to reference the same user.
/// warning:
/// This function should only be called if you’re not calling any purchase method.
/// note:
/// This method will not trigger a login prompt from App Store. However, if the receipt currently
/// on the device does not contain subscriptions, but the user has made subscription purchases, this method
/// won’t be able to restore them. Use <code>Purchases/restorePurchases(completion:)</code> to cover those cases.
- (void)syncPurchasesWithCompletion:(void (^ _Nullable)(RCCustomerInfo * _Nullable, NSError * _Nullable))completion;
/// This method will post all purchases associated with the current App Store account to RevenueCat and
/// become associated with the current <code>appUserID</code>.
/// If the receipt is being used by an existing user, the current <code>appUserID</code> will be aliased together with
/// the <code>appUserID</code> of the existing user.
/// Going forward, either <code>appUserID</code> will be able to reference the same user.
/// warning:
/// This function should only be called if you’re not calling any purchase method.
/// note:
/// This method will not trigger a login prompt from App Store. However, if the receipt currently
/// on the device does not contain subscriptions, but the user has made subscription purchases, this method
/// won’t be able to restore them. Use <code>Purchases/restorePurchases(completion:)</code> to cover those cases.
- (void)syncPurchasesWithCompletionHandler:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
/// Initiates a purchase of a <code>StoreProduct</code> with a <code>PromotionalOffer</code>.
/// Use this function if you are not using the Offerings system to purchase a <code>StoreProduct</code> with an
/// applied <code>PromotionalOffer</code>.
/// If you are using the Offerings system, use <code>Purchases/purchase(package:promotionalOffer:completion:)</code> instead.
/// important:
/// Call this method when a user has decided to purchase a product with an applied discount.
/// Only call this in direct response to user input.
/// From here <code>Purchases</code> will handle the purchase with <code>StoreKit</code> and call the <code>PurchaseCompletedBlock</code>.
/// note:
/// You do not need to finish the transaction yourself in the completion callback, Purchases will handle
/// this for you.
/// If the purchase was successful there will be a <code>StoreTransaction</code> and a <code>CustomerInfo</code>.
/// If the purchase was not successful, there will be an <code>NSError</code>.
/// If the user cancelled, <code>userCancelled</code> will be <code>true</code>.
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>StoreProduct/discounts</code>
///   </li>
///   <li>
///     <code>StoreProduct/eligiblePromotionalOffers()</code>
///   </li>
///   <li>
///     <code>Purchases/promotionalOffer(forProductDiscount:product:)</code>
///   </li>
/// </ul>
/// \param product The <code>StoreProduct</code> the user intends to purchase.
///
/// \param promotionalOffer The <code>PromotionalOffer</code> to apply to the purchase.
///
/// \param completion A completion block that is called when the purchase completes.
///
- (void)purchaseProduct:(RCStoreProduct * _Nonnull)product withPromotionalOffer:(RCPromotionalOffer * _Nonnull)promotionalOffer completion:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, NSError * _Nullable, BOOL))completion SWIFT_AVAILABILITY(tvos,introduced=12.2) SWIFT_AVAILABILITY(maccatalyst,introduced=13.0) SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(macos,introduced=10.14.4) SWIFT_AVAILABILITY(ios,introduced=12.2);
/// Use this function if you are not using the Offerings system to purchase a <code>StoreProduct</code> with an
/// applied <code>PromotionalOffer</code>.
/// If you are using the Offerings system, use <code>Purchases/purchase(package:promotionalOffer:completion:)</code> instead.
/// Call this method when a user has decided to purchase a product with an applied discount.
/// Only call this in direct response to user input.
/// From here <code>Purchases</code> will handle the purchase with <code>StoreKit</code> and return <code>PurchaseResultData</code>.
/// note:
/// You do not need to finish the transaction yourself after this, Purchases will handle
/// this for you.
/// \param product The <code>StoreProduct</code> the user intends to purchase
///
/// \param promotionalOffer The <code>PromotionalOffer</code> to apply to the purchase
///
///
/// throws:
/// An error of type <code>ErrorCode</code> is thrown if a failure occurs while purchasing
///
/// returns:
/// A tuple with <code>StoreTransaction</code> and a <code>CustomerInfo</code> if the purchase was successful.
/// If the user cancelled the purchase, <code>userCancelled</code> will be <code>true</code>.
- (void)purchaseWithProduct:(RCStoreProduct * _Nonnull)product promotionalOffer:(RCPromotionalOffer * _Nonnull)promotionalOffer completionHandler:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, BOOL, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
/// Purchase the passed <code>Package</code>.
/// Call this method when a user has decided to purchase a product with an applied discount. Only call this in
/// direct response to user input. From here <code>Purchases</code> will handle the purchase with <code>StoreKit</code> and call the
/// <code>PurchaseCompletedBlock</code>.
/// note:
/// You do not need to finish the transaction yourself in the completion callback, Purchases will handle
/// this for you.
/// If the purchase was successful there will be a <code>StoreTransaction</code> and a <code>CustomerInfo</code>.
/// If the purchase was not successful, there will be an <code>NSError</code>.
/// If the user cancelled, <code>userCancelled</code> will be <code>true</code>.
/// \param package The <code>Package</code> the user intends to purchase
///
/// \param promotionalOffer The <code>PromotionalOffer</code> to apply to the purchase
///
/// \param completion A completion block that is called when the purchase completes.
///
- (void)purchasePackage:(RCPackage * _Nonnull)package withPromotionalOffer:(RCPromotionalOffer * _Nonnull)promotionalOffer completion:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, NSError * _Nullable, BOOL))completion SWIFT_AVAILABILITY(tvos,introduced=12.2) SWIFT_AVAILABILITY(maccatalyst,introduced=13.0) SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(macos,introduced=10.14.4) SWIFT_AVAILABILITY(ios,introduced=12.2);
/// Purchase the passed <code>Package</code>.
/// Call this method when a user has decided to purchase a product with an applied discount. Only call this in
/// direct response to user input. From here <code>Purchases</code> will handle the purchase with <code>StoreKit</code> and return
/// <code>PurchaseResultData</code>.
/// note:
/// You do not need to finish the transaction yourself after this, Purchases will handle
/// this for you.
/// \param package The <code>Package</code> the user intends to purchase
///
/// \param promotionalOffer The <code>PromotionalOffer</code> to apply to the purchase
///
///
/// throws:
/// An error of type <code>ErrorCode</code> is thrown if a failure occurs while purchasing
///
/// returns:
/// A tuple with <code>StoreTransaction</code> and a <code>CustomerInfo</code> if the purchase was successful.
/// If the user cancelled the purchase, <code>userCancelled</code> will be <code>true</code>.
- (void)purchaseWithPackage:(RCPackage * _Nonnull)package promotionalOffer:(RCPromotionalOffer * _Nonnull)promotionalOffer completionHandler:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, BOOL, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
/// Computes whether or not a user is eligible for the introductory pricing period of a given product.
/// You should use this method to determine whether or not you show the user the normal product price or
/// the introductory price. This also applies to trials (trials are considered a type of introductory pricing).
/// <a href="https://docs.revenuecat.com/docs/ios-subscription-offers">iOS Introductory  Offers</a>.
/// note:
/// If you’re looking to use Promotional Offers instead,
/// use <code>Purchases/getPromotionalOffer(forProductDiscount:product:completion:)</code>.
/// note:
/// Subscription groups are automatically collected for determining eligibility. If RevenueCat can’t
/// definitively compute the eligibility, most likely because of missing group information, it will return
/// <code>IntroEligibilityStatus/unknown</code>. The best course of action on unknown status is to display the non-intro
/// pricing, to not create a misleading situation. To avoid this, make sure you are testing with the latest
/// version of iOS so that the subscription group can be collected by the SDK.
/// <h3>Related symbols</h3>
/// <ul>
///   <li>
///     <code>Purchases/checkTrialOrIntroDiscountEligibility(product:completion:)</code>
///   </li>
/// </ul>
/// \param productIdentifiers Array of product identifiers for which you want to compute eligibility
///
/// \param receiveEligibility A block that receives a dictionary of <code>product_id</code> -> <code>IntroEligibility</code>.
///
- (void)checkTrialOrIntroDiscountEligibility:(NSArray<NSString *> * _Nonnull)productIdentifiers completion:(void (^ _Nonnull)(NSDictionary<NSString *, RCIntroEligibility *> * _Nonnull))receiveEligibility;
/// Computes whether or not a user is eligible for the introductory pricing period of a given product.
/// You should use this method to determine whether or not you show the user the normal product price or
/// the introductory price. This also applies to trials (trials are considered a type of introductory pricing).
/// <a href="https://docs.revenuecat.com/docs/ios-subscription-offers">iOS Introductory  Offers</a>.
/// note:
/// If you’re looking to use Promotional Offers instead,
/// use <code>Purchases/getPromotionalOffer(forProductDiscount:product:completion:)</code>.
/// note:
/// Subscription groups are automatically collected for determining eligibility. If RevenueCat can’t
/// definitively compute the eligibility, most likely because of missing group information, it will return
/// <code>IntroEligibilityStatus/unknown</code>. The best course of action on unknown status is to display the non-intro
/// pricing, to not create a misleading situation. To avoid this, make sure you are testing with the latest
/// version of iOS so that the subscription group can be collected by the SDK.
/// <h3>Related symbols</h3>
/// <ul>
///   <li>
///     <code>Purchases/checkTrialOrIntroDiscountEligibility(product:)</code>
///   </li>
/// </ul>
/// \param productIdentifiers Array of product identifiers for which you want to compute eligibility
///
- (void)checkTrialOrIntroDiscountEligibilityWithProductIdentifiers:(NSArray<NSString *> * _Nonnull)productIdentifiers completionHandler:(void (^ _Nonnull)(NSDictionary<NSString *, RCIntroEligibility *> * _Nonnull))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(ios,introduced=13.0);
/// Computes whether or not a user is eligible for the introductory pricing period of a given product.
/// You should use this method to determine whether or not you show the user the normal product price or
/// the introductory price. This also applies to trials (trials are considered a type of introductory pricing).
/// <a href="https://docs.revenuecat.com/docs/ios-subscription-offers">iOS Introductory  Offers</a>.
/// note:
/// If you’re looking to use Promotional Offers instead,
/// use <code>Purchases/getPromotionalOffer(forProductDiscount:product:completion:)</code>.
/// note:
/// Subscription groups are automatically collected for determining eligibility. If RevenueCat can’t
/// definitively compute the eligibility, most likely because of missing group information, it will return
/// <code>IntroEligibilityStatus/unknown</code>. The best course of action on unknown status is to display the non-intro
/// pricing, to not create a misleading situation. To avoid this, make sure you are testing with the latest
/// version of iOS so that the subscription group can be collected by the SDK.
/// <h3>Related symbols</h3>
/// <ul>
///   <li>
///     <code>Purchases/checkTrialOrIntroDiscountEligibility(productIdentifiers:completion:)</code>
///   </li>
/// </ul>
/// \param product The <code>StoreProduct</code>  for which you want to compute eligibility.
///
/// \param completion A block that receives an <code>IntroEligibilityStatus</code>.
///
- (void)checkTrialOrIntroDiscountEligibilityForProduct:(RCStoreProduct * _Nonnull)product completion:(void (^ _Nonnull)(enum RCIntroEligibilityStatus))completion;
/// Computes whether or not a user is eligible for the introductory pricing period of a given product.
/// You should use this method to determine whether or not you show the user the normal product price or
/// the introductory price. This also applies to trials (trials are considered a type of introductory pricing).
/// <a href="https://docs.revenuecat.com/docs/ios-subscription-offers">iOS Introductory  Offers</a>.
/// note:
/// If you’re looking to use Promotional Offers instead,
/// use <code>Purchases/getPromotionalOffer(forProductDiscount:product:completion:)</code>.
/// note:
/// Subscription groups are automatically collected for determining eligibility. If RevenueCat can’t
/// definitively compute the eligibility, most likely because of missing group information, it will return
/// <code>IntroEligibilityStatus/unknown</code>. The best course of action on unknown status is to display the non-intro
/// pricing, to not create a misleading situation. To avoid this, make sure you are testing with the latest
/// version of iOS so that the subscription group can be collected by the SDK.
/// <h3>Related symbols</h3>
/// <ul>
///   <li>
///     <code>Purchases/checkTrialOrIntroDiscountEligibility(productIdentifiers:)</code>
///   </li>
/// </ul>
/// \param product The <code>StoreProduct</code>  for which you want to compute eligibility.
///
- (void)checkTrialOrIntroDiscountEligibilityWithProduct:(RCStoreProduct * _Nonnull)product completionHandler:(void (^ _Nonnull)(enum RCIntroEligibilityStatus))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(ios,introduced=13.0);
/// Use this method to fetch <code>PromotionalOffer</code>
/// to use in <code>Purchases/purchase(package:promotionalOffer:)</code>
/// or <code>Purchases/purchase(product:promotionalOffer:)</code>.
/// <a href="https://docs.revenuecat.com/docs/ios-subscription-offers#promotional-offers">iOS Promotional Offers</a>.
/// note:
/// If you’re looking to use free trials or Introductory Offers instead,
/// use <code>Purchases/checkTrialOrIntroDiscountEligibility(productIdentifiers:completion:)</code>.
/// \param discount The <code>StoreProductDiscount</code> to apply to the product.
///
/// \param product The <code>StoreProduct</code> the user intends to purchase.
///
/// \param completion A completion block that is called when the <code>PromotionalOffer</code> is returned.
/// If it was not successful, there will be an <code>Error</code>.
///
- (void)getPromotionalOfferForProductDiscount:(RCStoreProductDiscount * _Nonnull)discount withProduct:(RCStoreProduct * _Nonnull)product withCompletion:(void (^ _Nonnull)(RCPromotionalOffer * _Nullable, NSError * _Nullable))completion SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=12.2) SWIFT_AVAILABILITY(maccatalyst,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.14.4) SWIFT_AVAILABILITY(ios,introduced=12.2);
/// Use this method to find eligibility for this user for
/// <a href="https://docs.revenuecat.com/docs/ios-subscription-offers#promotional-offers">iOS Promotional Offers</a>.
/// note:
/// If you’re looking to use free trials or Introductory Offers instead,
/// use <code>Purchases/checkTrialOrIntroDiscountEligibility(productIdentifiers:completion:)</code>.
/// \param discount The <code>StoreProductDiscount</code> to apply to the product.
///
/// \param product The <code>StoreProduct</code> the user intends to purchase.
///
- (void)promotionalOfferForProductDiscount:(RCStoreProductDiscount * _Nonnull)discount product:(RCStoreProduct * _Nonnull)product completionHandler:(void (^ _Nonnull)(RCPromotionalOffer * _Nullable, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
/// Finds the subset of <code>StoreProduct/discounts</code> that’s eligible for the current user.
/// note:
/// if checking for eligibility for a <code>StoreProductDiscount</code> fails (for example, if network is down),
/// that discount will fail silently and be considered not eligible.
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>Purchases/promotionalOffer(forProductDiscount:product:)</code>
///   </li>
///   <li>
///     <code>StoreProduct/eligiblePromotionalOffers()</code>
///   </li>
///   <li>
///     <code>StoreProduct/discounts</code>
///   </li>
/// </ul>
/// \param product the product to filter discounts from.
///
- (void)eligiblePromotionalOffersForProduct:(RCStoreProduct * _Nonnull)product completionHandler:(void (^ _Nonnull)(NSArray<RCPromotionalOffer *> * _Nonnull))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
/// Displays a sheet that enables users to redeem subscription offer codes that you generated in App Store Connect.
/// important:
/// Even though the docs in <code>SKPaymentQueue.presentCodeRedemptionSheet</code>
/// say that it’s available on Catalyst 14.0, there is a note:
/// “<code>This function doesn’t affect Mac apps built with Mac Catalyst.</code>”
/// when, in fact, it crashes when called both from Catalyst and also when running as “Designed for iPad”.
/// This is why RevenueCat’s SDK makes it unavailable in mac catalyst.
- (void)presentCodeRedemptionSheet SWIFT_AVAILABILITY(maccatalyst,unavailable) SWIFT_AVAILABILITY(macos,unavailable) SWIFT_AVAILABILITY(tvos,unavailable) SWIFT_AVAILABILITY(watchos,unavailable) SWIFT_AVAILABILITY(ios,introduced=14.0);
/// Use this function to open the manage subscriptions page.
/// If the manage subscriptions page can’t be opened, the <code>CustomerInfo/managementURL</code> in
/// the <code>CustomerInfo</code> will be opened. If <code>CustomerInfo/managementURL</code> is not available,
/// the App Store’s subscription management section will be opened.
/// The <code>completion</code> block will be called when the modal is opened, not when it’s actually closed.
/// This is because of an undocumented change in StoreKit’s behavior between iOS 15.0 and 15.2,
/// where 15.0 would return when the modal was closed,
/// and 15.2 returns when the modal is opened.
/// \param completion A completion block that will be called when the modal is opened,
/// not when it’s actually closed. This is because of an undocumented change in StoreKit’s behavior
/// between iOS 15.0 and 15.2, where 15.0 would return when the modal was closed, and 15.2 returns
/// when the modal is opened.
///
- (void)showManageSubscriptionsWithCompletion:(void (^ _Nonnull)(NSError * _Nullable))completion SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0) SWIFT_AVAILABILITY(tvos,unavailable) SWIFT_AVAILABILITY(watchos,unavailable);
/// Use this function to open the manage subscriptions modal.
///
/// throws:
/// an <code>Error</code> will be thrown if the current window scene couldn’t be opened,
/// or the <code>CustomerInfo/managementURL</code> couldn’t be obtained.
/// If the manage subscriptions page can’t be opened, the <code>CustomerInfo/managementURL</code> in
/// the <code>CustomerInfo</code> will be opened. If <code>CustomerInfo/managementURL</code> is not available,
/// the App Store’s subscription management section will be opened.
- (void)showManageSubscriptionsWithCompletionHandler:(void (^ _Nonnull)(NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0) SWIFT_AVAILABILITY(tvos,unavailable) SWIFT_AVAILABILITY(watchos,unavailable);
/// <code>Attribution</code> object that is responsible for all explicit attribution APIs
/// as well as subscriber attributes that RevenueCat offers.
/// <h4>Example:</h4>
/// \code
/// Purchases.shared.attribution.setEmail(“nobody@example.com”)
///
/// \endcode<h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/subscriber-attributes">Subscriber Attribution</a>
///   </li>
///   <li>
///     <code>Attribution</code>
///   </li>
/// </ul>
@property (nonatomic, readonly, strong) RCAttribution * _Nonnull attribution;
- (void)setAttributes:(NSDictionary<NSString *, NSString *> * _Nonnull)attributes;
@property (nonatomic) BOOL allowSharingAppStoreAccount SWIFT_DEPRECATED;
- (void)setEmail:(NSString * _Nullable)email SWIFT_DEPRECATED;
- (void)setPhoneNumber:(NSString * _Nullable)phoneNumber SWIFT_DEPRECATED;
- (void)setDisplayName:(NSString * _Nullable)displayName SWIFT_DEPRECATED;
- (void)setPushToken:(NSData * _Nullable)pushToken SWIFT_DEPRECATED;
- (void)setPushTokenString:(NSString * _Nullable)pushToken SWIFT_DEPRECATED;
- (void)setAdjustID:(NSString * _Nullable)adjustID SWIFT_DEPRECATED;
- (void)setAppsflyerID:(NSString * _Nullable)appsflyerID SWIFT_DEPRECATED;
- (void)setFBAnonymousID:(NSString * _Nullable)fbAnonymousID SWIFT_DEPRECATED;
- (void)setMparticleID:(NSString * _Nullable)mparticleID SWIFT_DEPRECATED;
- (void)setOnesignalID:(NSString * _Nullable)onesignalID SWIFT_DEPRECATED;
- (void)setMediaSource:(NSString * _Nullable)mediaSource SWIFT_DEPRECATED;
- (void)setCampaign:(NSString * _Nullable)campaign SWIFT_DEPRECATED;
- (void)setAdGroup:(NSString * _Nullable)adGroup SWIFT_DEPRECATED;
- (void)setAd:(NSString * _Nullable)value SWIFT_DEPRECATED;
- (void)setKeyword:(NSString * _Nullable)keyword SWIFT_DEPRECATED;
- (void)setCreative:(NSString * _Nullable)creative SWIFT_DEPRECATED;
- (void)setCleverTapID:(NSString * _Nullable)cleverTapID SWIFT_DEPRECATED;
- (void)setMixpanelDistinctID:(NSString * _Nullable)mixpanelDistinctID SWIFT_DEPRECATED;
- (void)setFirebaseAppInstanceID:(NSString * _Nullable)firebaseAppInstanceID SWIFT_DEPRECATED;
- (void)collectDeviceIdentifiers SWIFT_DEPRECATED;
@end


/// <code>Purchases</code> is the entry point for RevenueCat.framework. It should be instantiated as soon as your app has a unique
/// user id for your user. This can be when a user logs in if you have accounts or on launch if you can generate a random
/// user identifier.
/// warning:
/// Only one instance of Purchases should be instantiated at a time! Use a configure method to let the
/// framework handle the singleton instance for you.
SWIFT_CLASS_NAMED("Purchases")
@interface RCPurchases : NSObject <RCPurchasesType>
/// Returns the already configured instance of <code>Purchases</code>.
/// warning:
/// this method will crash with <code>fatalError</code> if <code>Purchases</code> has not been initialized through
/// <code>Purchases/configure(withAPIKey:)</code> or one of its overloads.
/// If there’s a chance that may have not happened yet, you can use <code>isConfigured</code> to check if it’s safe to call.
/// <h3>Related symbols</h3>
/// <ul>
///   <li>
///     <code>isConfigured</code>
///   </li>
/// </ul>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) RCPurchases * _Nonnull sharedPurchases;)
+ (RCPurchases * _Nonnull)sharedPurchases SWIFT_WARN_UNUSED_RESULT;
/// Returns <code>true</code> if RevenueCat has already been initialized through <code>Purchases/configure(withAPIKey:)</code>
/// or one of is overloads.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL isConfigured;)
+ (BOOL)isConfigured SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, strong) id <RCPurchasesDelegate> _Nullable delegate;
/// Used to set the log level. Useful for debugging issues with the lovely team @RevenueCat.
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>logHandler</code>
///   </li>
///   <li>
///     <code>verboseLogHandler</code>
///   </li>
/// </ul>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) enum RCLogLevel logLevel;)
+ (enum RCLogLevel)logLevel SWIFT_WARN_UNUSED_RESULT;
+ (void)setLogLevel:(enum RCLogLevel)newValue;
/// Set this property to your proxy URL before configuring <code>Purchases</code> <em>only</em> if you’ve received a proxy key value
/// from your RevenueCat contact.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSURL * _Nullable proxyURL;)
+ (NSURL * _Nullable)proxyURL SWIFT_WARN_UNUSED_RESULT;
+ (void)setProxyURL:(NSURL * _Nullable)newValue;
/// Set this property to true <em>only</em> if you’re transitioning an existing Mac app from the Legacy
/// Mac App Store into the Universal Store, and you’ve configured your RevenueCat app accordingly.
/// Contact RevenueCat support before using this.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL forceUniversalAppStore;)
+ (BOOL)forceUniversalAppStore SWIFT_WARN_UNUSED_RESULT;
+ (void)setForceUniversalAppStore:(BOOL)newValue;
/// Set this property to true <em>only</em> when testing the ask-to-buy / SCA purchases flow.
/// More information <a href="https://rev.cat/ask-to-buy">available here</a>.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://rev.cat/approve-kids-purchases-apple">Approve what kids buy with Ask to Buy</a>
///   </li>
/// </ul>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL simulatesAskToBuyInSandbox SWIFT_AVAILABILITY(maccatalyst,introduced=13.0) SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(macos,introduced=10.14) SWIFT_AVAILABILITY(ios,introduced=8.0);)
+ (BOOL)simulatesAskToBuyInSandbox SWIFT_WARN_UNUSED_RESULT;
+ (void)setSimulatesAskToBuyInSandbox:(BOOL)newValue;
/// Indicates whether the user is allowed to make payments.
/// <a href="https://rev.cat/can-make-payments-apple">More information on when this might be <code>false</code> here</a>
+ (BOOL)canMakePayments SWIFT_WARN_UNUSED_RESULT;
/// Set a custom log handler for redirecting logs to your own logging system.
/// By default, this sends <code>LogLevel/info</code>, <code>LogLevel/warn</code>, and <code>LogLevel/error</code> messages.
/// If you wish to receive Debug level messages, set the log level to <code>LogLevel/debug</code>.
/// note:
/// <code>verboseLogHandler</code> provides additional information.
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>verboseLogHandler</code>
///   </li>
///   <li>
///     <code>logLevel</code>
///   </li>
/// </ul>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) void (^ _Nonnull logHandler)(enum RCLogLevel, NSString * _Nonnull);)
+ (void (^ _Nonnull)(enum RCLogLevel, NSString * _Nonnull))logHandler SWIFT_WARN_UNUSED_RESULT;
+ (void)setLogHandler:(void (^ _Nonnull)(enum RCLogLevel, NSString * _Nonnull))newValue;
/// Set a custom log handler for redirecting logs to your own logging system.
/// By default, this sends <code>LogLevel/info</code>, <code>LogLevel/warn</code>, and <code>LogLevel/error</code> messages.
/// If you wish to receive Debug level messages, set the log level to <code>LogLevel/debug</code>.
/// note:
/// you can use <code>logHandler</code> if you don’t need filename information.
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>logHandler</code>
///   </li>
///   <li>
///     <code>logLevel</code>
///   </li>
/// </ul>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) void (^ _Nonnull verboseLogHandler)(enum RCLogLevel, NSString * _Nonnull, NSString * _Nullable, NSString * _Nullable, NSUInteger);)
+ (void (^ _Nonnull)(enum RCLogLevel, NSString * _Nonnull, NSString * _Nullable, NSString * _Nullable, NSUInteger))verboseLogHandler SWIFT_WARN_UNUSED_RESULT;
+ (void)setVerboseLogHandler:(void (^ _Nonnull)(enum RCLogLevel, NSString * _Nonnull, NSString * _Nullable, NSString * _Nullable, NSUInteger))newValue;
/// Setting this to <code>true</code> adds additional information to the default log handler:
/// Filename, line, and method data.
/// You can also access that information for your own logging system by using <code>verboseLogHandler</code>.
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>verboseLogHandler</code>
///   </li>
///   <li>
///     <code>logLevel</code>
///   </li>
/// </ul>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL verboseLogs;)
+ (BOOL)verboseLogs SWIFT_WARN_UNUSED_RESULT;
+ (void)setVerboseLogs:(BOOL)newValue;
/// Current version of the <code>Purchases</code> framework.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull frameworkVersion;)
+ (NSString * _Nonnull)frameworkVersion SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, strong) RCAttribution * _Nonnull attribution;
@property (nonatomic) BOOL finishTransactions;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end








SWIFT_PROTOCOL("_TtP10RevenueCat29PurchasesOrchestratorDelegate_")
@protocol PurchasesOrchestratorDelegate
- (void)readyForPromotedProduct:(RCStoreProduct * _Nonnull)product purchase:(void (^ _Nonnull)(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, NSError * _Nullable, BOOL)))startPurchase;
@property (nonatomic, readonly) BOOL shouldShowPriceConsent SWIFT_AVAILABILITY(watchos,unavailable) SWIFT_AVAILABILITY(tvos,unavailable) SWIFT_AVAILABILITY(macos,unavailable) SWIFT_AVAILABILITY(maccatalyst,introduced=13.4) SWIFT_AVAILABILITY(ios,introduced=13.4);
@end


@interface RCPurchases (SWIFT_EXTENSION(RevenueCat)) <PurchasesOrchestratorDelegate>
/// Called when a user initiates a promoted in-app purchase from the App Store.
/// If your app is able to handle a purchase at the current time, run the <code>startPurchase</code> block.
/// If the app is not in a state to make a purchase: cache the <code>startPurchase</code> block, then call it
/// when the app is ready to make the promoted purchase.
/// If the purchase should never be made, you don’t need to ever call the <code>startPurchase</code> block
/// and <code>Purchases</code> will not proceed with promoted purchases.
/// \param product <code>StoreProduct</code> the product that was selected from the app store.
///
/// \param startPurchase Method that begins the purchase flow for the promoted purchase.
/// If the app is ready to start the purchase flow when this delegate method is called, then this method
/// should be called right away. Otherwise, the method should be stored as a property in memory, and then called
/// once the app is ready to start the purchase flow.
/// When the purchase completes, the result will be part of the callback parameters.
///
- (void)readyForPromotedProduct:(RCStoreProduct * _Nonnull)product purchase:(void (^ _Nonnull)(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, NSError * _Nullable, BOOL)))startPurchase;
@end



@interface RCPurchases (SWIFT_EXTENSION(RevenueCat))
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) RCPlatformInfo * _Nullable platformInfo;)
+ (RCPlatformInfo * _Nullable)platformInfo SWIFT_WARN_UNUSED_RESULT;
+ (void)setPlatformInfo:(RCPlatformInfo * _Nullable)value;
@end


SWIFT_CLASS_NAMED("PlatformInfo")
@interface RCPlatformInfo : NSObject
- (nonnull instancetype)initWithFlavor:(NSString * _Nonnull)flavor version:(NSString * _Nonnull)version OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@interface RCPurchases (SWIFT_EXTENSION(RevenueCat))
- (void)logIn:(NSString * _Nonnull)appUserID completion:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, BOOL, NSError * _Nullable))completion;
- (void)logIn:(NSString * _Nonnull)appUserID completionHandler:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, BOOL, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
- (void)logOutWithCompletion:(void (^ _Nullable)(RCCustomerInfo * _Nullable, NSError * _Nullable))completion;
- (void)logOutWithCompletionHandler:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
@end


@interface RCPurchases (SWIFT_EXTENSION(RevenueCat))
/// Enable debug logging. Useful for debugging issues with the lovely team @RevenueCat.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL debugLogsEnabled SWIFT_DEPRECATED_MSG("use Purchases.logLevel instead");)
+ (BOOL)debugLogsEnabled SWIFT_WARN_UNUSED_RESULT;
+ (void)setDebugLogsEnabled:(BOOL)newValue;
/// Deprecated
@property (nonatomic) BOOL allowSharingAppStoreAccount SWIFT_DEPRECATED_MSG("Configure behavior through the RevenueCat dashboard instead");
/// Deprecated
+ (void)addAttributionData:(NSDictionary<NSString *, id> * _Nonnull)data fromNetwork:(enum RCAttributionNetwork)network SWIFT_DEPRECATED_MSG("Use the set<NetworkId> functions instead");
/// Send your attribution data to RevenueCat so you can track the revenue generated by your different campaigns.
/// <h4>Related articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/attribution">Attribution</a>
///   </li>
/// </ul>
/// \param data Dictionary provided by the network.
///
/// \param network Enum for the network the data is coming from, see <code>AttributionNetwork</code> for supported
/// networks.
///
/// \param networkUserId User Id that should be sent to the network. Default is the current App User Id.
///
+ (void)addAttributionData:(NSDictionary<NSString *, id> * _Nonnull)data fromNetwork:(enum RCAttributionNetwork)network forNetworkUserId:(NSString * _Nullable)networkUserId SWIFT_DEPRECATED_MSG("Use the set<NetworkId> functions instead");
@end



@interface RCPurchases (SWIFT_EXTENSION(RevenueCat))
/// Configures an instance of the Purchases SDK with a specified <code>Configuration</code>.
/// The instance will be set as a singleton.
/// You should access the singleton instance using <code>Purchases/shared</code>
/// important:
/// See <code>Configuration/Builder</code> for more information about configurable properties.
/// <h3>Example</h3>
/// \code
///  Purchases.configure(
///      with: Configuration.Builder(withAPIKey: Constants.apiKey)
///               .with(observerMode: false)
///               .with(appUserID: "<app_user_id>")
///               .build()
///      )
///
/// \endcode\param configuration The <code>Configuration</code> object you wish to use to configure <code>Purchases</code>
///
///
/// returns:
/// An instantiated <code>Purchases</code> object that has been set as a singleton.
+ (RCPurchases * _Nonnull)configureWithConfiguration:(RCConfiguration * _Nonnull)configuration;
/// Configures an instance of the Purchases SDK with a specified <code>Configuration/Builder</code>.
/// The instance will be set as a singleton.
/// You should access the singleton instance using <code>Purchases/shared</code>
/// important:
/// See <code>Configuration/Builder</code> for more information about configurable properties.
/// <h3>Example</h3>
/// \code
///  Purchases.configure(
///      with: .init(withAPIKey: Constants.apiKey)
///               .with(observerMode: false)
///               .with(appUserID: "<app_user_id>")
///      )
///
/// \endcode\param builder The <code>Configuration/Builder</code> object you wish to use to configure <code>Purchases</code>
///
///
/// returns:
/// An instantiated <code>Purchases</code> object that has been set as a singleton.
+ (RCPurchases * _Nonnull)configureWithConfigurationBuilder:(RCConfigurationBuilder * _Nonnull)builder;
/// Configures an instance of the Purchases SDK with a specified API key.
/// The instance will be set as a singleton.
/// You should access the singleton instance using <code>Purchases/shared</code>
/// note:
/// Use this initializer if your app does not have an account system.
/// <code>Purchases</code> will generate a unique identifier for the current device and persist it to <code>NSUserDefaults</code>.
/// This also affects the behavior of <code>Purchases/restorePurchases(completion:)</code>.
/// \param apiKey The API Key generated for your app from https://app.revenuecat.com/
///
///
/// returns:
/// An instantiated <code>Purchases</code> object that has been set as a singleton.
+ (RCPurchases * _Nonnull)configureWithAPIKey:(NSString * _Nonnull)apiKey;
/// Configures an instance of the Purchases SDK with a specified API key and app user ID.
/// The instance will be set as a singleton.
/// You should access the singleton instance using <code>Purchases/shared</code>
/// note:
/// Best practice is to use a salted hash of your unique app user ids.
/// warning:
/// Use this initializer if you have your own user identifiers that you manage.
/// \param apiKey The API Key generated for your app from https://app.revenuecat.com/
///
/// \param appUserID The unique app user id for this user. This user id will allow users to share their
/// purchases and subscriptions across devices. Pass <code>nil</code> or an empty string if you want <code>Purchases</code>
/// to generate this for you.
///
///
/// returns:
/// An instantiated <code>Purchases</code> object that has been set as a singleton.
+ (RCPurchases * _Nonnull)configureWithAPIKey:(NSString * _Nonnull)apiKey appUserID:(NSString * _Nullable)appUserID;
/// Configures an instance of the Purchases SDK with a custom <code>UserDefaults</code>.
/// Use this constructor if you want to
/// sync status across a shared container, such as between a host app and an extension. The instance of the
/// Purchases SDK will be set as a singleton.
/// You should access the singleton instance using <code>Purchases/shared</code>
/// warning:
/// This assumes your IAP implementation uses StoreKit 1.
/// Observer mode is not compatible with StoreKit 2.
/// \param apiKey The API Key generated for your app from https://app.revenuecat.com/
///
/// \param appUserID The unique app user id for this user. This user id will allow users to share their
/// purchases and subscriptions across devices. Pass <code>nil</code> or an empty string if you want <code>Purchases</code>
/// to generate this for you.
///
/// \param observerMode Set this to <code>true</code> if you have your own IAP implementation and want to use only
/// RevenueCat’s backend. Default is <code>false</code>.
///
///
/// returns:
/// An instantiated <code>Purchases</code> object that has been set as a singleton.
+ (RCPurchases * _Nonnull)configureWithAPIKey:(NSString * _Nonnull)apiKey appUserID:(NSString * _Nullable)appUserID observerMode:(BOOL)observerMode;
@end


@interface RCPurchases (SWIFT_EXTENSION(RevenueCat))
+ (RCPurchases * _Nonnull)configureWithAPIKey:(NSString * _Nonnull)apiKey appUserID:(NSString * _Nullable)appUserID observerMode:(BOOL)observerMode userDefaults:(NSUserDefaults * _Nullable)userDefaults SWIFT_AVAILABILITY(maccatalyst,deprecated=1,message="'configure' has been renamed to 'configure(with:)'") SWIFT_AVAILABILITY(macos,deprecated=1,message="'configure' has been renamed to 'configure(with:)'") SWIFT_AVAILABILITY(watchos,deprecated=1,message="'configure' has been renamed to 'configure(with:)'") SWIFT_AVAILABILITY(tvos,deprecated=1,message="'configure' has been renamed to 'configure(with:)'") SWIFT_AVAILABILITY(ios,deprecated=1,message="'configure' has been renamed to 'configure(with:)'");
+ (RCPurchases * _Nonnull)configureWithAPIKey:(NSString * _Nonnull)apiKey appUserID:(NSString * _Nullable)appUserID observerMode:(BOOL)observerMode userDefaults:(NSUserDefaults * _Nullable)userDefaults useStoreKit2IfAvailable:(BOOL)useStoreKit2IfAvailable SWIFT_AVAILABILITY(maccatalyst,deprecated=1,message="'configure' has been renamed to 'configure(with:)'") SWIFT_AVAILABILITY(macos,deprecated=1,message="'configure' has been renamed to 'configure(with:)'") SWIFT_AVAILABILITY(watchos,deprecated=1,message="'configure' has been renamed to 'configure(with:)'") SWIFT_AVAILABILITY(tvos,deprecated=1,message="'configure' has been renamed to 'configure(with:)'") SWIFT_AVAILABILITY(ios,deprecated=1,message="'configure' has been renamed to 'configure(with:)'");
+ (RCPurchases * _Nonnull)configureWithAPIKey:(NSString * _Nonnull)apiKey appUserID:(NSString * _Nullable)appUserID observerMode:(BOOL)observerMode userDefaults:(NSUserDefaults * _Nullable)userDefaults useStoreKit2IfAvailable:(BOOL)useStoreKit2IfAvailable dangerousSettings:(RCDangerousSettings * _Nullable)dangerousSettings SWIFT_AVAILABILITY(maccatalyst,deprecated=1,message="'configure' has been renamed to 'configure(with:)'") SWIFT_AVAILABILITY(macos,deprecated=1,message="'configure' has been renamed to 'configure(with:)'") SWIFT_AVAILABILITY(watchos,deprecated=1,message="'configure' has been renamed to 'configure(with:)'") SWIFT_AVAILABILITY(tvos,deprecated=1,message="'configure' has been renamed to 'configure(with:)'") SWIFT_AVAILABILITY(ios,deprecated=1,message="'configure' has been renamed to 'configure(with:)'");
/// Enable automatic collection of Apple Search Ads attribution. Defaults to <code>false</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL automaticAppleSearchAdsAttributionCollection SWIFT_DEPRECATED_MSG("Use Purchases.shared.attribution.enableAdServicesAttributionTokenCollection() instead");)
+ (BOOL)automaticAppleSearchAdsAttributionCollection SWIFT_WARN_UNUSED_RESULT;
+ (void)setAutomaticAppleSearchAdsAttributionCollection:(BOOL)value;
@end


@interface RCPurchases (SWIFT_EXTENSION(RevenueCat))
@property (nonatomic, readonly, copy) NSString * _Nonnull appUserID;
@property (nonatomic, readonly) BOOL isAnonymous;
- (void)getOfferingsWithCompletion:(void (^ _Nonnull)(RCOfferings * _Nullable, NSError * _Nullable))completion;
- (void)offeringsWithCompletionHandler:(void (^ _Nonnull)(RCOfferings * _Nullable, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
@property (nonatomic, readonly, strong) RCOfferings * _Nullable cachedOfferings;
@end





@interface RCPurchases (SWIFT_EXTENSION(RevenueCat))
- (void)collectDeviceIdentifiers SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'collectDeviceIdentifiers' has been renamed to 'attribution.collectDeviceIdentifiers()'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'collectDeviceIdentifiers' has been renamed to 'attribution.collectDeviceIdentifiers()'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'collectDeviceIdentifiers' has been renamed to 'attribution.collectDeviceIdentifiers()'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'collectDeviceIdentifiers' has been renamed to 'attribution.collectDeviceIdentifiers()'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'collectDeviceIdentifiers' has been renamed to 'attribution.collectDeviceIdentifiers()'");
- (void)setAttributes:(NSDictionary<NSString *, NSString *> * _Nonnull)attributes SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setAttributes' has been renamed to 'attribution.setAttributes(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setAttributes' has been renamed to 'attribution.setAttributes(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setAttributes' has been renamed to 'attribution.setAttributes(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setAttributes' has been renamed to 'attribution.setAttributes(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setAttributes' has been renamed to 'attribution.setAttributes(_:)'");
- (void)setEmail:(NSString * _Nullable)email SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setEmail' has been renamed to 'attribution.setEmail(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setEmail' has been renamed to 'attribution.setEmail(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setEmail' has been renamed to 'attribution.setEmail(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setEmail' has been renamed to 'attribution.setEmail(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setEmail' has been renamed to 'attribution.setEmail(_:)'");
- (void)setPhoneNumber:(NSString * _Nullable)phoneNumber SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setPhoneNumber' has been renamed to 'attribution.setPhoneNumber(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setPhoneNumber' has been renamed to 'attribution.setPhoneNumber(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setPhoneNumber' has been renamed to 'attribution.setPhoneNumber(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setPhoneNumber' has been renamed to 'attribution.setPhoneNumber(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setPhoneNumber' has been renamed to 'attribution.setPhoneNumber(_:)'");
- (void)setDisplayName:(NSString * _Nullable)displayName SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setDisplayName' has been renamed to 'attribution.setDisplayName(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setDisplayName' has been renamed to 'attribution.setDisplayName(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setDisplayName' has been renamed to 'attribution.setDisplayName(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setDisplayName' has been renamed to 'attribution.setDisplayName(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setDisplayName' has been renamed to 'attribution.setDisplayName(_:)'");
- (void)setPushToken:(NSData * _Nullable)pushToken SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setPushToken' has been renamed to 'attribution.setPushToken(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setPushToken' has been renamed to 'attribution.setPushToken(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setPushToken' has been renamed to 'attribution.setPushToken(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setPushToken' has been renamed to 'attribution.setPushToken(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setPushToken' has been renamed to 'attribution.setPushToken(_:)'");
- (void)setPushTokenString:(NSString * _Nullable)pushToken SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setPushTokenString' has been renamed to 'attribution.setPushTokenString(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setPushTokenString' has been renamed to 'attribution.setPushTokenString(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setPushTokenString' has been renamed to 'attribution.setPushTokenString(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setPushTokenString' has been renamed to 'attribution.setPushTokenString(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setPushTokenString' has been renamed to 'attribution.setPushTokenString(_:)'");
- (void)setAdjustID:(NSString * _Nullable)adjustID SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setAdjustID' has been renamed to 'attribution.setAdjustID(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setAdjustID' has been renamed to 'attribution.setAdjustID(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setAdjustID' has been renamed to 'attribution.setAdjustID(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setAdjustID' has been renamed to 'attribution.setAdjustID(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setAdjustID' has been renamed to 'attribution.setAdjustID(_:)'");
- (void)setAppsflyerID:(NSString * _Nullable)appsflyerID SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setAppsflyerID' has been renamed to 'attribution.setAppsflyerID(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setAppsflyerID' has been renamed to 'attribution.setAppsflyerID(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setAppsflyerID' has been renamed to 'attribution.setAppsflyerID(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setAppsflyerID' has been renamed to 'attribution.setAppsflyerID(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setAppsflyerID' has been renamed to 'attribution.setAppsflyerID(_:)'");
- (void)setFBAnonymousID:(NSString * _Nullable)fbAnonymousID SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setFBAnonymousID' has been renamed to 'attribution.setFBAnonymousID(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setFBAnonymousID' has been renamed to 'attribution.setFBAnonymousID(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setFBAnonymousID' has been renamed to 'attribution.setFBAnonymousID(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setFBAnonymousID' has been renamed to 'attribution.setFBAnonymousID(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setFBAnonymousID' has been renamed to 'attribution.setFBAnonymousID(_:)'");
- (void)setMparticleID:(NSString * _Nullable)mparticleID SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setMparticleID' has been renamed to 'attribution.setMparticleID(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setMparticleID' has been renamed to 'attribution.setMparticleID(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setMparticleID' has been renamed to 'attribution.setMparticleID(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setMparticleID' has been renamed to 'attribution.setMparticleID(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setMparticleID' has been renamed to 'attribution.setMparticleID(_:)'");
- (void)setOnesignalID:(NSString * _Nullable)onesignalID SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setOnesignalID' has been renamed to 'attribution.setOnesignalID(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setOnesignalID' has been renamed to 'attribution.setOnesignalID(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setOnesignalID' has been renamed to 'attribution.setOnesignalID(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setOnesignalID' has been renamed to 'attribution.setOnesignalID(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setOnesignalID' has been renamed to 'attribution.setOnesignalID(_:)'");
- (void)setAirshipChannelID:(NSString * _Nullable)airshipChannelID SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setAirshipChannelID' has been renamed to 'attribution.setAirshipChannelID(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setAirshipChannelID' has been renamed to 'attribution.setAirshipChannelID(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setAirshipChannelID' has been renamed to 'attribution.setAirshipChannelID(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setAirshipChannelID' has been renamed to 'attribution.setAirshipChannelID(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setAirshipChannelID' has been renamed to 'attribution.setAirshipChannelID(_:)'");
- (void)setCleverTapID:(NSString * _Nullable)cleverTapID SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setCleverTapID' has been renamed to 'attribution.setCleverTapID(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setCleverTapID' has been renamed to 'attribution.setCleverTapID(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setCleverTapID' has been renamed to 'attribution.setCleverTapID(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setCleverTapID' has been renamed to 'attribution.setCleverTapID(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setCleverTapID' has been renamed to 'attribution.setCleverTapID(_:)'");
- (void)setMixpanelDistinctID:(NSString * _Nullable)mixpanelDistinctID SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setMixpanelDistinctID' has been renamed to 'attribution.setMixpanelDistinctID(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setMixpanelDistinctID' has been renamed to 'attribution.setMixpanelDistinctID(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setMixpanelDistinctID' has been renamed to 'attribution.setMixpanelDistinctID(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setMixpanelDistinctID' has been renamed to 'attribution.setMixpanelDistinctID(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setMixpanelDistinctID' has been renamed to 'attribution.setMixpanelDistinctID(_:)'");
- (void)setFirebaseAppInstanceID:(NSString * _Nullable)firebaseAppInstanceID SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setFirebaseAppInstanceID' has been renamed to 'attribution.setFirebaseAppInstanceID(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setFirebaseAppInstanceID' has been renamed to 'attribution.setFirebaseAppInstanceID(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setFirebaseAppInstanceID' has been renamed to 'attribution.setFirebaseAppInstanceID(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setFirebaseAppInstanceID' has been renamed to 'attribution.setFirebaseAppInstanceID(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setFirebaseAppInstanceID' has been renamed to 'attribution.setFirebaseAppInstanceID(_:)'");
- (void)setMediaSource:(NSString * _Nullable)mediaSource SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setMediaSource' has been renamed to 'attribution.setMediaSource(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setMediaSource' has been renamed to 'attribution.setMediaSource(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setMediaSource' has been renamed to 'attribution.setMediaSource(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setMediaSource' has been renamed to 'attribution.setMediaSource(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setMediaSource' has been renamed to 'attribution.setMediaSource(_:)'");
- (void)setCampaign:(NSString * _Nullable)campaign SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setCampaign' has been renamed to 'attribution.setCampaign(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setCampaign' has been renamed to 'attribution.setCampaign(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setCampaign' has been renamed to 'attribution.setCampaign(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setCampaign' has been renamed to 'attribution.setCampaign(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setCampaign' has been renamed to 'attribution.setCampaign(_:)'");
- (void)setAdGroup:(NSString * _Nullable)adGroup SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setAdGroup' has been renamed to 'attribution.setAdGroup(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setAdGroup' has been renamed to 'attribution.setAdGroup(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setAdGroup' has been renamed to 'attribution.setAdGroup(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setAdGroup' has been renamed to 'attribution.setAdGroup(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setAdGroup' has been renamed to 'attribution.setAdGroup(_:)'");
- (void)setAd:(NSString * _Nullable)installAd SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setAd' has been renamed to 'attribution.setAd(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setAd' has been renamed to 'attribution.setAd(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setAd' has been renamed to 'attribution.setAd(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setAd' has been renamed to 'attribution.setAd(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setAd' has been renamed to 'attribution.setAd(_:)'");
- (void)setKeyword:(NSString * _Nullable)keyword SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setKeyword' has been renamed to 'attribution.setKeyword(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setKeyword' has been renamed to 'attribution.setKeyword(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setKeyword' has been renamed to 'attribution.setKeyword(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setKeyword' has been renamed to 'attribution.setKeyword(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setKeyword' has been renamed to 'attribution.setKeyword(_:)'");
- (void)setCreative:(NSString * _Nullable)creative SWIFT_AVAILABILITY(maccatalyst,deprecated=0.0.1,message="'setCreative' has been renamed to 'attribution.setCreative(_:)'") SWIFT_AVAILABILITY(macos,deprecated=0.0.1,message="'setCreative' has been renamed to 'attribution.setCreative(_:)'") SWIFT_AVAILABILITY(watchos,deprecated=0.0.1,message="'setCreative' has been renamed to 'attribution.setCreative(_:)'") SWIFT_AVAILABILITY(tvos,deprecated=0.0.1,message="'setCreative' has been renamed to 'attribution.setCreative(_:)'") SWIFT_AVAILABILITY(ios,deprecated=0.0.1,message="'setCreative' has been renamed to 'attribution.setCreative(_:)'");
@end

@class SKPaymentDiscount;
@class SKProductDiscount;

@interface RCPurchases (SWIFT_EXTENSION(RevenueCat))
/// This method will post all purchases associated with the current App Store account to RevenueCat and become
/// associated with the current <code>appUserID</code>. If the receipt is being used by an existing user, the current
/// <code>appUserID</code> will be aliased together with the <code>appUserID</code> of the existing user.
/// Going forward, either <code>appUserID</code> will be able to reference the same user.
/// You shouldn’t use this method if you have your own account system. In that case “restoration” is provided
/// by your app passing the same <code>appUserId</code> used to purchase originally.
/// note:
/// This may force your users to enter the App Store password so should only be performed on request of
/// the user. Typically with a button in settings or near your purchase UI. Use
/// <code>Purchases/syncPurchases(completion:)</code> if you need to restore transactions programmatically.
- (void)restoreTransactionsWithCompletionBlock:(void (^ _Nullable)(RCCustomerInfo * _Nullable, NSError * _Nullable))completion SWIFT_AVAILABILITY(macos,obsoleted=1,message="'restoreTransactions' has been renamed to 'restorePurchasesWithCompletion:'") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'restoreTransactions' has been renamed to 'restorePurchasesWithCompletion:'") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'restoreTransactions' has been renamed to 'restorePurchasesWithCompletion:'") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'restoreTransactions' has been renamed to 'restorePurchasesWithCompletion:'");
/// Get latest available purchaser info.
/// \param completion A completion block called when customer info is available and not stale.
/// Called immediately if info is cached. Customer info can be nil if an error occurred.
///
- (void)customerInfoWithCompletion:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, NSError * _Nullable))completion SWIFT_AVAILABILITY(macos,obsoleted=1,message="'customerInfo' has been renamed to 'getCustomerInfoWithCompletion:'") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'customerInfo' has been renamed to 'getCustomerInfoWithCompletion:'") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'customerInfo' has been renamed to 'getCustomerInfoWithCompletion:'") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'customerInfo' has been renamed to 'getCustomerInfoWithCompletion:'");
/// Get latest available purchaser info.
/// \param completion A completion block called when customer info is available and not stale.
/// Called immediately if info is cached. Customer info can be nil if an error occurred.
///
- (void)purchaserInfoWithCompletionBlock:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, NSError * _Nullable))completion SWIFT_AVAILABILITY(macos,obsoleted=1,message="'purchaserInfo' has been renamed to 'getCustomerInfoWithCompletion:'") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'purchaserInfo' has been renamed to 'getCustomerInfoWithCompletion:'") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'purchaserInfo' has been renamed to 'getCustomerInfoWithCompletion:'") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'purchaserInfo' has been renamed to 'getCustomerInfoWithCompletion:'");
/// Fetches the <code>SKProducts</code> for your IAPs for given <code>productIdentifiers</code>.
/// Use this method if you aren’t using <code>-offeringsWithCompletionBlock:</code>.
/// You should use offerings though.
/// note:
/// <code>completion</code> may be called without <code>SKProduct</code>s that you are expecting.
/// This is usually caused by iTunesConnect configuration errors.
/// Ensure your IAPs have the “Ready to Submit” status in iTunesConnect.
/// Also ensure that you have an active developer program subscription and you have
/// signed the latest paid application agreements.
/// If you’re having trouble see: https://www.revenuecat.com/2018/10/11/configuring-in-app-products-is-hard
/// \param productIdentifiers A set of product identifiers for in app purchases setup via iTunesConnect.
/// This should be either hard coded in your application, from a file, or from
/// a custom endpoint if you want to be able to deploy new IAPs without an app update.
///
/// \param completion An @escaping callback that is called with the loaded products.
/// If the fetch fails for any reason it will return an empty array.
///
- (void)productsWithIdentifiers:(NSArray<NSString *> * _Nonnull)productIdentifiers completionBlock:(void (^ _Nonnull)(NSArray<SKProduct *> * _Nonnull))completion SWIFT_AVAILABILITY(macos,obsoleted=1,message="'products' has been renamed to 'getProductsWithIdentifiers:completion:'") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'products' has been renamed to 'getProductsWithIdentifiers:completion:'") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'products' has been renamed to 'getProductsWithIdentifiers:completion:'") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'products' has been renamed to 'getProductsWithIdentifiers:completion:'");
/// Fetch the configured offerings for this users.
/// Offerings allows you to configure your in-app products via RevenueCat and greatly simplifies management.
/// Offerings will be fetched and cached on instantiation so that, by the time they are needed,
/// your prices are loaded for your purchase flow. Time is money.
/// <h4>Related Articles</h4>
/// <ul>
///   <li>
///     <a href="https://docs.revenuecat.com/docs/displaying-products">Displaying Products</a>
///   </li>
/// </ul>
/// \param completion A completion block called when offerings are available.
/// Called immediately if offerings are cached. Offerings will be nil if an error occurred.
///
- (void)offeringsWithCompletionBlock:(void (^ _Nonnull)(RCOfferings * _Nullable, NSError * _Nullable))completion SWIFT_AVAILABILITY(macos,obsoleted=1,message="'offerings' has been renamed to 'getOfferingsWithCompletion:'") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'offerings' has been renamed to 'getOfferingsWithCompletion:'") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'offerings' has been renamed to 'getOfferingsWithCompletion:'") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'offerings' has been renamed to 'getOfferingsWithCompletion:'");
/// Purchase the passed <code>Package</code>.
/// Call this method when a user has decided to purchase a product. Only call this in direct response to user input.
/// From here <code>Purchases</code> will handle the purchase with <code>StoreKit</code> and call the <code>RCPurchaseCompletedBlock</code>.
/// note:
/// You do not need to finish the transaction yourself in the completion callback,
/// Purchases will handle this for you.
/// \param package The <code>Package</code> the user intends to purchase
///
/// \param completion A completion block that is called when the purchase completes.
/// If the purchase was successful there will be a <code>SKPaymentTransaction</code> and a <code>RCPurchaserInfo</code>
/// If the purchase was not successful, there will be an <code>NSError</code>.
/// If the user cancelled, <code>userCancelled</code> will be <code>YES</code>.
///
- (void)purchasePackage:(RCPackage * _Nonnull)package withCompletionBlock:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, NSError * _Nullable, BOOL))completion SWIFT_AVAILABILITY(macos,obsoleted=1,message="'purchasePackage' has been renamed to 'purchasePackage:withCompletion:'") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'purchasePackage' has been renamed to 'purchasePackage:withCompletion:'") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'purchasePackage' has been renamed to 'purchasePackage:withCompletion:'") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'purchasePackage' has been renamed to 'purchasePackage:withCompletion:'");
/// Purchase the passed <code>Package</code>.
/// Call this method when a user has decided to purchase a product. Only call this in direct response to user input.
/// From here <code>Purchases</code> will handle the purchase with <code>StoreKit</code> and call the <code>RCPurchaseCompletedBlock</code>.
/// note:
/// You do not need to finish the transaction yourself in the completion callback,
/// Purchases will handle this for you.
/// \param package The <code>Package</code> the user intends to purchase
///
/// \param completion A completion block that is called when the purchase completes.
/// If the purchase was successful there will be a <code>SKPaymentTransaction</code> and a <code>RCPurchaserInfo</code>.
/// If the purchase was not successful, there will be an <code>NSError</code>.
/// If the user cancelled, <code>userCancelled</code> will be <code>YES</code>.
///
- (void)purchasePackage:(RCPackage * _Nonnull)package withDiscount:(SKPaymentDiscount * _Nonnull)discount completionBlock:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, NSError * _Nullable, BOOL))completion SWIFT_AVAILABILITY(maccatalyst,unavailable,message="'purchasePackage' has been renamed to 'purchasePackage:withPromotionalOffer:completion:'") SWIFT_AVAILABILITY(macos,unavailable,message="'purchasePackage' has been renamed to 'purchasePackage:withPromotionalOffer:completion:'") SWIFT_AVAILABILITY(watchos,unavailable,message="'purchasePackage' has been renamed to 'purchasePackage:withPromotionalOffer:completion:'") SWIFT_AVAILABILITY(tvos,unavailable,message="'purchasePackage' has been renamed to 'purchasePackage:withPromotionalOffer:completion:'") SWIFT_AVAILABILITY(ios,unavailable,message="'purchasePackage' has been renamed to 'purchasePackage:withPromotionalOffer:completion:'");
/// Use this function if you are not using the Offerings system to purchase an <code>SKProduct</code>.
/// If you are using the Offerings system, use <code>-[RCPurchases purchasePackage:withCompletionBlock]</code> instead.
/// Call this method when a user has decided to purchase a product. Only call this in direct response to user input.
/// From here <code>Purchases</code> will handle the purchase with <code>StoreKit</code> and call the <code>RCPurchaseCompletedBlock</code>.
/// note:
/// You do not need to finish the transaction yourself in the completion callback,
/// Purchases will handle this for you.
/// \param product The <code>SKProduct</code> the user intends to purchase
///
/// \param completion A completion block that is called when the purchase completes.
/// If the purchase was successful there will be a <code>SKPaymentTransaction</code> and a <code>RCPurchaserInfo</code>.
/// If the purchase was not successful, there will be an <code>NSError</code>.
/// If the user cancelled, <code>userCancelled</code> will be <code>YES</code>.
///
- (void)purchaseProduct:(SKProduct * _Nonnull)product withCompletionBlock:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, NSError * _Nullable, BOOL))completion SWIFT_AVAILABILITY(macos,obsoleted=1,message="'purchaseProduct' has been renamed to 'purchase(product:_:)'") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'purchaseProduct' has been renamed to 'purchase(product:_:)'") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'purchaseProduct' has been renamed to 'purchase(product:_:)'") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'purchaseProduct' has been renamed to 'purchase(product:_:)'");
/// Use this function if you are not using the Offerings system to purchase an <code>SKProduct</code>.
/// If you are using the Offerings system, use <code>-[RCPurchases purchasePackage:withCompletionBlock]</code> instead.
/// Call this method when a user has decided to purchase a product. Only call this in direct response to user input.
/// From here <code>Purchases</code> will handle the purchase with <code>StoreKit</code> and call the <code>RCPurchaseCompletedBlock</code>.
/// note:
/// You do not need to finish the transaction yourself in the completion callback,
/// Purchases will handle this for you.
/// \param product The <code>SKProduct</code> the user intends to purchase
///
/// \param completion A completion block that is called when the purchase completes.
/// If the purchase was successful there will be a <code>SKPaymentTransaction</code> and a <code>RCPurchaserInfo</code>.
/// If the purchase was not successful, there will be an <code>NSError</code>.
/// If the user cancelled, <code>userCancelled</code> will be <code>YES</code>.
///
- (void)purchaseProduct:(SKProduct * _Nonnull)product withDiscount:(SKPaymentDiscount * _Nonnull)discount completionBlock:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, NSError * _Nullable, BOOL))completion SWIFT_AVAILABILITY(maccatalyst,unavailable,message="'purchaseProduct' has been renamed to 'purchaseProduct:withPromotionalOffer:completion:'") SWIFT_AVAILABILITY(macos,unavailable,message="'purchaseProduct' has been renamed to 'purchaseProduct:withPromotionalOffer:completion:'") SWIFT_AVAILABILITY(watchos,unavailable,message="'purchaseProduct' has been renamed to 'purchaseProduct:withPromotionalOffer:completion:'") SWIFT_AVAILABILITY(tvos,unavailable,message="'purchaseProduct' has been renamed to 'purchaseProduct:withPromotionalOffer:completion:'") SWIFT_AVAILABILITY(ios,unavailable,message="'purchaseProduct' has been renamed to 'purchaseProduct:withPromotionalOffer:completion:'");
- (void)invalidatePurchaserInfoCache SWIFT_AVAILABILITY(maccatalyst,obsoleted=1,message="'invalidatePurchaserInfoCache' has been renamed to 'invalidateCustomerInfoCache'") SWIFT_AVAILABILITY(macos,obsoleted=1,message="'invalidatePurchaserInfoCache' has been renamed to 'invalidateCustomerInfoCache'") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'invalidatePurchaserInfoCache' has been renamed to 'invalidateCustomerInfoCache'") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'invalidatePurchaserInfoCache' has been renamed to 'invalidateCustomerInfoCache'") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'invalidatePurchaserInfoCache' has been renamed to 'invalidateCustomerInfoCache'");
/// Computes whether or not a user is eligible for the introductory pricing period of a given product.
/// You should use this method to determine whether or not you show the user the normal product price or
/// the introductory price. This also applies to trials (trials are considered a type of introductory pricing).
/// <a href="https://docs.revenuecat.com/docs/ios-subscription-offers">iOS Introductory  Offers</a>.
/// note:
/// If you’re looking to use Promotional Offers use instead,
/// use <code>Purchases/checkPromotionalDiscountEligibility(forProductDiscount:product:completion:)</code>.
/// note:
/// Subscription groups are automatically collected for determining eligibility. If RevenueCat can’t
/// definitively compute the eligibilty, most likely because of missing group information, it will return
/// <code>IntroEligibilityStatus/unknown</code>. The best course of action on unknown status is to display the non-intro
/// pricing, to not create a misleading situation. To avoid this, make sure you are testing with the latest
/// version of iOS so that the subscription group can be collected by the SDK.
/// \param productIdentifiers Array of product identifiers for which you want to compute eligibility
///
/// \param completion A block that receives a dictionary of product_id -> <code>IntroEligibility</code>.
///
- (void)checkTrialOrIntroductoryPriceEligibility:(NSArray<NSString *> * _Nonnull)productIdentifiers completion:(void (^ _Nonnull)(NSDictionary<NSString *, RCIntroEligibility *> * _Nonnull))completion SWIFT_AVAILABILITY(maccatalyst,obsoleted=1,message="'checkTrialOrIntroductoryPriceEligibility' has been renamed to 'checkTrialOrIntroDiscountEligibility(_:completion:)'") SWIFT_AVAILABILITY(macos,obsoleted=1,message="'checkTrialOrIntroductoryPriceEligibility' has been renamed to 'checkTrialOrIntroDiscountEligibility(_:completion:)'") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'checkTrialOrIntroductoryPriceEligibility' has been renamed to 'checkTrialOrIntroDiscountEligibility(_:completion:)'") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'checkTrialOrIntroductoryPriceEligibility' has been renamed to 'checkTrialOrIntroDiscountEligibility(_:completion:)'") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'checkTrialOrIntroductoryPriceEligibility' has been renamed to 'checkTrialOrIntroDiscountEligibility(_:completion:)'");
/// Use this function to retrieve the <code>SKPaymentDiscount</code> for a given <code>SKProduct</code>.
/// \param discount The <code>SKProductDiscount</code> to apply to the product.
///
/// \param product The <code>SKProduct</code> the user intends to purchase.
///
/// \param completion A completion block that is called when the <code>SKPaymentDiscount</code> is returned.
/// If it was not successful, there will be an <code>Error</code>.
///
- (void)paymentDiscountForProductDiscount:(SKProductDiscount * _Nonnull)discount product:(SKProduct * _Nonnull)product completion:(void (^ _Nonnull)(SKPaymentDiscount * _Nullable, NSError * _Nullable))completion SWIFT_AVAILABILITY(maccatalyst,unavailable,message="Check eligibility for a discount using getPromotionalOffer:") SWIFT_AVAILABILITY(macos,unavailable,message="Check eligibility for a discount using getPromotionalOffer:") SWIFT_AVAILABILITY(watchos,unavailable,message="Check eligibility for a discount using getPromotionalOffer:") SWIFT_AVAILABILITY(tvos,unavailable,message="Check eligibility for a discount using getPromotionalOffer:") SWIFT_AVAILABILITY(ios,unavailable,message="Check eligibility for a discount using getPromotionalOffer:");
- (void)shouldPurchasePromoProduct:(RCStoreProduct * _Nonnull)product defermentBlock:(void (^ _Nonnull)(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, NSError * _Nullable, BOOL)))defermentBlock SWIFT_AVAILABILITY(maccatalyst,obsoleted=1,message="This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`") SWIFT_AVAILABILITY(macos,obsoleted=1,message="This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`") SWIFT_AVAILABILITY(ios,obsoleted=1,message="This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`");
/// This function will alias two appUserIDs together.
/// \param alias The new appUserID that should be linked to the currently identified appUserID
///
/// \param completion An optional completion block called when the aliasing has been successful.
/// This completion block will receive an error if there’s been one.
///
- (void)createAlias:(NSString * _Nonnull)alias completionBlock:(void (^ _Nullable)(RCCustomerInfo * _Nullable, NSError * _Nullable))completion SWIFT_AVAILABILITY(macos,obsoleted=1,message="'createAlias' has been renamed to 'logIn:completionHandler:'") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'createAlias' has been renamed to 'logIn:completionHandler:'") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'createAlias' has been renamed to 'logIn:completionHandler:'") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'createAlias' has been renamed to 'logIn:completionHandler:'");
/// This function will identify the current user with an appUserID. Typically this would be used after a
/// logout to identify a new user without calling configure.
/// \param appUserID The appUserID that should be linked to the current user.
///
/// \param completion An optional completion block called when the identify call has completed.
/// This completion block will receive an error if there’s been one.
///
- (void)identify:(NSString * _Nonnull)appUserID completionBlock:(void (^ _Nullable)(RCCustomerInfo * _Nullable, NSError * _Nullable))completion SWIFT_AVAILABILITY(macos,obsoleted=1,message="'identify' has been renamed to 'logIn:completionHandler:'") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'identify' has been renamed to 'logIn:completionHandler:'") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'identify' has been renamed to 'logIn:completionHandler:'") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'identify' has been renamed to 'logIn:completionHandler:'");
/// Resets the Purchases client clearing the saved appUserID.
/// This will generate a random user id and save it in the cache.
- (void)resetWithCompletionBlock:(void (^ _Nullable)(RCCustomerInfo * _Nullable, NSError * _Nullable))completion SWIFT_AVAILABILITY(macos,obsoleted=1,message="'reset' has been renamed to 'logOutWithCompletionHandler:'") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'reset' has been renamed to 'logOutWithCompletionHandler:'") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'reset' has been renamed to 'logOutWithCompletionHandler:'") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'reset' has been renamed to 'logOutWithCompletionHandler:'");
@end


@interface RCPurchases (SWIFT_EXTENSION(RevenueCat))
- (void)getCustomerInfoWithCompletion:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, NSError * _Nullable))completion;
- (void)getCustomerInfoWithFetchPolicy:(enum RCCacheFetchPolicy)fetchPolicy completion:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, NSError * _Nullable))completion;
- (void)customerInfoWithCompletionHandler:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
- (void)customerInfoWithFetchPolicy:(enum RCCacheFetchPolicy)fetchPolicy completionHandler:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
@property (nonatomic, readonly, strong) RCCustomerInfo * _Nullable cachedCustomerInfo;
- (void)getProductsWithIdentifiers:(NSArray<NSString *> * _Nonnull)productIdentifiers completion:(void (^ _Nonnull)(NSArray<RCStoreProduct *> * _Nonnull))completion;
- (void)products:(NSArray<NSString *> * _Nonnull)productIdentifiers completionHandler:(void (^ _Nonnull)(NSArray<RCStoreProduct *> * _Nonnull))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
- (void)purchaseProduct:(RCStoreProduct * _Nonnull)product withCompletion:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, NSError * _Nullable, BOOL))completion;
- (void)purchaseWithProduct:(RCStoreProduct * _Nonnull)product completionHandler:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, BOOL, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
- (void)purchasePackage:(RCPackage * _Nonnull)package withCompletion:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, NSError * _Nullable, BOOL))completion;
- (void)purchaseWithPackage:(RCPackage * _Nonnull)package completionHandler:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, BOOL, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
- (void)restorePurchasesWithCompletion:(void (^ _Nullable)(RCCustomerInfo * _Nullable, NSError * _Nullable))completion;
- (void)restorePurchasesWithCompletionHandler:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
- (void)invalidateCustomerInfoCache;
- (void)syncPurchasesWithCompletion:(void (^ _Nullable)(RCCustomerInfo * _Nullable, NSError * _Nullable))completion;
- (void)syncPurchasesWithCompletionHandler:(void (^ _Nonnull)(RCCustomerInfo * _Nullable, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
- (void)purchaseProduct:(RCStoreProduct * _Nonnull)product withPromotionalOffer:(RCPromotionalOffer * _Nonnull)promotionalOffer completion:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, NSError * _Nullable, BOOL))completion SWIFT_AVAILABILITY(tvos,introduced=12.2) SWIFT_AVAILABILITY(maccatalyst,introduced=13.0) SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(macos,introduced=10.14.4) SWIFT_AVAILABILITY(ios,introduced=12.2);
- (void)purchaseWithProduct:(RCStoreProduct * _Nonnull)product promotionalOffer:(RCPromotionalOffer * _Nonnull)promotionalOffer completionHandler:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, BOOL, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
- (void)purchasePackage:(RCPackage * _Nonnull)package withPromotionalOffer:(RCPromotionalOffer * _Nonnull)promotionalOffer completion:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, NSError * _Nullable, BOOL))completion SWIFT_AVAILABILITY(tvos,introduced=12.2) SWIFT_AVAILABILITY(maccatalyst,introduced=13.0) SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(macos,introduced=10.14.4) SWIFT_AVAILABILITY(ios,introduced=12.2);
- (void)purchaseWithPackage:(RCPackage * _Nonnull)package promotionalOffer:(RCPromotionalOffer * _Nonnull)promotionalOffer completionHandler:(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, BOOL, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
- (void)checkTrialOrIntroDiscountEligibility:(NSArray<NSString *> * _Nonnull)productIdentifiers completion:(void (^ _Nonnull)(NSDictionary<NSString *, RCIntroEligibility *> * _Nonnull))completion;
- (void)checkTrialOrIntroDiscountEligibilityWithProductIdentifiers:(NSArray<NSString *> * _Nonnull)productIdentifiers completionHandler:(void (^ _Nonnull)(NSDictionary<NSString *, RCIntroEligibility *> * _Nonnull))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(ios,introduced=13.0);
- (void)checkTrialOrIntroDiscountEligibilityForProduct:(RCStoreProduct * _Nonnull)product completion:(void (^ _Nonnull)(enum RCIntroEligibilityStatus))completion;
- (void)checkTrialOrIntroDiscountEligibilityWithProduct:(RCStoreProduct * _Nonnull)product completionHandler:(void (^ _Nonnull)(enum RCIntroEligibilityStatus))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(ios,introduced=13.0);
- (void)getPromotionalOfferForProductDiscount:(RCStoreProductDiscount * _Nonnull)discount withProduct:(RCStoreProduct * _Nonnull)product withCompletion:(void (^ _Nonnull)(RCPromotionalOffer * _Nullable, NSError * _Nullable))completion SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=12.2) SWIFT_AVAILABILITY(maccatalyst,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.14.4) SWIFT_AVAILABILITY(ios,introduced=12.2);
- (void)promotionalOfferForProductDiscount:(RCStoreProductDiscount * _Nonnull)discount product:(RCStoreProduct * _Nonnull)product completionHandler:(void (^ _Nonnull)(RCPromotionalOffer * _Nullable, NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
- (void)eligiblePromotionalOffersForProduct:(RCStoreProduct * _Nonnull)product completionHandler:(void (^ _Nonnull)(NSArray<RCPromotionalOffer *> * _Nonnull))completionHandler SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
- (void)showManageSubscriptionsWithCompletion:(void (^ _Nonnull)(NSError * _Nullable))completion SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0) SWIFT_AVAILABILITY(tvos,unavailable) SWIFT_AVAILABILITY(watchos,unavailable);
- (void)showManageSubscriptionsWithCompletionHandler:(void (^ _Nonnull)(NSError * _Nullable))completionHandler SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0) SWIFT_AVAILABILITY(tvos,unavailable) SWIFT_AVAILABILITY(watchos,unavailable);
@end


/// Delegate for <code>Purchases</code> responsible for handling updating your app’s state in response to updated customer info
/// or promotional product purchases.
/// note:
/// Delegate methods can be called at any time after the <code>delegate</code> is set, not just in response to
/// <code>customerInfo:</code> calls. Ensure your app is capable of handling these calls at anytime if <code>delegate</code> is set.
SWIFT_PROTOCOL_NAMED("PurchasesDelegate")
@protocol RCPurchasesDelegate <NSObject>
@optional
/// note:
/// Deprecated, use purchases(_ purchases: Purchases, receivedUpdated customerInfo: CustomerInfo) or
/// objc: purchases:receivedUpdatedCustomerInfo:
- (void)purchases:(RCPurchases * _Nonnull)purchases didReceiveUpdatedPurchaserInfo:(RCCustomerInfo * _Nonnull)purchaserInfo SWIFT_AVAILABILITY(watchos,obsoleted=1) SWIFT_AVAILABILITY(tvos,obsoleted=1) SWIFT_AVAILABILITY(macos,obsoleted=1) SWIFT_AVAILABILITY(ios,obsoleted=1);
/// Called whenever <code>Purchases</code> receives updated customer info. This may happen periodically
/// throughout the life of the app if new information becomes available (e.g. UIApplicationDidBecomeActive).*
/// \param purchases Related <code>Purchases</code> object
///
/// \param customerInfo Updated <code>CustomerInfo</code>
///
- (void)purchases:(RCPurchases * _Nonnull)purchases receivedUpdatedCustomerInfo:(RCCustomerInfo * _Nonnull)customerInfo;
/// Called when a user initiates a promotional in-app purchase from the App Store.
/// If your app is able to handle a purchase at the current time, run the deferment block in this method.
/// If the app is not in a state to make a purchase: cache the <code>startPurchase</code> block,
/// then call the <code>startPurchase</code> block when the app is ready to make the promotional purchase.
/// If the purchase should never be made, you don’t need to ever call the block and
/// <code>Purchases</code> will not proceed with the promotional purchase.
/// This can be tested by opening a link like:
/// itms-services://?action=purchaseIntent&bundleId=<BUNDLE_ID>&productIdentifier=<SKPRODUCT_ID>
/// <h3>Related Articles:</h3>
/// <ul>
///   <li>
///     <a href="https://rev.cat/testing-promoted-in-app-purchases">Apple Documentation</a>
///   </li>
/// </ul>
/// \param product <code>StoreProduct</code> the product that was selected from the app store
///
/// \param startPurchase call this block when the app is ready to handle the purchase
///
- (void)purchases:(RCPurchases * _Nonnull)purchases readyForPromotedProduct:(RCStoreProduct * _Nonnull)product purchase:(void (^ _Nonnull)(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, NSError * _Nullable, BOOL)))startPurchase;
- (void)purchases:(RCPurchases * _Nonnull)purchases shouldPurchasePromoProduct:(RCStoreProduct * _Nonnull)product defermentBlock:(void (^ _Nonnull)(void (^ _Nonnull)(RCStoreTransaction * _Nullable, RCCustomerInfo * _Nullable, NSError * _Nullable, BOOL)))makeDeferredPurchase SWIFT_AVAILABILITY(maccatalyst,obsoleted=1,message="'purchases' has been renamed to 'purchases:readyForPromotedProduct:purchase:'") SWIFT_AVAILABILITY(macos,obsoleted=1,message="'purchases' has been renamed to 'purchases:readyForPromotedProduct:purchase:'") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'purchases' has been renamed to 'purchases:readyForPromotedProduct:purchase:'") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'purchases' has been renamed to 'purchases:readyForPromotedProduct:purchase:'") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'purchases' has been renamed to 'purchases:readyForPromotedProduct:purchase:'");
/// The default return value for this optional method is true. By default, the system displays the price consent
/// sheet when you increase the subscription price in App Store Connect and the subscriber hasn’t yet taken action.
/// The system calls your delegate’s method, if appropriate, when RevenueCat starts observing the <code>SKPaymentQueue</code>,
/// and any time the app comes to foreground.
/// If you return false, the system won’t show the price consent sheet. You can choose to display it later by
/// calling <code>Purchases/showPriceConsentIfNeeded()</code>.
/// You may want to delay showing the sheet if it would interrupt your user’s interaction in your app.
/// <h3>Related Articles</h3>
/// <ul>
///   <li>
///     <a href="https://rev.cat/testing-promoted-in-app-purchases">Apple Documentation</a>
///   </li>
/// </ul>
@property (nonatomic, readonly) BOOL shouldShowPriceConsent SWIFT_AVAILABILITY(watchos,unavailable) SWIFT_AVAILABILITY(tvos,unavailable) SWIFT_AVAILABILITY(macos,unavailable) SWIFT_AVAILABILITY(maccatalyst,introduced=13.4) SWIFT_AVAILABILITY(ios,introduced=13.4);
@end


/// <code>PurchasesDiagnostics</code> allows you to ensure that the SDK is set up correctly by diagnosing configuration errors.
/// To run the test, simply call <code>PurchasesDiagnostics/testSDKHealth()</code>.
/// <h4>Example:</h4>
/// \code
/// let diagnostics = PurchasesDiagnostics.default
/// do {
///     try await diagnostics.testSDKHealth()
/// } catch {
///     print("Diagnostics failed: \(error.localizedDescription)")
/// }
///
/// \endcode
SWIFT_CLASS_NAMED("PurchasesDiagnostics") SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0)
@interface RCPurchasesDiagnostics : NSObject
/// Default instance of <code>PurchasesDiagnostics</code>.
/// Note: you must call <code>Purchases/configure(with:)-6oipy</code> before using this.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong, getter=default) RCPurchasesDiagnostics * _Nonnull default_;)
+ (RCPurchasesDiagnostics * _Nonnull)default SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0)
@interface RCPurchasesDiagnostics (SWIFT_EXTENSION(RevenueCat))
/// Perform tests to ensure SDK is configured correctly.
/// <ul>
///   <li>
///     <code>Throws</code>: <code>PurchasesDiagnostics/Error</code> if any step fails
///   </li>
/// </ul>
- (void)testSDKHealthWithCompletion:(void (^ _Nonnull)(NSError * _Nullable))completionHandler;
@end





/// A type that can parse Apple receipts from a device.
/// This implements parsing based on <a href="https://rev.cat/apple-receipt-fields">Apple’s documentation</a>.
/// To use this class you must access <code>PurchasesReceiptParser/default</code>:
/// \code
/// let parser = PurchasesReceiptParser.default
/// let receipt = try parser.parse(from: data)
///
/// \endcode
SWIFT_CLASS("_TtC10RevenueCat22PurchasesReceiptParser")
@interface PurchasesReceiptParser : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end





@interface PurchasesReceiptParser (SWIFT_EXTENSION(RevenueCat))
- (BOOL)receiptHasTransactionsWithReceiptData:(NSData * _Nonnull)receiptData SWIFT_WARN_UNUSED_RESULT;
@end


@interface PurchasesReceiptParser (SWIFT_EXTENSION(RevenueCat))
/// A default instance of <code>PurchasesReceiptParser</code>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong, getter=default) PurchasesReceiptParser * _Nonnull default_;)
+ (PurchasesReceiptParser * _Nonnull)default SWIFT_WARN_UNUSED_RESULT;
@end




SWIFT_CLASS("_TtC10RevenueCat21RCPurchasesErrorUtils") SWIFT_AVAILABILITY(maccatalyst,obsoleted=1) SWIFT_AVAILABILITY(macos,obsoleted=1) SWIFT_AVAILABILITY(watchos,obsoleted=1) SWIFT_AVAILABILITY(tvos,obsoleted=1) SWIFT_AVAILABILITY(ios,obsoleted=1)
@interface RCPurchasesErrorUtils : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSURLSession;
@class NSURLSessionTask;
@class NSHTTPURLResponse;
@class NSURLRequest;

/// Implementation of <code>URLSessionTaskDelegate</code> that logs when the task will perform a redirection.
SWIFT_CLASS("_TtC10RevenueCat29RedirectLoggerSessionDelegate")
@interface RedirectLoggerSessionDelegate : NSObject <NSURLSessionTaskDelegate>
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task willPerformHTTPRedirection:(NSHTTPURLResponse * _Nonnull)response newRequest:(NSURLRequest * _Nonnull)request completionHandler:(void (^ _Nonnull)(NSURLRequest * _Nullable))completionHandler;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// Status codes for refund requests.
typedef SWIFT_ENUM_NAMED(NSInteger, RCRefundRequestStatus, "RefundRequestStatus", open) {
/// User canceled submission of the refund request.
  RCRefundRequestUserCancelled SWIFT_COMPILE_NAME("userCancelled") = 0,
/// Apple has received the refund request.
  RCRefundRequestSuccess SWIFT_COMPILE_NAME("success") = 1,
/// There was an error with the request. See message for more details.
  RCRefundRequestError SWIFT_COMPILE_NAME("error") = 2,
};








/// Enum of supported stores
typedef SWIFT_ENUM_NAMED(NSInteger, RCStore, "Store", open) {
/// For entitlements granted via Apple App Store.
  RCAppStore SWIFT_COMPILE_NAME("appStore") = 0,
/// For entitlements granted via Apple Mac App Store.
  RCMacAppStore SWIFT_COMPILE_NAME("macAppStore") = 1,
/// For entitlements granted via Google Play Store.
  RCPlayStore SWIFT_COMPILE_NAME("playStore") = 2,
/// For entitlements granted via Stripe.
  RCStripe SWIFT_COMPILE_NAME("stripe") = 3,
/// For entitlements granted via a promo in RevenueCat.
  RCPromotional SWIFT_COMPILE_NAME("promotional") = 4,
/// For entitlements granted via an unknown store.
  RCUnknownStore SWIFT_COMPILE_NAME("unknownStore") = 5,
/// For entitlements granted via the Amazon Store.
  RCAmazon SWIFT_COMPILE_NAME("amazon") = 6,
};


SWIFT_CLASS("_TtC10RevenueCat16StoreKit1Wrapper")
@interface StoreKit1Wrapper : NSObject
@property (nonatomic, readonly, strong) RCStorefront * _Nullable currentStorefront;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@interface StoreKit1Wrapper (SWIFT_EXTENSION(RevenueCat)) <SKPaymentQueueDelegate>
@end


@interface StoreKit1Wrapper (SWIFT_EXTENSION(RevenueCat)) <PaymentQueueWrapperType>
- (void)finishTransaction:(SKPaymentTransaction * _Nonnull)transaction completion:(void (^ _Nonnull)(void))completion;
@end


@interface StoreKit1Wrapper (SWIFT_EXTENSION(RevenueCat)) <SKPaymentTransactionObserver>
- (void)paymentQueue:(SKPaymentQueue * _Nonnull)queue updatedTransactions:(NSArray<SKPaymentTransaction *> * _Nonnull)transactions;
- (void)paymentQueue:(SKPaymentQueue * _Nonnull)queue removedTransactions:(NSArray<SKPaymentTransaction *> * _Nonnull)transactions;
- (BOOL)paymentQueue:(SKPaymentQueue * _Nonnull)queue shouldAddStorePayment:(SKPayment * _Nonnull)payment forProduct:(SKProduct * _Nonnull)product SWIFT_WARN_UNUSED_RESULT;
- (void)paymentQueue:(SKPaymentQueue * _Nonnull)queue didRevokeEntitlementsForProductIdentifiers:(NSArray<NSString *> * _Nonnull)productIdentifiers SWIFT_AVAILABILITY(watchos,introduced=7.0) SWIFT_AVAILABILITY(tvos,introduced=14.0) SWIFT_AVAILABILITY(macos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=14.0);
- (void)paymentQueueDidChangeStorefront:(SKPaymentQueue * _Nonnull)queue;
@end


SWIFT_CLASS("_TtC10RevenueCat22StoreKitRequestFetcher")
@interface StoreKitRequestFetcher : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




@interface StoreKitRequestFetcher (SWIFT_EXTENSION(RevenueCat)) <SKRequestDelegate>
- (void)requestDidFinish:(SKRequest * _Nonnull)request;
- (void)request:(SKRequest * _Nonnull)request didFailWithError:(NSError * _Nonnull)error;
@end

/// Type of messages available in StoreKit
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>Purchases/showStoreMessages(for:)</code>
///   </li>
/// </ul>
typedef SWIFT_ENUM_NAMED(NSInteger, RCStoreMessageType, "StoreMessageType", open) {
/// Message shown when there are billing issues in a subscription
  RCStoreMessageTypeBillingIssue = 0,
/// Message shown when there is a price increase in a subscription that requires consent
  RCStoreMessageTypePriceIncreaseConsent = 1,
/// Generic Store messages
  RCStoreMessageTypeGeneric = 2,
};

enum RCStoreProductType : NSInteger;
enum RCStoreProductCategory : NSInteger;
@class NSNumberFormatter;
@class RCSubscriptionPeriod;

/// Type that provides access to all of <code>StoreKit</code>‘s product type’s properties.
SWIFT_CLASS_NAMED("StoreProduct")
@interface RCStoreProduct : NSObject
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
@property (nonatomic, readonly) enum RCStoreProductType productType;
@property (nonatomic, readonly) enum RCStoreProductCategory productCategory;
@property (nonatomic, readonly, copy) NSString * _Nonnull localizedDescription;
@property (nonatomic, readonly, copy) NSString * _Nonnull localizedTitle;
@property (nonatomic, readonly, copy) NSString * _Nullable currencyCode;
@property (nonatomic, readonly, copy) NSString * _Nonnull localizedPriceString;
@property (nonatomic, readonly, copy) NSString * _Nonnull productIdentifier;
@property (nonatomic, readonly) BOOL isFamilyShareable SWIFT_AVAILABILITY(watchos,introduced=7.0) SWIFT_AVAILABILITY(tvos,introduced=14.0) SWIFT_AVAILABILITY(macos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=14.0);
@property (nonatomic, readonly, copy) NSString * _Nullable subscriptionGroupIdentifier SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(macos,introduced=10.14) SWIFT_AVAILABILITY(tvos,introduced=12.0) SWIFT_AVAILABILITY(maccatalyst,introduced=13.0) SWIFT_AVAILABILITY(ios,introduced=12.0);
@property (nonatomic, readonly, strong) NSNumberFormatter * _Nullable priceFormatter;
@property (nonatomic, readonly, strong) RCSubscriptionPeriod * _Nullable subscriptionPeriod SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=11.2) SWIFT_AVAILABILITY(macos,introduced=10.13.2) SWIFT_AVAILABILITY(ios,introduced=11.2);
@property (nonatomic, readonly, strong) RCStoreProductDiscount * _Nullable introductoryDiscount SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=11.2) SWIFT_AVAILABILITY(macos,introduced=10.13.2) SWIFT_AVAILABILITY(ios,introduced=11.2);
@property (nonatomic, readonly, copy) NSArray<RCStoreProductDiscount *> * _Nonnull discounts SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=12.2) SWIFT_AVAILABILITY(macos,introduced=10.14.4) SWIFT_AVAILABILITY(ios,introduced=12.2);
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




@interface RCStoreProduct (SWIFT_EXTENSION(RevenueCat))
@end

/// The category of a product, whether a subscription or a one-time purchase.
/// <h3>Related Symbols</h3>
/// <ul>
///   <li>
///     <code>StoreProduct/ProductType-swift.enum</code>
///   </li>
/// </ul>
typedef SWIFT_ENUM_NAMED(NSInteger, RCStoreProductCategory, "ProductCategory", open) {
/// A non-renewable or auto-renewable subscription.
  RCStoreProductCategorySubscription = 0,
/// A consumable or non-consumable in-app purchase.
  RCStoreProductCategoryNonSubscription = 1,
};

/// The type of product, equivalent to StoreKit’s <code>Product.ProductType</code>.
/// <h3>Related Symbols</h3>
/// <ul>
///   <li>
///     <code>StoreProduct/ProductCategory-swift.enum</code>
///   </li>
/// </ul>
typedef SWIFT_ENUM_NAMED(NSInteger, RCStoreProductType, "ProductType", open) {
/// A consumable in-app purchase.
  RCStoreProductTypeConsumable = 0,
/// A non-consumable in-app purchase.
  RCStoreProductTypeNonConsumable = 1,
/// A non-renewing subscription.
  RCStoreProductTypeNonRenewableSubscription = 2,
/// An auto-renewable subscription.
  RCStoreProductTypeAutoRenewableSubscription = 3,
};

@class NSLocale;

@interface RCStoreProduct (SWIFT_EXTENSION(RevenueCat))
/// The object containing introductory price information for the product.
@property (nonatomic, readonly, strong) SKProductDiscount * _Nullable introductoryPrice SWIFT_AVAILABILITY(macos,unavailable,message="'introductoryPrice' has been renamed to 'introductoryDiscount': Use StoreProductDiscount instead") SWIFT_AVAILABILITY(watchos,unavailable,message="'introductoryPrice' has been renamed to 'introductoryDiscount': Use StoreProductDiscount instead") SWIFT_AVAILABILITY(tvos,unavailable,message="'introductoryPrice' has been renamed to 'introductoryDiscount': Use StoreProductDiscount instead") SWIFT_AVAILABILITY(ios,unavailable,message="'introductoryPrice' has been renamed to 'introductoryDiscount': Use StoreProductDiscount instead");
/// The locale used to format the price of the product.
@property (nonatomic, readonly, copy) NSLocale * _Nonnull priceLocale SWIFT_AVAILABILITY(macos,unavailable,message="Use localizedPriceString instead") SWIFT_AVAILABILITY(watchos,unavailable,message="Use localizedPriceString instead") SWIFT_AVAILABILITY(tvos,unavailable,message="Use localizedPriceString instead") SWIFT_AVAILABILITY(ios,unavailable,message="Use localizedPriceString instead");
@end

@class NSDecimalNumber;

@interface RCStoreProduct (SWIFT_EXTENSION(RevenueCat))
/// The decimal representation of the cost of the product, in local currency.
/// For a string representation of the price to display to customers, use <code>localizedPriceString</code>.
/// note:
/// this is meant for  Objective-C. For Swift, use <code>price</code> instead.
/// <h4>Related Symbols</h4>
/// <ul>
///   <li>
///     <code>pricePerMonth</code>
///   </li>
///   <li>
///     <code>pricePerYear</code>
///   </li>
/// </ul>
@property (nonatomic, readonly, strong) NSDecimalNumber * _Nonnull price;
/// Calculates the price of this subscription product per month.
///
/// returns:
/// <code>nil</code> if the product is not a subscription.
@property (nonatomic, readonly, strong) NSDecimalNumber * _Nullable pricePerMonth SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=11.2) SWIFT_AVAILABILITY(macos,introduced=10.13.2) SWIFT_AVAILABILITY(ios,introduced=11.2);
/// Calculates the price of this subscription product per year.
///
/// returns:
/// <code>nil</code> if the product is not a subscription.
@property (nonatomic, readonly, strong) NSDecimalNumber * _Nullable pricePerYear SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=11.2) SWIFT_AVAILABILITY(macos,introduced=10.13.2) SWIFT_AVAILABILITY(ios,introduced=11.2);
/// The price of the <code>introductoryPrice</code> formatted using <code>priceFormatter</code>.
///
/// returns:
/// <code>nil</code> if there is no <code>introductoryPrice</code>.
@property (nonatomic, readonly, copy) NSString * _Nullable localizedIntroductoryPriceString;
@end


@interface RCStoreProduct (SWIFT_EXTENSION(RevenueCat))
- (nonnull instancetype)initWithSk1Product:(SKProduct * _Nonnull)sk1Product;
/// Returns the <code>SKProduct</code> if this <code>StoreProduct</code> represents a <code>StoreKit.SKProduct</code>.
@property (nonatomic, readonly, strong) SKProduct * _Nullable sk1Product;
@end

enum RCPaymentMode : NSInteger;
enum RCDiscountType : NSInteger;

/// Type that wraps <code>StoreKit.Product.SubscriptionOffer</code> and <code>SKProductDiscount</code>
/// and provides access to their properties.
/// Information about a subscription offer that you configured in App Store Connect.
SWIFT_CLASS_NAMED("StoreProductDiscount")
@interface RCStoreProductDiscount : NSObject
@property (nonatomic, readonly, copy) NSString * _Nullable offerIdentifier;
@property (nonatomic, readonly, copy) NSString * _Nullable currencyCode;
@property (nonatomic, readonly, copy) NSString * _Nonnull localizedPriceString;
@property (nonatomic, readonly) enum RCPaymentMode paymentMode;
@property (nonatomic, readonly, strong) RCSubscriptionPeriod * _Nonnull subscriptionPeriod;
@property (nonatomic, readonly) NSInteger numberOfPeriods;
@property (nonatomic, readonly) enum RCDiscountType type;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The payment mode for a <code>StoreProductDiscount</code>
/// Indicates how the product discount price is charged.
typedef SWIFT_ENUM_NAMED(NSInteger, RCPaymentMode, "PaymentMode", open) {
/// Price is charged one or more times
  RCPaymentModePayAsYouGo = 0,
/// Price is charged once in advance
  RCPaymentModePayUpFront = 1,
/// No initial charge
  RCPaymentModeFreeTrial = 2,
};

/// The discount type for a <code>StoreProductDiscount</code>
/// Wraps <code>SKProductDiscount.Type</code> if this <code>StoreProductDiscount</code> represents a <code>SKProductDiscount</code>.
/// Wraps  <code>Product.SubscriptionOffer.OfferType</code> if this <code>StoreProductDiscount</code> represents
/// a <code>Product.SubscriptionOffer</code>.
typedef SWIFT_ENUM_NAMED(NSInteger, RCDiscountType, "DiscountType", open) {
/// Introductory offer
  RCDiscountTypeIntroductory = 0,
/// Promotional offer for subscriptions
  RCDiscountTypePromotional = 1,
};




@interface RCStoreProductDiscount (SWIFT_EXTENSION(RevenueCat))
/// The discount price of the product in the local currency.
/// note:
/// this is meant for  Objective-C. For Swift, use <code>price</code> instead.
@property (nonatomic, readonly, strong) NSDecimalNumber * _Nonnull price;
@end




@interface RCStoreProductDiscount (SWIFT_EXTENSION(RevenueCat))
/// Returns the <code>SK1ProductDiscount</code> if this <code>StoreProductDiscount</code> represents a <code>SKProductDiscount</code>.
@property (nonatomic, readonly, strong) SKProductDiscount * _Nullable sk1Discount SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=12.2) SWIFT_AVAILABILITY(macos,introduced=10.14.4) SWIFT_AVAILABILITY(ios,introduced=12.2);
@end


/// Abstract class that provides access to properties of a transaction.
/// <code>StoreTransaction</code>s can represent transactions from StoreKit 1, StoreKit 2 or
/// transactions made from other places, like Stripe, Google Play or Amazon Store.
SWIFT_CLASS_NAMED("StoreTransaction")
@interface RCStoreTransaction : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull productIdentifier;
@property (nonatomic, readonly, copy) NSDate * _Nonnull purchaseDate;
@property (nonatomic, readonly, copy) NSString * _Nonnull transactionIdentifier;
@property (nonatomic, readonly) NSInteger quantity;
@property (nonatomic, readonly, strong) RCStorefront * _Nullable storefront;
@property (nonatomic, readonly, copy) NSString * _Nullable jwsRepresentation;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@interface RCStoreTransaction (SWIFT_EXTENSION(RevenueCat))
@property (nonatomic, readonly, copy) NSString * _Nonnull productId SWIFT_AVAILABILITY(macos,obsoleted=1,message="'productId' has been renamed to 'productIdentifier'") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'productId' has been renamed to 'productIdentifier'") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'productId' has been renamed to 'productIdentifier'") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'productId' has been renamed to 'productIdentifier'");
@property (nonatomic, readonly, copy) NSString * _Nonnull revenueCatId SWIFT_AVAILABILITY(macos,obsoleted=1,message="'revenueCatId' has been renamed to 'transactionIdentifier'") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'revenueCatId' has been renamed to 'transactionIdentifier'") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'revenueCatId' has been renamed to 'transactionIdentifier'") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'revenueCatId' has been renamed to 'transactionIdentifier'");
@end


@interface RCStoreTransaction (SWIFT_EXTENSION(RevenueCat))
/// Returns the <code>SKPaymentTransaction</code> if this <code>StoreTransaction</code> represents a <code>SKPaymentTransaction</code>.
@property (nonatomic, readonly, strong) SKPaymentTransaction * _Nullable sk1Transaction;
@end


/// An object containing the location and unique identifier of an Apple App Store storefront.
/// note:
/// Don’t save the storefront information with your user information; storefront information can change
/// at any time. Always get the storefront identifier immediately before you display product information or availability
/// to the user in your app. Storefront information may not be used to develop or enhance a user profile,
/// or track customers for advertising or marketing purposes.
SWIFT_CLASS_NAMED("Storefront")
@interface RCStorefront : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull countryCode;
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@class SKStorefront;

@interface RCStorefront (SWIFT_EXTENSION(RevenueCat))
/// Returns the <code>SKStorefront</code> if this <code>Storefront</code> represents an <code>SKStorefront</code>.
@property (nonatomic, readonly, strong) SKStorefront * _Nullable sk1Storefront SWIFT_AVAILABILITY(maccatalyst,introduced=13.1) SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);
@end


@interface RCStorefront (SWIFT_EXTENSION(RevenueCat))
/// The current App Store storefront for the device obtained from StoreKit 1 only.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) RCStorefront * _Nullable sk1CurrentStorefront SWIFT_AVAILABILITY(maccatalyst,introduced=13.1) SWIFT_AVAILABILITY(watchos,introduced=6.2) SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13.0);)
+ (RCStorefront * _Nullable)sk1CurrentStorefront SWIFT_WARN_UNUSED_RESULT;
@end

enum RCSubscriptionPeriodUnit : NSInteger;

/// The duration of time between subscription renewals.
/// Use the value and the unit together to determine the subscription period.
/// For example, if the unit is  <code>.month</code>, and the value is <code>3</code>, the subscription period is three months.
SWIFT_CLASS_NAMED("SubscriptionPeriod")
@interface RCSubscriptionPeriod : NSObject
/// The number of period units.
@property (nonatomic, readonly) NSInteger value;
/// The increment of time that a subscription period is specified in.
@property (nonatomic, readonly) enum RCSubscriptionPeriodUnit unit;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Units of time used to describe subscription periods.
typedef SWIFT_ENUM_NAMED(NSInteger, RCSubscriptionPeriodUnit, "Unit", open) {
/// A subscription period unit of a day.
  RCSubscriptionPeriodUnitDay = 0,
/// A subscription period unit of a week.
  RCSubscriptionPeriodUnitWeek = 1,
/// A subscription period unit of a month.
  RCSubscriptionPeriodUnitMonth = 2,
/// A subscription period unit of a year.
  RCSubscriptionPeriodUnitYear = 3,
};





@interface RCSubscriptionPeriod (SWIFT_EXTENSION(RevenueCat))
/// The number of units per subscription period
@property (nonatomic, readonly) NSInteger numberOfUnits SWIFT_AVAILABILITY(macos,unavailable,message="'numberOfUnits' has been renamed to 'value'") SWIFT_AVAILABILITY(watchos,unavailable,message="'numberOfUnits' has been renamed to 'value'") SWIFT_AVAILABILITY(tvos,unavailable,message="'numberOfUnits' has been renamed to 'value'") SWIFT_AVAILABILITY(ios,unavailable,message="'numberOfUnits' has been renamed to 'value'");
@end


@interface RCSubscriptionPeriod (SWIFT_EXTENSION(RevenueCat))
@property (nonatomic, readonly, copy) NSString * _Nonnull debugDescription;
@end



SWIFT_CLASS("_TtC10RevenueCat20TrackingManagerProxy")
@interface TrackingManagerProxy : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull authorizationStatusPropertyName;
- (NSInteger)trackingAuthorizationStatus SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("Transaction") SWIFT_AVAILABILITY(macos,obsoleted=1,message="'Transaction' has been renamed to 'RCStoreTransaction'") SWIFT_AVAILABILITY(watchos,obsoleted=1,message="'Transaction' has been renamed to 'RCStoreTransaction'") SWIFT_AVAILABILITY(tvos,obsoleted=1,message="'Transaction' has been renamed to 'RCStoreTransaction'") SWIFT_AVAILABILITY(ios,obsoleted=1,message="'Transaction' has been renamed to 'RCStoreTransaction'")
@interface RCTransaction : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end





/// The result of data verification process.
/// This is accomplished by preventing MiTM attacks between the SDK and the RevenueCat server.
/// With verification enabled, the SDK ensures that the response created by the server was not
/// modified by a third-party, and the entitlements received are exactly what was sent.
/// note:
/// Entitlements are only verified if enabled using
/// <code>Configuration/Builder/with(entitlementVerificationMode:)</code>, which is disabled by default.
/// <h3>Example:</h3>
/// \code
/// let purchases = Purchases.configure(
///   with: Configuration
///     .builder(withAPIKey: "")
///     .with(entitlementVerificationMode: .informational)
/// )
///
/// let customerInfo = try await purchases.customerInfo()
/// if !customerInfo.entitlements.verification.isVerified {
///   print("Entitlements could not be verified")
/// }
///
/// \endcode<h3>Related Articles</h3>
/// <ul>
///   <li>
///     <a href="https://rev.cat/trusted-entitlements">Documentation</a>
///   </li>
/// </ul>
/// <h3>Related Symbols</h3>
/// <ul>
///   <li>
///     <code>Configuration/EntitlementVerificationMode</code>
///   </li>
///   <li>
///     <code>Configuration/Builder/with(entitlementVerificationMode:)</code>
///   </li>
///   <li>
///     <code>EntitlementInfos/verification</code>
///   </li>
/// </ul>
typedef SWIFT_ENUM_NAMED(NSInteger, RCVerificationResult, "VerificationResult", open) {
/// No verification was done.
/// This can happen for multiple reasons:
/// <ol>
///   <li>
///     Verification is not enabled in <code>Configuration</code>
///   </li>
///   <li>
///     Verification can’t be performed prior to iOS 13.0
///   </li>
/// </ol>
  RCVerificationResultNotRequested = 0,
/// Entitlements were verified with our server.
  RCVerificationResultVerified = 1,
/// Entitlements were created and verified on device through <code>StoreKit 2</code>.
  RCVerificationResultVerifiedOnDevice = 3,
/// Entitlement verification failed, possibly due to a MiTM attack.
/// <h3>Related Symbols</h3>
/// <ul>
///   <li>
///     <code>ErrorCode/signatureVerificationFailed</code>
///   </li>
/// </ul>
  RCVerificationResultFailed = 2,
};

#endif
#if defined(__cplusplus)
#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif
