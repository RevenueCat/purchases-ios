// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1 effective-5.10 (swiftlang-6.1.0.110.21 clang-1700.0.13.3)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name RevenueCat
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -interface-compiler-version 6.1
import AdServices
import Combine
import CommonCrypto
import CoreText
import CryptoKit
import Foundation
@_exported import RevenueCat
import StoreKit
import Swift
import SwiftUI
import UIKit
import _Concurrency
import _StoreKit_SwiftUI
import _StringProcessing
import _SwiftConcurrencyShims
import os
@_hasMissingDesignatedInitializers @objc(RCOffering) final public class Offering : ObjectiveC.NSObject {
  public struct PaywallComponents {
    public let uiConfig: RevenueCat.UIConfig
    public let data: RevenueCat.PaywallComponentsData
    public init(uiConfig: RevenueCat.UIConfig, data: RevenueCat.PaywallComponentsData)
  }
  @objc final public let identifier: Swift.String
  @objc final public let serverDescription: Swift.String
  @objc final public var metadata: [Swift.String : Any] {
    @objc get
  }
  final public let paywall: RevenueCat.PaywallData?
  final public let paywallComponents: RevenueCat.Offering.PaywallComponents?
  final public var hasPaywall: Swift.Bool {
    get
  }
  @objc final public let availablePackages: [RevenueCat.Package]
  @objc final public let lifetime: RevenueCat.Package?
  @objc final public let annual: RevenueCat.Package?
  @objc final public let sixMonth: RevenueCat.Package?
  @objc final public let threeMonth: RevenueCat.Package?
  @objc final public let twoMonth: RevenueCat.Package?
  @objc final public let monthly: RevenueCat.Package?
  @objc final public let weekly: RevenueCat.Package?
  @objc final public let webCheckoutUrl: Foundation.URL?
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc final public func package(identifier: Swift.String?) -> RevenueCat.Package?
  @objc final public subscript(key: Swift.String) -> RevenueCat.Package? {
    @objc get
  }
  @objc convenience public init(identifier: Swift.String, serverDescription: Swift.String, metadata: [Swift.String : Any] = [:], availablePackages: [RevenueCat.Package], webCheckoutUrl: Foundation.URL?)
  convenience public init(identifier: Swift.String, serverDescription: Swift.String, metadata: [Swift.String : Any] = [:], paywall: RevenueCat.PaywallData? = nil, paywallComponents: RevenueCat.Offering.PaywallComponents? = nil, availablePackages: [RevenueCat.Package], webCheckoutUrl: Foundation.URL?)
  @objc deinit
}
extension RevenueCat.Offering {
  final public func getMetadataValue<T>(for key: Swift.String, default: T) -> T
  final public func getMetadataValue<T>(for key: Swift.String) -> T? where T : Swift.Decodable
}
extension RevenueCat.Offering : Swift.Identifiable {
  final public var id: Swift.String {
    get
  }
  public typealias ID = Swift.String
}
extension RevenueCat.Offering.PaywallComponents : Swift.Sendable {
}
extension RevenueCat.Offering : Swift.Sendable {
}
extension RevenueCat.PaywallComponent {
  final public class ImageComponent : RevenueCat.PaywallComponentBase {
    final public let visible: Swift.Bool?
    final public let source: RevenueCat.PaywallComponent.ThemeImageUrls
    final public let size: RevenueCat.PaywallComponent.Size
    final public let overrideSourceLid: RevenueCat.PaywallComponent.LocalizationKey?
    final public let fitMode: RevenueCat.PaywallComponent.FitMode
    final public let maskShape: RevenueCat.PaywallComponent.MaskShape?
    final public let colorOverlay: RevenueCat.PaywallComponent.ColorScheme?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialImageComponent>?
    public init(visible: Swift.Bool? = nil, source: RevenueCat.PaywallComponent.ThemeImageUrls, size: RevenueCat.PaywallComponent.Size = .init(width: .fill, height: .fit), overrideSourceLid: RevenueCat.PaywallComponent.LocalizationKey? = nil, fitMode: RevenueCat.PaywallComponent.FitMode = .fit, maskShape: RevenueCat.PaywallComponent.MaskShape? = nil, colorOverlay: RevenueCat.PaywallComponent.ColorScheme? = nil, padding: RevenueCat.PaywallComponent.Padding? = nil, margin: RevenueCat.PaywallComponent.Padding? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil, overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialImageComponent>? = nil)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.ImageComponent, rhs: RevenueCat.PaywallComponent.ImageComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class PartialImageComponent : RevenueCat.PaywallPartialComponent {
    final public let visible: Swift.Bool?
    final public let source: RevenueCat.PaywallComponent.ThemeImageUrls?
    final public let size: RevenueCat.PaywallComponent.Size?
    final public let overrideSourceLid: RevenueCat.PaywallComponent.LocalizationKey?
    final public let maskShape: RevenueCat.PaywallComponent.MaskShape?
    final public let fitMode: RevenueCat.PaywallComponent.FitMode?
    final public let colorOverlay: RevenueCat.PaywallComponent.ColorScheme?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    public init(visible: Swift.Bool? = true, source: RevenueCat.PaywallComponent.ThemeImageUrls? = nil, size: RevenueCat.PaywallComponent.Size? = nil, overrideSourceLid: RevenueCat.PaywallComponent.LocalizationKey? = nil, fitMode: RevenueCat.PaywallComponent.FitMode? = nil, maskShape: RevenueCat.PaywallComponent.MaskShape? = nil, colorOverlay: RevenueCat.PaywallComponent.ColorScheme? = nil, padding: RevenueCat.PaywallComponent.Padding? = nil, margin: RevenueCat.PaywallComponent.Padding? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PartialImageComponent, rhs: RevenueCat.PaywallComponent.PartialImageComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
public enum PaywallEvent {
  public typealias ID = Foundation.UUID
  public typealias SessionID = Foundation.UUID
  case impression(RevenueCat.PaywallEvent.CreationData, RevenueCat.PaywallEvent.Data)
  case cancel(RevenueCat.PaywallEvent.CreationData, RevenueCat.PaywallEvent.Data)
  case close(RevenueCat.PaywallEvent.CreationData, RevenueCat.PaywallEvent.Data)
}
extension RevenueCat.PaywallEvent {
  public struct CreationData {
    public var id: RevenueCat.PaywallEvent.ID
    public var date: Foundation.Date
    public init(id: RevenueCat.PaywallEvent.ID = .init(), date: Foundation.Date = .init())
  }
}
extension RevenueCat.PaywallEvent {
  public struct Data {
    public var offeringIdentifier: Swift.String
    public var paywallRevision: Swift.Int
    public var sessionIdentifier: RevenueCat.PaywallEvent.SessionID
    public var displayMode: RevenueCat.PaywallViewMode
    public var localeIdentifier: Swift.String
    public var darkMode: Swift.Bool
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    public init(offering: RevenueCat.Offering, paywallComponentsData: RevenueCat.PaywallComponentsData, sessionID: RevenueCat.PaywallEvent.SessionID, displayMode: RevenueCat.PaywallViewMode, locale: Foundation.Locale, darkMode: Swift.Bool)
    @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
    public init(offering: RevenueCat.Offering, paywall: RevenueCat.PaywallData, sessionID: RevenueCat.PaywallEvent.SessionID, displayMode: RevenueCat.PaywallViewMode, locale: Foundation.Locale, darkMode: Swift.Bool)
  }
}
extension RevenueCat.PaywallEvent {
  public var creationData: RevenueCat.PaywallEvent.CreationData {
    get
  }
  public var data: RevenueCat.PaywallEvent.Data {
    get
  }
}
extension RevenueCat.PaywallEvent.CreationData : Swift.Equatable, Swift.Codable, Swift.Sendable {
  public static func == (a: RevenueCat.PaywallEvent.CreationData, b: RevenueCat.PaywallEvent.CreationData) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallEvent.Data : Swift.Equatable, Swift.Codable, Swift.Sendable {
  public static func == (a: RevenueCat.PaywallEvent.Data, b: RevenueCat.PaywallEvent.Data) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallEvent : Swift.Equatable, Swift.Codable, Swift.Sendable {
  public static func == (a: RevenueCat.PaywallEvent, b: RevenueCat.PaywallEvent) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
infix operator ??? : DefaultPrecedence
@objc(RCVirtualCurrencies) final public class VirtualCurrencies : ObjectiveC.NSObject {
  @objc final public let all: [Swift.String : RevenueCat.VirtualCurrency]
  @objc final public subscript(key: Swift.String) -> RevenueCat.VirtualCurrency? {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.VirtualCurrencies : Swift.Sendable {
}
extension RevenueCat.VirtualCurrencies : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.VirtualCurrencies {
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
}
@_hasMissingDesignatedInitializers @objc(RCOfferings) final public class Offerings : ObjectiveC.NSObject {
  @objc final public let all: [Swift.String : RevenueCat.Offering]
  @objc final public var current: RevenueCat.Offering? {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.Offerings : Swift.Sendable {
}
extension RevenueCat.Offerings {
  @objc final public func offering(identifier: Swift.String?) -> RevenueCat.Offering?
  @objc final public subscript(key: Swift.String) -> RevenueCat.Offering? {
    @objc get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc(currentOfferingForPlacement:) final public func currentOffering(forPlacement placementIdentifier: Swift.String) -> RevenueCat.Offering?
}
extension RevenueCat.Purchases {
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  final public func beginRefundRequest(forProduct productID: Swift.String, completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  final public func beginRefundRequest(forEntitlement entitlementID: Swift.String, completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  final public func beginRefundRequestForActiveEntitlement(completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  @available(iOS 16.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  final public func showStoreMessages(for types: Swift.Set<RevenueCat.StoreMessageType> = Set(StoreMessageType.allCases), completion: @escaping () -> Swift.Void)
}
@_hasMissingDesignatedInitializers @objc(RCStorefront) final public class Storefront : ObjectiveC.NSObject {
  @objc final public var countryCode: Swift.String {
    @objc get
  }
  @objc final public var identifier: Swift.String {
    @objc get
  }
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.Storefront : Swift.Sendable {
}
extension RevenueCat.Storefront {
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, macCatalyst 13.1, *)
  public static var currentStorefront: RevenueCat.Storefront? {
    get async
  }
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, macCatalyst 13.1, *)
  @available(swift, obsoleted: 0.0.1, renamed: "currentStorefront")
  @objc public static var sk1CurrentStorefront: RevenueCat.Storefront? {
    @objc get
  }
}
extension RevenueCat.Storefront {
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, macCatalyst 13.1, *)
  @objc final public var sk1Storefront: StoreKit.SKStorefront? {
    @objc get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  final public var sk2Storefront: StoreKit.Storefront? {
    get
  }
}
@_hasMissingDesignatedInitializers @objc(RCWinBackOffer) final public class WinBackOffer : ObjectiveC.NSObject, Swift.Sendable {
  @objc final public let discount: RevenueCat.StoreProductDiscount
  @objc deinit
}
@objc(RCVerificationResult) public enum VerificationResult : Swift.Int {
  case notRequested = 0
  case verified = 1
  case verifiedOnDevice = 3
  case failed = 2
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.VerificationResult : Swift.Sendable, Swift.Codable {
}
extension RevenueCat.VerificationResult {
  public var isVerified: Swift.Bool {
    get
  }
}
extension RevenueCat.VerificationResult : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers @objc(RCAttribution) final public class Attribution : ObjectiveC.NSObject {
  @objc deinit
}
@available(iOS 14.3, macOS 11.1, macCatalyst 14.3, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension RevenueCat.Attribution {
  @objc final public func enableAdServicesAttributionTokenCollection()
}
extension RevenueCat.Attribution {
  @objc final public func collectDeviceIdentifiers()
  @objc final public func setAttributes(_ attributes: [Swift.String : Swift.String])
  @objc final public func setEmail(_ email: Swift.String?)
  @objc final public func setPhoneNumber(_ phoneNumber: Swift.String?)
  @objc final public func setDisplayName(_ displayName: Swift.String?)
  @objc final public func setPushToken(_ pushToken: Foundation.Data?)
  @objc final public func setPushTokenString(_ pushToken: Swift.String?)
  @objc final public func setAdjustID(_ adjustID: Swift.String?)
  @objc final public func setAppsflyerID(_ appsflyerID: Swift.String?)
  @objc final public func setFBAnonymousID(_ fbAnonymousID: Swift.String?)
  @objc final public func setMparticleID(_ mparticleID: Swift.String?)
  @objc final public func setOnesignalID(_ onesignalID: Swift.String?)
  @objc final public func setOnesignalUserID(_ onesignalUserID: Swift.String?)
  @objc final public func setAirshipChannelID(_ airshipChannelID: Swift.String?)
  @objc final public func setCleverTapID(_ cleverTapID: Swift.String?)
  @objc final public func setKochavaDeviceID(_ kochavaDeviceID: Swift.String?)
  @objc final public func setMixpanelDistinctID(_ mixpanelDistinctID: Swift.String?)
  @objc final public func setFirebaseAppInstanceID(_ firebaseAppInstanceID: Swift.String?)
  @objc final public func setTenjinAnalyticsInstallationID(_ tenjinAnalyticsInstallationID: Swift.String?)
  @objc final public func setPostHogUserID(_ postHogUserID: Swift.String?)
  @objc final public func setAmplitudeUserID(_ amplitudeUserID: Swift.String?)
  @objc final public func setAmplitudeDeviceID(_ amplitudeDeviceID: Swift.String?)
  @objc final public func setMediaSource(_ mediaSource: Swift.String?)
  @objc final public func setCampaign(_ campaign: Swift.String?)
  @objc final public func setAdGroup(_ adGroup: Swift.String?)
  @objc final public func setAd(_ installAd: Swift.String?)
  @objc final public func setKeyword(_ keyword: Swift.String?)
  @objc final public func setCreative(_ creative: Swift.String?)
}
extension RevenueCat.Attribution : @unchecked Swift.Sendable {
}
extension RevenueCat.StoreProduct {
  @objc(RCStoreProductCategory) public enum ProductCategory : Swift.Int {
    case subscription
    case nonSubscription
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(RCStoreProductType) public enum ProductType : Swift.Int {
    case consumable
    case nonConsumable
    case nonRenewableSubscription
    case autoRenewableSubscription
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension RevenueCat.StoreProduct.ProductCategory : Swift.Sendable {
}
extension RevenueCat.StoreProduct.ProductType : Swift.Sendable {
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension _StoreKit_SwiftUI.StoreView {
  @_Concurrency.MainActor @preconcurrency public static func forOffering(_ offering: RevenueCat.Offering, prefersPromotionalIcon: Swift.Bool = false, @SwiftUICore.ViewBuilder icon: @escaping (StoreKit.Product) -> Icon, @SwiftUICore.ViewBuilder placeholderIcon: () -> PlaceholderIcon) -> some SwiftUICore.View
  
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension _StoreKit_SwiftUI.StoreView where Icon == SwiftUICore.EmptyView, PlaceholderIcon == SwiftUICore.EmptyView {
  @_Concurrency.MainActor @preconcurrency public static func forOffering(_ offering: RevenueCat.Offering, prefersPromotionalIcon: Swift.Bool = false) -> some SwiftUICore.View
  
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension _StoreKit_SwiftUI.SubscriptionStoreView {
  @_Concurrency.MainActor @preconcurrency public static func forOffering(_ offering: RevenueCat.Offering, @SwiftUICore.ViewBuilder marketingContent: () -> Content) -> some SwiftUICore.View
  
}
@available(iOS 17.0, macOS 14.0, tvOS 17.0, watchOS 10.0, *)
extension _StoreKit_SwiftUI.SubscriptionStoreView where Content == _StoreKit_SwiftUI.AutomaticSubscriptionStoreMarketingContent {
  @_Concurrency.MainActor @preconcurrency public static func forOffering(_ offering: RevenueCat.Offering) -> some SwiftUICore.View
  
}
@_hasMissingDesignatedInitializers @objc(RCWebPurchaseRedemption) final public class WebPurchaseRedemption : ObjectiveC.NSObject {
  @objc deinit
}
extension RevenueCat.Purchases {
  @available(iOS, obsoleted: 1, renamed: "restorePurchases(completion:)")
  @available(tvOS, obsoleted: 1, renamed: "restorePurchases(completion:)")
  @available(watchOS, obsoleted: 1, renamed: "restorePurchases(completion:)")
  @available(macOS, obsoleted: 1, renamed: "restorePurchases(completion:)")
  @objc(restoreTransactionsWithCompletionBlock:) final public func restoreTransactions(completion: ((RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)? = nil)
  @available(iOS, unavailable, introduced: 13.0, renamed: "restorePurchases()")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "restorePurchases()")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "restorePurchases()")
  @available(macOS, unavailable, introduced: 10.15, renamed: "restorePurchases()")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "restorePurchases()")
  final public func restoreTransactions() async throws -> RevenueCat.CustomerInfo
  @available(iOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(tvOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(watchOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(macOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @objc final public func customerInfo(completion: @escaping (RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)
  @available(iOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(tvOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(watchOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @available(macOS, obsoleted: 1, renamed: "getCustomerInfo(completion:)")
  @objc(purchaserInfoWithCompletionBlock:) final public func purchaserInfo(completion: @escaping (RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)
  @available(iOS, unavailable, introduced: 13.0, renamed: "customerInfo()")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "customerInfo()")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "customerInfo()")
  @available(macOS, unavailable, introduced: 10.15, renamed: "customerInfo()")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "customerInfo()")
  final public func purchaserInfo() async throws -> RevenueCat.CustomerInfo
  @available(iOS, obsoleted: 1, renamed: "getProducts(_:completion:)")
  @available(tvOS, obsoleted: 1, renamed: "getProducts(_:completion:)")
  @available(watchOS, obsoleted: 1, renamed: "getProducts(_:completion:)")
  @available(macOS, obsoleted: 1, renamed: "getProducts(_:completion:)")
  @objc(productsWithIdentifiers:completionBlock:) final public func products(_ productIdentifiers: [Swift.String], completion: @escaping ([StoreKit.SKProduct]) -> Swift.Void)
  @available(iOS, obsoleted: 1, renamed: "getOfferings(completion:)")
  @available(tvOS, obsoleted: 1, renamed: "getOfferings(completion:)")
  @available(watchOS, obsoleted: 1, renamed: "getOfferings(completion:)")
  @available(macOS, obsoleted: 1, renamed: "getOfferings(completion:)")
  @objc(offeringsWithCompletionBlock:) final public func offerings(completion: @escaping (RevenueCat.Offerings?, (any Swift.Error)?) -> Swift.Void)
  @available(iOS, obsoleted: 1, renamed: "purchase(package:completion:)")
  @available(tvOS, obsoleted: 1, renamed: "purchase(package:completion:)")
  @available(watchOS, obsoleted: 1, renamed: "purchase(package:completion:)")
  @available(macOS, obsoleted: 1, renamed: "purchase(package:completion:)")
  @objc(purchasePackage:withCompletionBlock:) final public func purchasePackage(_ package: RevenueCat.Package, _ completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(package:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(package:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(package:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(package:)")
  final public func purchasePackage(_ package: RevenueCat.Package) async throws -> RevenueCat.PurchaseResultData
  @available(iOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(tvOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macOS, unavailable, introduced: 10.14.4, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:completion:)")
  @objc(purchasePackage:withDiscount:completionBlock:) final public func purchasePackage(_ package: RevenueCat.Package, discount: StoreKit.SKPaymentDiscount, _ completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(package:promotionalOffer:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  final public func purchasePackage(_ package: RevenueCat.Package, discount: StoreKit.SKPaymentDiscount) async throws -> RevenueCat.PurchaseResultData
  @available(iOS, obsoleted: 1, renamed: "purchase(product:_:)")
  @available(tvOS, obsoleted: 1, renamed: "purchase(product:_:)")
  @available(watchOS, obsoleted: 1, renamed: "purchase(product:_:)")
  @available(macOS, obsoleted: 1, renamed: "purchase(product:_:)")
  @objc(purchaseProduct:withCompletionBlock:) final public func purchaseProduct(_ product: StoreKit.SKProduct, _ completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(product:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(product:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(product:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(product:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(product:)")
  final public func purchaseProduct(_ product: StoreKit.SKProduct) async throws
  @available(iOS, unavailable, introduced: 12.2, renamed: "purchase(product:promotionalOffer:completion:)")
  @available(tvOS, unavailable, introduced: 12.2, renamed: "purchase(product:promotionalOffer:completion:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(product:promotionalOffer:completion:)")
  @available(macOS, unavailable, introduced: 10.14.4, renamed: "purchase(product:promotionalOffer:completion:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(product:promotionalOffer:completion:)")
  @objc(purchaseProduct:withDiscount:completionBlock:) final public func purchaseProduct(_ product: StoreKit.SKProduct, discount: StoreKit.SKPaymentDiscount, _ completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(product:promotionalOffer:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(product:promotionalOffer:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(product:promotionalOffer:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(product:promotionalOffer:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(product:promotionalOffer:)")
  final public func purchaseProduct(_ product: StoreKit.SKProduct, discount: StoreKit.SKPaymentDiscount) async throws
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(package:promotionalOffer:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  final public func purchase(package: RevenueCat.Package, discount: RevenueCat.StoreProductDiscount) async throws -> RevenueCat.PurchaseResultData
  @available(iOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(tvOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macOS, unavailable, introduced: 10.14.4, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macCatalyst, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  final public func purchase(package: RevenueCat.Package, discount: RevenueCat.StoreProductDiscount, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @available(iOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "purchase(package:promotionalOffer:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "purchase(package:promotionalOffer:)")
  final public func purchase(product: RevenueCat.StoreProduct, discount: RevenueCat.StoreProductDiscount) async throws -> RevenueCat.PurchaseResultData
  @available(iOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(tvOS, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macOS, unavailable, introduced: 10.14.4, renamed: "purchase(package:promotionalOffer:completion:)")
  @available(macCatalyst, unavailable, introduced: 12.2, renamed: "purchase(package:promotionalOffer:completion:)")
  final public func purchase(product: RevenueCat.StoreProduct, discount: RevenueCat.StoreProductDiscount, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @available(iOS, unavailable, introduced: 13.0, renamed: "getPromotionalOffer(forProductDiscount:product:)")
  @available(tvOS, unavailable, introduced: 13.0, renamed: "getPromotionalOffer(forProductDiscount:product:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "getPromotionalOffer(forProductDiscount:product:)")
  @available(macOS, unavailable, introduced: 10.15, renamed: "getPromotionalOffer(forProductDiscount:product:)")
  @available(macCatalyst, unavailable, introduced: 13.0, renamed: "getPromotionalOffer(forProductDiscount:product:)")
  final public func checkPromotionalDiscountEligibility(forProductDiscount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct)
  @available(iOS, unavailable, introduced: 12.2, renamed: "getPromotionalOffer(forProductDiscount:product:completion:)")
  @available(tvOS, unavailable, introduced: 12.2, renamed: "getPromotionalOffer(forProductDiscount:product:completion:)")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "getPromotionalOffer(forProductDiscount:product:completion:)")
  @available(macOS, unavailable, introduced: 10.14.4, renamed: "getPromotionalOffer(forProductDiscount:product:completion:)")
  @available(macCatalyst, unavailable, introduced: 12.2, renamed: "getPromotionalOffer(forProductDiscount:product:completion:)")
  final public func checkPromotionalDiscountEligibility(forProductDiscount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct, completion: @escaping (Swift.AnyObject, (any Swift.Error)?) -> Swift.Void)
  @available(iOS, obsoleted: 1, renamed: "invalidateCustomerInfoCache")
  @available(tvOS, obsoleted: 1, renamed: "invalidateCustomerInfoCache")
  @available(watchOS, obsoleted: 1, renamed: "invalidateCustomerInfoCache")
  @available(macOS, obsoleted: 1, renamed: "invalidateCustomerInfoCache")
  @available(macCatalyst, obsoleted: 1, renamed: "invalidateCustomerInfoCache")
  @objc final public func invalidatePurchaserInfoCache()
  @available(iOS, obsoleted: 1, renamed: "checkTrialOrIntroDiscountEligibility(_:completion:)")
  @available(tvOS, obsoleted: 1, renamed: "checkTrialOrIntroDiscountEligibility(_:completion:)")
  @available(watchOS, obsoleted: 1, renamed: "checkTrialOrIntroDiscountEligibility(_:completion:)")
  @available(macOS, obsoleted: 1, renamed: "checkTrialOrIntroDiscountEligibility(_:completion:)")
  @available(macCatalyst, obsoleted: 1, renamed: "checkTrialOrIntroDiscountEligibility(_:completion:)")
  @objc(checkTrialOrIntroductoryPriceEligibility:completion:) final public func checkTrialOrIntroductoryPriceEligibility(_ productIdentifiers: [Swift.String], completion: @escaping ([Swift.String : RevenueCat.IntroEligibility]) -> Swift.Void)
  @available(iOS, unavailable, introduced: 12.2, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(tvOS, unavailable, introduced: 12.2, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(watchOS, unavailable, introduced: 6.2, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(macOS, unavailable, introduced: 10.14.4, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(macCatalyst, unavailable, introduced: 13.0, message: "Check eligibility for a discount using getPromotionalOffer:")
  @objc(paymentDiscountForProductDiscount:product:completion:) final public func paymentDiscount(for discount: StoreKit.SKProductDiscount, product: StoreKit.SKProduct, completion: @escaping (StoreKit.SKPaymentDiscount?, (any Swift.Error)?) -> Swift.Void)
  @available(iOS, unavailable, introduced: 13.0, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(tvOS, unavailable, introduced: 13.0, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(watchOS, unavailable, introduced: 6.2, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(macOS, unavailable, introduced: 10.15, message: "Check eligibility for a discount using getPromotionalOffer:")
  @available(macCatalyst, unavailable, introduced: 13.0, message: "Check eligibility for a discount using getPromotionalOffer:")
  final public func paymentDiscount(for discount: StoreKit.SKProductDiscount, product: StoreKit.SKProduct) async throws -> StoreKit.SKPaymentDiscount
  @available(iOS, obsoleted: 1, message: "This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`")
  @available(tvOS, obsoleted: 1, message: "This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`")
  @available(watchOS, obsoleted: 1, message: "This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`")
  @available(macOS, obsoleted: 1, message: "This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`")
  @available(macCatalyst, obsoleted: 1, message: "This was never meant to be public. Use `PurchasesDelegate.purchases(_:readyForPromotedProduct:purchase:)`")
  @objc final public func shouldPurchasePromoProduct(_ product: RevenueCat.StoreProduct, defermentBlock: @escaping RevenueCat.StartPurchaseBlock)
  @available(iOS, obsoleted: 1, renamed: "logIn")
  @available(tvOS, obsoleted: 1, renamed: "logIn")
  @available(watchOS, obsoleted: 1, renamed: "logIn")
  @available(macOS, obsoleted: 1, renamed: "logIn")
  @objc(createAlias:completionBlock:) final public func createAlias(_ alias: Swift.String, _ completion: ((RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)?)
  @available(iOS, obsoleted: 1, renamed: "logIn")
  @available(tvOS, obsoleted: 1, renamed: "logIn")
  @available(watchOS, obsoleted: 1, renamed: "logIn")
  @available(macOS, obsoleted: 1, renamed: "logIn")
  @objc(identify:completionBlock:) final public func identify(_ appUserID: Swift.String, _ completion: ((RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)?)
  @available(iOS, obsoleted: 1, renamed: "logOut")
  @available(tvOS, obsoleted: 1, renamed: "logOut")
  @available(watchOS, obsoleted: 1, renamed: "logOut")
  @available(macOS, obsoleted: 1, renamed: "logOut")
  @objc(resetWithCompletionBlock:) final public func reset(completion: ((RevenueCat.CustomerInfo?, (any Swift.Error)?) -> Swift.Void)?)
  @available(iOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting purchasesAreCompletedBy.")
  @available(tvOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting purchasesAreCompletedBy.")
  @available(watchOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting purchasesAreCompletedBy.")
  @available(macOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting purchasesAreCompletedBy.")
  @discardableResult
  @objc(configureWithAPIKey:appUserID:observerMode:) @_disfavoredOverload public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.String?, observerMode: Swift.Bool) -> RevenueCat.Purchases
  @available(iOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting purchasesAreCompletedBy.")
  @available(tvOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting purchasesAreCompletedBy.")
  @available(watchOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting purchasesAreCompletedBy.")
  @available(macOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting purchasesAreCompletedBy.")
  @discardableResult
  public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.StaticString, observerMode: Swift.Bool) -> RevenueCat.Purchases
  @available(iOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting\npurchasesAreCompletedBy. Please use the Configuration.Builder class to configure the SDK with\ncustom UserDefaults.")
  @available(tvOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting\npurchasesAreCompletedBy. Please use the Configuration.Builder class to configure the SDK with\ncustom UserDefaults.")
  @available(watchOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting\npurchasesAreCompletedBy. Please use the Configuration.Builder class to configure the SDK with\ncustom UserDefaults.")
  @available(macOS, obsoleted: 1, renamed: "configure(withAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:)", message: "Explicitly setting the StoreKit version is now required when setting\npurchasesAreCompletedBy. Please use the Configuration.Builder class to configure the SDK with\ncustom UserDefaults.")
  @discardableResult
  @objc(configureWithAPIKey:appUserID:observerMode:userDefaults:) public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.String?, observerMode: Swift.Bool, userDefaults: Foundation.UserDefaults?) -> RevenueCat.Purchases
  @available(iOS, obsoleted: 1, renamed: "configure(with:)")
  @available(tvOS, obsoleted: 1, renamed: "configure(with:)")
  @available(watchOS, obsoleted: 1, renamed: "configure(with:)")
  @available(macOS, obsoleted: 1, renamed: "configure(with:)")
  @available(macCatalyst, obsoleted: 1, renamed: "configure(with:)")
  @discardableResult
  @objc(configureWithAPIKey:appUserID:observerMode:userDefaults:useStoreKit2IfAvailable:) public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.String?, observerMode: Swift.Bool, userDefaults: Foundation.UserDefaults?, useStoreKit2IfAvailable: Swift.Bool) -> RevenueCat.Purchases
  @available(iOS, obsoleted: 1, renamed: "configure(with:)")
  @available(tvOS, obsoleted: 1, renamed: "configure(with:)")
  @available(watchOS, obsoleted: 1, renamed: "configure(with:)")
  @available(macOS, obsoleted: 1, renamed: "configure(with:)")
  @available(macCatalyst, obsoleted: 1, renamed: "configure(with:)")
  @discardableResult
  @objc(configureWithAPIKey:appUserID:observerMode:userDefaults:useStoreKit2IfAvailable:dangerousSettings:) public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.String?, observerMode: Swift.Bool, userDefaults: Foundation.UserDefaults?, useStoreKit2IfAvailable: Swift.Bool, dangerousSettings: RevenueCat.DangerousSettings?) -> RevenueCat.Purchases
  @available(iOS, obsoleted: 1, renamed: "Purchases.shared.attribution.enableAdServicesAttributionTokenCollection()", message: "Use Purchases.shared.attribution.enableAdServicesAttributionTokenCollection() instead.\nAdClient doesn't work after February 7, 2023  so this boolean doesn't have any effect.")
  @available(tvOS, obsoleted: 1, renamed: "Purchases.shared.attribution.enableAdServicesAttributionTokenCollection()", message: "Use Purchases.shared.attribution.enableAdServicesAttributionTokenCollection() instead.\nAdClient doesn't work after February 7, 2023  so this boolean doesn't have any effect.")
  @available(watchOS, obsoleted: 1, renamed: "Purchases.shared.attribution.enableAdServicesAttributionTokenCollection()", message: "Use Purchases.shared.attribution.enableAdServicesAttributionTokenCollection() instead.\nAdClient doesn't work after February 7, 2023  so this boolean doesn't have any effect.")
  @available(macOS, obsoleted: 1, renamed: "Purchases.shared.attribution.enableAdServicesAttributionTokenCollection()", message: "Use Purchases.shared.attribution.enableAdServicesAttributionTokenCollection() instead.\nAdClient doesn't work after February 7, 2023  so this boolean doesn't have any effect.")
  @objc public static var automaticAppleSearchAdsAttributionCollection: Swift.Bool {
    @objc get
    @objc set
  }
}
@available(iOS, obsoleted: 1, renamed: "StartPurchaseBlock")
@available(tvOS, obsoleted: 1, renamed: "StartPurchaseBlock")
@available(watchOS, obsoleted: 1, renamed: "StartPurchaseBlock")
@available(macOS, obsoleted: 1, renamed: "StartPurchaseBlock")
public typealias DeferredPromotionalPurchaseBlock = RevenueCat.StartPurchaseBlock
@_inheritsConvenienceInitializers @available(iOS, obsoleted: 1, renamed: "CustomerInfo")
@available(tvOS, obsoleted: 1, renamed: "CustomerInfo")
@available(watchOS, obsoleted: 1, renamed: "CustomerInfo")
@available(macOS, obsoleted: 1, renamed: "CustomerInfo")
@objc(RCPurchaserInfo) public class PurchaserInfo : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @available(iOS, obsoleted: 1, renamed: "StoreTransaction")
@available(tvOS, obsoleted: 1, renamed: "StoreTransaction")
@available(watchOS, obsoleted: 1, renamed: "StoreTransaction")
@available(macOS, obsoleted: 1, renamed: "StoreTransaction")
@objc(RCTransaction) public class Transaction : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
extension RevenueCat.StoreTransaction {
  @available(iOS, obsoleted: 1, renamed: "productIdentifier")
  @available(tvOS, obsoleted: 1, renamed: "productIdentifier")
  @available(watchOS, obsoleted: 1, renamed: "productIdentifier")
  @available(macOS, obsoleted: 1, renamed: "productIdentifier")
  @objc final public var productId: Swift.String {
    @objc get
  }
  @available(iOS, obsoleted: 1, renamed: "transactionIdentifier")
  @available(tvOS, obsoleted: 1, renamed: "transactionIdentifier")
  @available(watchOS, obsoleted: 1, renamed: "transactionIdentifier")
  @available(macOS, obsoleted: 1, renamed: "transactionIdentifier")
  @objc final public var revenueCatId: Swift.String {
    @objc get
  }
}
extension RevenueCat.Package {
  @available(iOS, obsoleted: 1, renamed: "storeProduct", message: "Use StoreProduct instead")
  @available(tvOS, obsoleted: 1, renamed: "storeProduct", message: "Use StoreProduct instead")
  @available(watchOS, obsoleted: 1, renamed: "storeProduct", message: "Use StoreProduct instead")
  @available(macOS, obsoleted: 1, renamed: "storeProduct", message: "Use StoreProduct instead")
  @available(macCatalyst, obsoleted: 1, renamed: "storeProduct", message: "Use StoreProduct instead")
  @objc final public var product: StoreKit.SKProduct {
    @objc get
  }
}
extension RevenueCat.StoreProductDiscount.PaymentMode {
  @available(iOS, obsoleted: 1, message: "This option no longer exists. PaymentMode would be nil instead.")
  @available(tvOS, obsoleted: 1, message: "This option no longer exists. PaymentMode would be nil instead.")
  @available(watchOS, obsoleted: 1, message: "This option no longer exists. PaymentMode would be nil instead.")
  @available(macOS, obsoleted: 1, message: "This option no longer exists. PaymentMode would be nil instead.")
  @available(macCatalyst, obsoleted: 1, message: "This option no longer exists. PaymentMode would be nil instead.")
  public static var none: RevenueCat.StoreProductDiscount.PaymentMode {
    get
  }
}
@available(iOS, obsoleted: 1, renamed: "StoreProductDiscount.PaymentMode")
@available(tvOS, obsoleted: 1, renamed: "StoreProductDiscount.PaymentMode")
@available(watchOS, obsoleted: 1, renamed: "StoreProductDiscount.PaymentMode")
@available(macOS, obsoleted: 1, renamed: "StoreProductDiscount.PaymentMode")
@available(macCatalyst, obsoleted: 1, renamed: "StoreProductDiscount.PaymentMode")
public enum RCPaymentMode {
}
@_inheritsConvenienceInitializers @available(iOS, obsoleted: 1, message: "Use PromotionalOffer instead")
@available(tvOS, obsoleted: 1, message: "Use PromotionalOffer instead")
@available(watchOS, obsoleted: 1, message: "Use PromotionalOffer instead")
@available(macOS, obsoleted: 1, message: "Use PromotionalOffer instead")
@available(macCatalyst, obsoleted: 1, message: "Use PromotionalOffer instead")
@objc(RCPromotionalOfferEligibility) public class PromotionalOfferEligibility : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(tvOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(watchOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(macOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(macCatalyst, obsoleted: 1, message: "Use ErrorCode instead")
public var ErrorDomain: Foundation.NSErrorDomain {
  get
}
@available(iOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(tvOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(watchOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(macOS, obsoleted: 1, message: "Use ErrorCode instead")
@available(macCatalyst, obsoleted: 1, message: "Use ErrorCode instead")
public enum RCBackendErrorCode {
}
@objc @_inheritsConvenienceInitializers @available(iOS, obsoleted: 1)
@available(tvOS, obsoleted: 1)
@available(watchOS, obsoleted: 1)
@available(macOS, obsoleted: 1)
@available(macCatalyst, obsoleted: 1)
public class RCPurchasesErrorUtils : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
extension RevenueCat.Purchases {
  @available(iOS, obsoleted: 1, renamed: "ErrorCode")
  @available(tvOS, obsoleted: 1, renamed: "ErrorCode")
  @available(watchOS, obsoleted: 1, renamed: "ErrorCode")
  @available(macOS, obsoleted: 1, renamed: "ErrorCode")
  @available(macCatalyst, obsoleted: 1, renamed: "ErrorCode")
  public enum Errors {
  }
  @available(iOS, obsoleted: 1)
  @available(tvOS, obsoleted: 1)
  @available(watchOS, obsoleted: 1)
  @available(macOS, obsoleted: 1)
  @available(macCatalyst, obsoleted: 1)
  public enum FinishableKey {
  }
  @available(iOS, obsoleted: 1)
  @available(tvOS, obsoleted: 1)
  @available(watchOS, obsoleted: 1)
  @available(macOS, obsoleted: 1)
  @available(macCatalyst, obsoleted: 1)
  public enum ReadableErrorCodeKey {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum ErrorCode {
  }
  @available(iOS, obsoleted: 1)
  @available(tvOS, obsoleted: 1)
  @available(watchOS, obsoleted: 1)
  @available(macOS, obsoleted: 1)
  @available(macCatalyst, obsoleted: 1)
  public enum RevenueCatBackendErrorCode {
  }
  @available(iOS, obsoleted: 1, renamed: "StoreTransaction")
  @available(tvOS, obsoleted: 1, renamed: "StoreTransaction")
  @available(watchOS, obsoleted: 1, renamed: "StoreTransaction")
  @available(macOS, obsoleted: 1, renamed: "StoreTransaction")
  @available(macCatalyst, obsoleted: 1, renamed: "StoreTransaction")
  public enum Transaction {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum EntitlementInfo {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum EntitlementInfos {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum PackageType {
  }
  @available(iOS, obsoleted: 1, renamed: "CustomerInfo")
  @available(tvOS, obsoleted: 1, renamed: "CustomerInfo")
  @available(watchOS, obsoleted: 1, renamed: "CustomerInfo")
  @available(macOS, obsoleted: 1, renamed: "CustomerInfo")
  @available(macCatalyst, obsoleted: 1, renamed: "CustomerInfo")
  public enum PurchaserInfo {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum Offering {
  }
  @available(iOS, obsoleted: 1)
  @available(tvOS, obsoleted: 1)
  @available(watchOS, obsoleted: 1)
  @available(macOS, obsoleted: 1)
  @available(macCatalyst, obsoleted: 1)
  public enum ErrorUtils {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum Store {
  }
  @available(iOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(tvOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(watchOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macOS, obsoleted: 1, message: "Remove `Purchases.`")
  @available(macCatalyst, obsoleted: 1, message: "Remove `Purchases.`")
  public enum PeriodType {
  }
}
extension RevenueCat.Configuration.Builder {
  @available(iOS, obsoleted: 1, renamed: "with(purchasesAreCompletedBy:storeKitVersion:)", message: "Observer Mode is now named PurchasesAreCompletedBy.")
  @available(tvOS, obsoleted: 1, renamed: "with(purchasesAreCompletedBy:storeKitVersion:)", message: "Observer Mode is now named PurchasesAreCompletedBy.")
  @available(watchOS, obsoleted: 1, renamed: "with(purchasesAreCompletedBy:storeKitVersion:)", message: "Observer Mode is now named PurchasesAreCompletedBy.")
  @available(macOS, obsoleted: 1, renamed: "with(purchasesAreCompletedBy:storeKitVersion:)", message: "Observer Mode is now named PurchasesAreCompletedBy.")
  @objc dynamic public func with(observerMode: Swift.Bool) -> RevenueCat.Configuration.Builder
}
@_hasMissingDesignatedInitializers @objc(RCPromotionalOffer) final public class PromotionalOffer : ObjectiveC.NSObject {
  @objc final public let discount: RevenueCat.StoreProductDiscount
  @objc final public let signedData: RevenueCat.PromotionalOffer.SignedData
  @objc deinit
}
extension RevenueCat.PromotionalOffer : Swift.Sendable {
}
@objc extension RevenueCat.PromotionalOffer {
  @_hasMissingDesignatedInitializers @objc(RCPromotionalOfferSignedData) final public class SignedData : ObjectiveC.NSObject {
    @objc final public let identifier: Swift.String
    @objc final public let keyIdentifier: Swift.String
    @objc final public let nonce: Foundation.UUID
    @objc final public let signature: Swift.String
    @objc final public let timestamp: Swift.Int
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    public static func == (lhs: RevenueCat.PromotionalOffer.SignedData, rhs: RevenueCat.PromotionalOffer.SignedData) -> Swift.Bool
    @objc deinit
  }
}
extension RevenueCat.PromotionalOffer.SignedData : Swift.Sendable {
}
public struct PaywallData {
  public var templateName: Swift.String
  public var config: RevenueCat.PaywallData.Configuration
  public var assetBaseURL: Foundation.URL
  public var revision: Swift.Int {
    get
    set
  }
  public var zeroDecimalPlaceCountries: [Swift.String] {
    get
  }
  public var defaultLocale: Swift.String?
}
public protocol PaywallLocalizedConfiguration {
  var title: Swift.String { get }
  var subtitle: Swift.String? { get }
  var callToAction: Swift.String { get }
  var callToActionWithIntroOffer: Swift.String? { get }
  var offerDetails: Swift.String? { get }
  var offerDetailsWithIntroOffer: Swift.String? { get }
  var offerName: Swift.String? { get }
  var features: [RevenueCat.PaywallData.LocalizedConfiguration.Feature] { get }
  var tierName: Swift.String? { get }
}
extension RevenueCat.PaywallData {
  public struct ZeroDecimalPlaceCountries : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public var apple: [Swift.String]
    public init(apple: [Swift.String])
    public static func == (a: RevenueCat.PaywallData.ZeroDecimalPlaceCountries, b: RevenueCat.PaywallData.ZeroDecimalPlaceCountries) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension RevenueCat.PaywallData {
  public struct LocalizedConfiguration : RevenueCat.PaywallLocalizedConfiguration {
    public var title: Swift.String
    public var callToAction: Swift.String
    public var subtitle: Swift.String? {
      get
      set
    }
    public var callToActionWithIntroOffer: Swift.String? {
      get
      set
    }
    public var offerDetails: Swift.String? {
      get
      set
    }
    public var offerDetailsWithIntroOffer: Swift.String? {
      get
      set
    }
    public var offerName: Swift.String? {
      get
      set
    }
    public var offerOverrides: [Swift.String : RevenueCat.PaywallData.LocalizedConfiguration.OfferOverride] {
      get
      set
    }
    public var features: [RevenueCat.PaywallData.LocalizedConfiguration.Feature] {
      get
      set
    }
    public var tierName: Swift.String? {
      get
      set
    }
    public init(title: Swift.String, subtitle: Swift.String? = nil, callToAction: Swift.String, callToActionWithIntroOffer: Swift.String? = nil, offerDetails: Swift.String? = nil, offerDetailsWithIntroOffer: Swift.String? = nil, offerName: Swift.String? = nil, offerOverrides: [Swift.String : RevenueCat.PaywallData.LocalizedConfiguration.OfferOverride] = [:], features: [RevenueCat.PaywallData.LocalizedConfiguration.Feature] = [], tierName: Swift.String? = nil)
  }
  public func config(for requiredLocale: Foundation.Locale) -> RevenueCat.PaywallData.LocalizedConfiguration?
  public func tiersLocalization(for requiredLocale: Foundation.Locale) -> [Swift.String : RevenueCat.PaywallData.LocalizedConfiguration]?
}
extension RevenueCat.PaywallData.LocalizedConfiguration {
  public struct Feature {
    public var title: Swift.String
    public var content: Swift.String?
    public var iconID: Swift.String?
    public init(title: Swift.String, content: Swift.String? = nil, iconID: Swift.String? = nil)
  }
}
extension RevenueCat.PaywallData.LocalizedConfiguration {
  public struct OfferOverride {
    public var offerDetails: Swift.String?
    public var offerDetailsWithIntroOffer: Swift.String?
    public var offerName: Swift.String?
    public var offerBadge: Swift.String?
    public init(offerDetails: Swift.String? = nil, offerDetailsWithIntroOffer: Swift.String? = nil, offerName: Swift.String? = nil, offerBadge: Swift.String? = nil)
  }
}
extension RevenueCat.PaywallData {
  public struct Configuration {
    public var packages: [Swift.String] {
      get
      set
    }
    public var defaultPackage: Swift.String?
    public var tiers: [RevenueCat.PaywallData.Tier] {
      get
      set
    }
    public var images: RevenueCat.PaywallData.Configuration.Images {
      get
      set
    }
    public var imagesByTier: [Swift.String : RevenueCat.PaywallData.Configuration.Images] {
      get
    }
    public var imagesLowRes: RevenueCat.PaywallData.Configuration.Images {
      get
      set
    }
    public var blurredBackgroundImage: Swift.Bool {
      get
      set
    }
    public var displayRestorePurchases: Swift.Bool {
      get
      set
    }
    public var termsOfServiceURL: Foundation.URL? {
      get
      set
    }
    public var privacyURL: Foundation.URL? {
      get
      set
    }
    public var colors: RevenueCat.PaywallData.Configuration.ColorInformation
    public var colorsByTier: [Swift.String : RevenueCat.PaywallData.Configuration.ColorInformation] {
      get
      set
    }
    public init(packages: [Swift.String], defaultPackage: Swift.String? = nil, images: RevenueCat.PaywallData.Configuration.Images, imagesLowRes: RevenueCat.PaywallData.Configuration.Images = Images(), colors: RevenueCat.PaywallData.Configuration.ColorInformation, blurredBackgroundImage: Swift.Bool = false, displayRestorePurchases: Swift.Bool = true, termsOfServiceURL: Foundation.URL? = nil, privacyURL: Foundation.URL? = nil)
    public init(images: RevenueCat.PaywallData.Configuration.Images, imagesByTier: [Swift.String : RevenueCat.PaywallData.Configuration.Images] = [:], colors: RevenueCat.PaywallData.Configuration.ColorInformation, colorsByTier: [Swift.String : RevenueCat.PaywallData.Configuration.ColorInformation] = [:], tiers: [RevenueCat.PaywallData.Tier], blurredBackgroundImage: Swift.Bool = false, displayRestorePurchases: Swift.Bool = true, termsOfServiceURL: Foundation.URL? = nil, privacyURL: Foundation.URL? = nil)
  }
}
extension RevenueCat.PaywallData.Configuration {
  public struct Images {
    public var header: Swift.String? {
      get
      set
    }
    public var background: Swift.String? {
      get
      set
    }
    public var icon: Swift.String? {
      get
      set
    }
    public init(header: Swift.String? = nil, background: Swift.String? = nil, icon: Swift.String? = nil)
  }
}
extension RevenueCat.PaywallData.Configuration {
  public struct ColorInformation {
    public var light: RevenueCat.PaywallData.Configuration.Colors
    public var dark: RevenueCat.PaywallData.Configuration.Colors?
    public init(light: RevenueCat.PaywallData.Configuration.Colors, dark: RevenueCat.PaywallData.Configuration.Colors? = nil)
  }
  public struct Colors {
    public var background: RevenueCat.PaywallColor?
    public var text1: RevenueCat.PaywallColor?
    public var text2: RevenueCat.PaywallColor?
    public var text3: RevenueCat.PaywallColor?
    public var callToActionBackground: RevenueCat.PaywallColor?
    public var callToActionForeground: RevenueCat.PaywallColor?
    public var callToActionSecondaryBackground: RevenueCat.PaywallColor?
    public var accent1: RevenueCat.PaywallColor?
    public var accent2: RevenueCat.PaywallColor?
    public var accent3: RevenueCat.PaywallColor?
    public var closeButton: RevenueCat.PaywallColor?
    public var tierControlBackground: RevenueCat.PaywallColor?
    public var tierControlForeground: RevenueCat.PaywallColor?
    public var tierControlSelectedBackground: RevenueCat.PaywallColor?
    public var tierControlSelectedForeground: RevenueCat.PaywallColor?
    public init(background: RevenueCat.PaywallColor? = nil, text1: RevenueCat.PaywallColor? = nil, text2: RevenueCat.PaywallColor? = nil, text3: RevenueCat.PaywallColor? = nil, callToActionBackground: RevenueCat.PaywallColor? = nil, callToActionForeground: RevenueCat.PaywallColor? = nil, callToActionSecondaryBackground: RevenueCat.PaywallColor? = nil, accent1: RevenueCat.PaywallColor? = nil, accent2: RevenueCat.PaywallColor? = nil, accent3: RevenueCat.PaywallColor? = nil, closeButton: RevenueCat.PaywallColor? = nil, tierControlBackground: RevenueCat.PaywallColor? = nil, tierControlForeground: RevenueCat.PaywallColor? = nil, tierControlSelectedBackground: RevenueCat.PaywallColor? = nil, tierControlSelectedForeground: RevenueCat.PaywallColor? = nil)
  }
}
extension RevenueCat.PaywallData {
  public struct Tier {
    public var id: Swift.String
    public var packages: [Swift.String]
    public var defaultPackage: Swift.String
    public init(id: Swift.String, packages: [Swift.String], defaultPackage: Swift.String)
  }
}
extension RevenueCat.PaywallData {
  public init(templateName: Swift.String, config: RevenueCat.PaywallData.Configuration, localization: RevenueCat.PaywallData.LocalizedConfiguration, assetBaseURL: Foundation.URL, revision: Swift.Int = 0, locale: Foundation.Locale = .current, zeroDecimalPlaceCountries: [Swift.String] = [])
  public init(templateName: Swift.String, config: RevenueCat.PaywallData.Configuration, localizationByTier: [Swift.String : RevenueCat.PaywallData.LocalizedConfiguration], assetBaseURL: Foundation.URL, revision: Swift.Int = 0, locale: Foundation.Locale = .current, zeroDecimalPlaceCountries: [Swift.String] = [])
}
extension RevenueCat.PaywallData.LocalizedConfiguration.Feature : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.LocalizedConfiguration.OfferOverride : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.LocalizedConfiguration : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.Configuration.ColorInformation : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.Configuration.Colors : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.Configuration.Images : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.Tier : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.Configuration : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallData.Tier : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData.Tier, b: RevenueCat.PaywallData.Tier) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.LocalizedConfiguration.Feature : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData.LocalizedConfiguration.Feature, b: RevenueCat.PaywallData.LocalizedConfiguration.Feature) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.LocalizedConfiguration.OfferOverride : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData.LocalizedConfiguration.OfferOverride, b: RevenueCat.PaywallData.LocalizedConfiguration.OfferOverride) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.LocalizedConfiguration : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData.LocalizedConfiguration, b: RevenueCat.PaywallData.LocalizedConfiguration) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.Configuration.ColorInformation : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData.Configuration.ColorInformation, b: RevenueCat.PaywallData.Configuration.ColorInformation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.Configuration.Colors : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData.Configuration.Colors, b: RevenueCat.PaywallData.Configuration.Colors) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.Configuration.Images : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData.Configuration.Images, b: RevenueCat.PaywallData.Configuration.Images) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.Configuration : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData.Configuration, b: RevenueCat.PaywallData.Configuration) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData : Swift.Hashable {
  public static func == (a: RevenueCat.PaywallData, b: RevenueCat.PaywallData) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallData.LocalizedConfiguration.Feature : Swift.Sendable {
}
extension RevenueCat.PaywallData.LocalizedConfiguration.OfferOverride : Swift.Sendable {
}
extension RevenueCat.PaywallData.LocalizedConfiguration : Swift.Sendable {
}
extension RevenueCat.PaywallData.Tier : Swift.Sendable {
}
extension RevenueCat.PaywallData.Configuration.ColorInformation : Swift.Sendable {
}
extension RevenueCat.PaywallData.Configuration.Colors : Swift.Sendable {
}
extension RevenueCat.PaywallData.Configuration.Images : Swift.Sendable {
}
extension RevenueCat.PaywallData.Configuration : Swift.Sendable {
}
extension RevenueCat.PaywallData : Swift.Sendable {
}
extension RevenueCat.PaywallData.Tier : Swift.Identifiable {
  public typealias ID = Swift.String
}
@_hasMissingDesignatedInitializers @objc(RCPurchasesDiagnostics) final public class PurchasesDiagnostics : ObjectiveC.NSObject, Swift.Sendable {
  @objc public static let `default`: RevenueCat.PurchasesDiagnostics
  @objc deinit
}
extension RevenueCat.PurchasesDiagnostics {
  public enum ProductStatus : Swift.Sendable {
    case valid
    case couldNotCheck
    case notFound
    case actionInProgress
    case needsAction
    case unknown
    public static func == (a: RevenueCat.PurchasesDiagnostics.ProductStatus, b: RevenueCat.PurchasesDiagnostics.ProductStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct ProductDiagnosticsPayload : Swift.Sendable {
    public let identifier: Swift.String
    public let title: Swift.String?
    public let status: RevenueCat.PurchasesDiagnostics.ProductStatus
    public let description: Swift.String
  }
  public struct InvalidBundleIdErrorPayload : Swift.Equatable {
    public let appBundleId: Swift.String
    public let sdkBundleId: Swift.String
    public static func == (a: RevenueCat.PurchasesDiagnostics.InvalidBundleIdErrorPayload, b: RevenueCat.PurchasesDiagnostics.InvalidBundleIdErrorPayload) -> Swift.Bool
  }
  public enum SDKHealthCheckStatus : Swift.Sendable {
    case passed
    case failed
    case warning
    public static func == (a: RevenueCat.PurchasesDiagnostics.SDKHealthCheckStatus, b: RevenueCat.PurchasesDiagnostics.SDKHealthCheckStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct OfferingDiagnosticsPayload : Swift.Sendable {
    public let identifier: Swift.String
    public let packages: [RevenueCat.PurchasesDiagnostics.OfferingPackageDiagnosticsPayload]
    public let status: RevenueCat.PurchasesDiagnostics.SDKHealthCheckStatus
  }
  public struct OfferingPackageDiagnosticsPayload : Swift.Sendable {
    public let identifier: Swift.String
    public let title: Swift.String?
    public let status: RevenueCat.PurchasesDiagnostics.ProductStatus
    public let description: Swift.String
    public let productIdentifier: Swift.String
    public let productTitle: Swift.String?
  }
  public enum SDKHealthError : Swift.Error {
    case invalidAPIKey
    case noOfferings
    case offeringConfiguration([RevenueCat.PurchasesDiagnostics.OfferingDiagnosticsPayload])
    case invalidBundleId(RevenueCat.PurchasesDiagnostics.InvalidBundleIdErrorPayload?)
    case invalidProducts([RevenueCat.PurchasesDiagnostics.ProductDiagnosticsPayload])
    case notAuthorizedToMakePayments
    case unknown(any Swift.Error)
  }
  public struct SDKHealthReport : Swift.Sendable {
    public let status: RevenueCat.PurchasesDiagnostics.SDKHealthStatus
    public let projectId: Swift.String?
    public let appId: Swift.String?
    public let products: [RevenueCat.PurchasesDiagnostics.ProductDiagnosticsPayload]
    public let offerings: [RevenueCat.PurchasesDiagnostics.OfferingDiagnosticsPayload]
  }
  public enum SDKHealthStatus : Swift.Sendable {
    case healthy(warnings: [RevenueCat.PurchasesDiagnostics.SDKHealthError])
    case unhealthy(RevenueCat.PurchasesDiagnostics.SDKHealthError)
  }
}
extension RevenueCat.PurchasesDiagnostics {
  public enum Error : Swift.Error {
    case failedConnectingToAPI(any Swift.Error)
    case invalidAPIKey
    case failedFetchingOfferings(any Swift.Error)
    case failedMakingSignedRequest(any Swift.Error)
    case unknown(any Swift.Error)
  }
}
extension RevenueCat.PurchasesDiagnostics {
  @available(*, deprecated, message: "Use the `PurchasesDiagnostics.shared.checkSDKHealth()` method instead.")
  @objc(testSDKHealthWithCompletion:) final public func testSDKHealth() async throws
  final public func checkSDKHealth() async throws
  final public func healthReport() async -> RevenueCat.PurchasesDiagnostics.SDKHealthReport
}
extension RevenueCat.PurchasesDiagnostics.Error : Foundation.CustomNSError {
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
@_hasMissingDesignatedInitializers @objc(RCNonSubscriptionTransaction) final public class NonSubscriptionTransaction : ObjectiveC.NSObject {
  @objc final public let productIdentifier: Swift.String
  @objc final public let purchaseDate: Foundation.Date
  @objc final public let transactionIdentifier: Swift.String
  @objc final public let storeTransactionIdentifier: Swift.String
  @objc final public let store: RevenueCat.Store
  @objc final public let price: RevenueCat.ProductPaidPrice?
  @objc final public let isSandbox: Swift.Bool
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.NonSubscriptionTransaction : Swift.Sendable {
}
extension RevenueCat.Purchases {
  @available(iOS, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(tvOS, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(watchOS, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(macOS, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(macCatalyst, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  final public func checkTrialOrIntroDiscountEligibility(_ productIdentifiers: [Swift.String], completion: @escaping ([Swift.String : RevenueCat.IntroEligibility]) -> Swift.Void)
  @available(iOS, introduced: 13.0, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(tvOS, introduced: 13.0, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(watchOS, introduced: 6.2, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(macOS, introduced: 10.15, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  @available(macCatalyst, introduced: 13.0, deprecated: 1, renamed: "checkTrialOrIntroDiscountEligibility(productIdentifiers:)")
  final public func checkTrialOrIntroDiscountEligibility(_ productIdentifiers: [Swift.String]) async -> [Swift.String : RevenueCat.IntroEligibility]
  @available(iOS, deprecated, introduced: 13.0, renamed: "promotionalOffer(forProductDiscount:product:)")
  @available(tvOS, deprecated, introduced: 13.0, renamed: "promotionalOffer(forProductDiscount:product:)")
  @available(watchOS, deprecated, introduced: 6.2, renamed: "promotionalOffer(forProductDiscount:product:)")
  @available(macOS, deprecated, introduced: 10.15, renamed: "promotionalOffer(forProductDiscount:product:)")
  @available(macCatalyst, deprecated, introduced: 13.0, renamed: "promotionalOffer(forProductDiscount:product:)")
  final public func getPromotionalOffer(forProductDiscount discount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct) async throws -> RevenueCat.PromotionalOffer
  @available(iOS, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers(forProduct:)")
  @available(tvOS, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers(forProduct:)")
  @available(watchOS, deprecated, introduced: 6.2, renamed: "eligiblePromotionalOffers(forProduct:)")
  @available(macOS, deprecated, introduced: 10.15, renamed: "eligiblePromotionalOffers(forProduct:)")
  @available(macCatalyst, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers(forProduct:)")
  final public func getEligiblePromotionalOffers(forProduct product: RevenueCat.StoreProduct) async -> [RevenueCat.PromotionalOffer]
}
extension RevenueCat.Purchases {
  @available(iOS, deprecated, renamed: "attribution.collectDeviceIdentifiers()")
  @available(tvOS, deprecated, renamed: "attribution.collectDeviceIdentifiers()")
  @available(watchOS, deprecated, renamed: "attribution.collectDeviceIdentifiers()")
  @available(macOS, deprecated, renamed: "attribution.collectDeviceIdentifiers()")
  @available(macCatalyst, deprecated, renamed: "attribution.collectDeviceIdentifiers()")
  @objc final public func collectDeviceIdentifiers()
  @available(iOS, deprecated, renamed: "attribution.setAttributes(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAttributes(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAttributes(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAttributes(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAttributes(_:)")
  @objc final public func setAttributes(_ attributes: [Swift.String : Swift.String])
  @available(iOS, deprecated, renamed: "attribution.setEmail(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setEmail(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setEmail(_:)")
  @available(macOS, deprecated, renamed: "attribution.setEmail(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setEmail(_:)")
  @objc final public func setEmail(_ email: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setPhoneNumber(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setPhoneNumber(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setPhoneNumber(_:)")
  @available(macOS, deprecated, renamed: "attribution.setPhoneNumber(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setPhoneNumber(_:)")
  @objc final public func setPhoneNumber(_ phoneNumber: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setDisplayName(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setDisplayName(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setDisplayName(_:)")
  @available(macOS, deprecated, renamed: "attribution.setDisplayName(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setDisplayName(_:)")
  @objc final public func setDisplayName(_ displayName: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setPushToken(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setPushToken(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setPushToken(_:)")
  @available(macOS, deprecated, renamed: "attribution.setPushToken(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setPushToken(_:)")
  @objc final public func setPushToken(_ pushToken: Foundation.Data?)
  @available(iOS, deprecated, renamed: "attribution.setPushTokenString(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setPushTokenString(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setPushTokenString(_:)")
  @available(macOS, deprecated, renamed: "attribution.setPushTokenString(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setPushTokenString(_:)")
  @objc final public func setPushTokenString(_ pushToken: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setAdjustID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAdjustID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAdjustID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAdjustID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAdjustID(_:)")
  @objc final public func setAdjustID(_ adjustID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setAppsflyerID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAppsflyerID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAppsflyerID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAppsflyerID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAppsflyerID(_:)")
  @objc final public func setAppsflyerID(_ appsflyerID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setFBAnonymousID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setFBAnonymousID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setFBAnonymousID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setFBAnonymousID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setFBAnonymousID(_:)")
  @objc final public func setFBAnonymousID(_ fbAnonymousID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setMparticleID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setMparticleID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setMparticleID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setMparticleID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setMparticleID(_:)")
  @objc final public func setMparticleID(_ mparticleID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setOnesignalID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setOnesignalID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setOnesignalID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setOnesignalID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setOnesignalID(_:)")
  @objc final public func setOnesignalID(_ onesignalID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setAirshipChannelID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAirshipChannelID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAirshipChannelID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAirshipChannelID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAirshipChannelID(_:)")
  @objc final public func setAirshipChannelID(_ airshipChannelID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setCleverTapID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setCleverTapID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setCleverTapID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setCleverTapID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setCleverTapID(_:)")
  @objc final public func setCleverTapID(_ cleverTapID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setMixpanelDistinctID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setMixpanelDistinctID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setMixpanelDistinctID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setMixpanelDistinctID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setMixpanelDistinctID(_:)")
  @objc final public func setMixpanelDistinctID(_ mixpanelDistinctID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setFirebaseAppInstanceID(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setFirebaseAppInstanceID(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setFirebaseAppInstanceID(_:)")
  @available(macOS, deprecated, renamed: "attribution.setFirebaseAppInstanceID(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setFirebaseAppInstanceID(_:)")
  @objc final public func setFirebaseAppInstanceID(_ firebaseAppInstanceID: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setMediaSource(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setMediaSource(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setMediaSource(_:)")
  @available(macOS, deprecated, renamed: "attribution.setMediaSource(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setMediaSource(_:)")
  @objc final public func setMediaSource(_ mediaSource: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setCampaign(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setCampaign(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setCampaign(_:)")
  @available(macOS, deprecated, renamed: "attribution.setCampaign(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setCampaign(_:)")
  @objc final public func setCampaign(_ campaign: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setAdGroup(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAdGroup(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAdGroup(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAdGroup(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAdGroup(_:)")
  @objc final public func setAdGroup(_ adGroup: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setAd(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setAd(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setAd(_:)")
  @available(macOS, deprecated, renamed: "attribution.setAd(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setAd(_:)")
  @objc final public func setAd(_ installAd: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setKeyword(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setKeyword(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setKeyword(_:)")
  @available(macOS, deprecated, renamed: "attribution.setKeyword(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setKeyword(_:)")
  @objc final public func setKeyword(_ keyword: Swift.String?)
  @available(iOS, deprecated, renamed: "attribution.setCreative(_:)")
  @available(tvOS, deprecated, renamed: "attribution.setCreative(_:)")
  @available(watchOS, deprecated, renamed: "attribution.setCreative(_:)")
  @available(macOS, deprecated, renamed: "attribution.setCreative(_:)")
  @available(macCatalyst, deprecated, renamed: "attribution.setCreative(_:)")
  @objc final public func setCreative(_ creative: Swift.String?)
  @available(iOS, deprecated, renamed: "purchase(_:completion:)")
  @available(tvOS, deprecated, renamed: "purchase(_:completion:)")
  @available(watchOS, deprecated, renamed: "purchase(_:completion:)")
  @available(macOS, deprecated, renamed: "purchase(_:completion:)")
  @available(macCatalyst, deprecated, renamed: "purchase(_:completion:)")
  @objc(params:withCompletion:) final public func purchaseWithParams(_ params: RevenueCat.PurchaseParams, completion: @escaping RevenueCat.PurchaseCompletedBlock)
}
extension RevenueCat.StoreProduct {
  @available(iOS, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers()")
  @available(tvOS, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers()")
  @available(watchOS, deprecated, introduced: 6.2, renamed: "eligiblePromotionalOffers()")
  @available(macOS, deprecated, introduced: 10.15, renamed: "eligiblePromotionalOffers()")
  @available(macCatalyst, deprecated, introduced: 13.0, renamed: "eligiblePromotionalOffers()")
  final public func getEligiblePromotionalOffers() async -> [RevenueCat.PromotionalOffer]
}
extension RevenueCat.CustomerInfo {
  @available(*, deprecated, message: "use nonSubscriptionTransactions")
  @objc final public var nonConsumablePurchases: Swift.Set<Swift.String> {
    @objc get
  }
  @available(*, deprecated, renamed: "nonSubscriptions")
  @objc final public var nonSubscriptionTransactions: [RevenueCat.StoreTransaction] {
    @objc get
  }
}
extension RevenueCat.Configuration.Builder {
  @available(*, deprecated, message: "Use .with(storeKitVersion:) to enable StoreKit 2")
  @objc dynamic public func with(usesStoreKit2IfAvailable: Swift.Bool) -> RevenueCat.Configuration.Builder
}
@objc(RCPurchasesErrorCode) public enum ErrorCode : Swift.Int, Swift.Error {
  @objc(RCUnknownError) case unknownError = 0
  @objc(RCPurchaseCancelledError) case purchaseCancelledError = 1
  @objc(RCStoreProblemError) case storeProblemError = 2
  @objc(RCPurchaseNotAllowedError) case purchaseNotAllowedError = 3
  @objc(RCPurchaseInvalidError) case purchaseInvalidError = 4
  @objc(RCProductNotAvailableForPurchaseError) case productNotAvailableForPurchaseError = 5
  @objc(RCProductAlreadyPurchasedError) case productAlreadyPurchasedError = 6
  @objc(RCReceiptAlreadyInUseError) case receiptAlreadyInUseError = 7
  @objc(RCInvalidReceiptError) case invalidReceiptError = 8
  @objc(RCMissingReceiptFileError) case missingReceiptFileError = 9
  @objc(RCNetworkError) case networkError = 10
  @objc(RCInvalidCredentialsError) case invalidCredentialsError = 11
  @objc(RCUnexpectedBackendResponseError) case unexpectedBackendResponseError = 12
  @objc(RCReceiptInUseByOtherSubscriberError) case receiptInUseByOtherSubscriberError = 13
  @objc(RCInvalidAppUserIdError) case invalidAppUserIdError = 14
  @objc(RCOperationAlreadyInProgressForProductError) case operationAlreadyInProgressForProductError = 15
  @objc(RCUnknownBackendError) case unknownBackendError = 16
  @objc(RCInvalidAppleSubscriptionKeyError) case invalidAppleSubscriptionKeyError = 17
  @objc(RCIneligibleError) case ineligibleError = 18
  @objc(RCInsufficientPermissionsError) case insufficientPermissionsError = 19
  @objc(RCPaymentPendingError) case paymentPendingError = 20
  @objc(RCInvalidSubscriberAttributesError) case invalidSubscriberAttributesError = 21
  @objc(RCLogOutAnonymousUserError) case logOutAnonymousUserError = 22
  @objc(RCConfigurationError) case configurationError = 23
  @objc(RCUnsupportedError) case unsupportedError = 24
  @objc(RCEmptySubscriberAttributesError) case emptySubscriberAttributes = 25
  @objc(RCProductDiscountMissingIdentifierError) case productDiscountMissingIdentifierError = 26
  @objc(RCProductDiscountMissingSubscriptionGroupIdentifierError) case productDiscountMissingSubscriptionGroupIdentifierError = 28
  @objc(RCCustomerInfoError) case customerInfoError = 29
  @objc(RCSystemInfoError) case systemInfoError = 30
  @objc(RCBeginRefundRequestError) case beginRefundRequestError = 31
  @objc(RCProductRequestTimedOut) case productRequestTimedOut = 32
  @objc(RCAPIEndpointBlocked) case apiEndpointBlockedError = 33
  @objc(RCInvalidPromotionalOfferError) case invalidPromotionalOfferError = 34
  @objc(RCOfflineConnectionError) case offlineConnectionError = 35
  @objc(RCFeatureNotAvailableInCustomEntitlementsComputationMode) case featureNotAvailableInCustomEntitlementsComputationMode = 36
  @objc(RCSignatureVerificationFailed) case signatureVerificationFailed = 37
  @objc(RCFeatureNotSupportedWithStoreKit1) case featureNotSupportedWithStoreKit1 = 38
  @objc(RCInvalidWebPurchaseToken) case invalidWebPurchaseToken = 39
  @objc(RCPurchaseBelongsToOtherUser) case purchaseBelongsToOtherUser = 40
  @objc(RCExpiredWebPurchaseToken) case expiredWebPurchaseToken = 41
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public static var _nsErrorDomain: Swift.String {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.ErrorCode : Swift.CaseIterable {
  public typealias AllCases = [RevenueCat.ErrorCode]
  nonisolated public static var allCases: [RevenueCat.ErrorCode] {
    get
  }
}
extension RevenueCat.ErrorCode {
  public var description: Swift.String {
    get
  }
}
extension RevenueCat.ErrorCode : Foundation.CustomNSError {
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
@objc(RCPurchasesAreCompletedBy) public enum PurchasesAreCompletedBy : Swift.Int {
  case revenueCat
  case myApp
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.PurchasesAreCompletedBy : Swift.Sendable {
}
@objc(RCRefundRequestStatus) public enum RefundRequestStatus : Swift.Int, Swift.Sendable {
  @objc(RCRefundRequestUserCancelled) case userCancelled = 0
  @objc(RCRefundRequestSuccess) case success
  @objc(RCRefundRequestError) case error
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum CustomerCenterPresentationMode {
  case sheet
  case fullScreen
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.CustomerCenterPresentationMode {
  public static let `default`: RevenueCat.CustomerCenterPresentationMode
}
extension RevenueCat.CustomerCenterPresentationMode : Swift.CaseIterable {
  public static var allCases: [RevenueCat.CustomerCenterPresentationMode] {
    get
  }
  public typealias AllCases = [RevenueCat.CustomerCenterPresentationMode]
}
extension RevenueCat.CustomerCenterPresentationMode : Swift.Equatable, Swift.Sendable {
  public static func == (a: RevenueCat.CustomerCenterPresentationMode, b: RevenueCat.CustomerCenterPresentationMode) -> Swift.Bool
}
extension RevenueCat.CustomerCenterPresentationMode : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@objc @_hasMissingDesignatedInitializers public class PurchasesReceiptParser : ObjectiveC.NSObject {
  public func parse(from receiptData: Foundation.Data) throws -> RevenueCat.AppleReceipt
  @objc deinit
}
extension RevenueCat.PurchasesReceiptParser {
  public func parse(base64String string: Swift.String) throws -> RevenueCat.AppleReceipt
}
extension RevenueCat.PurchasesReceiptParser : @unchecked Swift.Sendable {
}
extension RevenueCat.Purchases {
  @objc(RCPlatformInfo) final public class PlatformInfo : ObjectiveC.NSObject {
    @objc public init(flavor: Swift.String, version: Swift.String)
    @objc deinit
  }
  @objc public static var platformInfo: RevenueCat.Purchases.PlatformInfo?
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(RCDangerousSettings) final public class DangerousSettings : ObjectiveC.NSObject {
  @objc final public let autoSyncPurchases: Swift.Bool
  @objc final public let customEntitlementComputation: Swift.Bool
  @objc override convenience dynamic public init()
  @objc convenience public init(autoSyncPurchases: Swift.Bool = true)
  @objc deinit
}
extension RevenueCat.DangerousSettings : Swift.Sendable {
}
public typealias ProductIdentifier = Swift.String
@_hasMissingDesignatedInitializers @objc(RCCustomerInfo) final public class CustomerInfo : ObjectiveC.NSObject {
  @objc final public let entitlements: RevenueCat.EntitlementInfos
  @objc final public var activeSubscriptions: Swift.Set<RevenueCat.ProductIdentifier> {
    @objc get
  }
  @objc final public let allPurchasedProductIdentifiers: Swift.Set<RevenueCat.ProductIdentifier>
  @objc final public var latestExpirationDate: Foundation.Date? {
    @objc get
  }
  @objc final public let nonSubscriptions: [RevenueCat.NonSubscriptionTransaction]
  @objc final public let requestDate: Foundation.Date
  @objc final public let firstSeen: Foundation.Date
  @objc final public let originalAppUserId: Swift.String
  @objc final public let managementURL: Foundation.URL?
  @objc final public let originalPurchaseDate: Foundation.Date?
  @objc final public let originalApplicationVersion: Swift.String?
  @objc final public let subscriptionsByProductIdentifier: [RevenueCat.ProductIdentifier : RevenueCat.SubscriptionInfo]
  @objc final public func expirationDate(forProductIdentifier productIdentifier: RevenueCat.ProductIdentifier) -> Foundation.Date?
  @objc final public func purchaseDate(forProductIdentifier productIdentifier: RevenueCat.ProductIdentifier) -> Foundation.Date?
  @objc final public func expirationDate(forEntitlement entitlementIdentifier: Swift.String) -> Foundation.Date?
  @objc final public func purchaseDate(forEntitlement entitlementIdentifier: Swift.String) -> Foundation.Date?
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.CustomerInfo : RevenueCat.RawDataContainer {
  @objc final public var rawData: [Swift.String : Any] {
    @objc get
  }
  public typealias Content = [Swift.String : Any]
}
extension RevenueCat.CustomerInfo : Swift.Sendable {
}
extension RevenueCat.CustomerInfo : Swift.Codable {
  convenience public init(from decoder: any Swift.Decoder) throws
  final public func encode(to encoder: any Swift.Encoder) throws
}
extension RevenueCat.CustomerInfo : Swift.Identifiable {
  final public var id: Swift.String {
    get
  }
  public typealias ID = Swift.String
}
extension RevenueCat.PaywallComponent {
  public enum Background : Swift.Codable, Swift.Sendable, Swift.Hashable {
    case color(RevenueCat.PaywallComponent.ColorScheme)
    case image(RevenueCat.PaywallComponent.ThemeImageUrls, RevenueCat.PaywallComponent.FitMode)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public static func == (a: RevenueCat.PaywallComponent.Background, b: RevenueCat.PaywallComponent.Background) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension RevenueCat.AppleReceipt {
  public struct InAppPurchase : Swift.Equatable {
    public let quantity: Swift.Int
    public let productId: Swift.String
    public let transactionId: Swift.String
    public let originalTransactionId: Swift.String?
    public let productType: RevenueCat.AppleReceipt.InAppPurchase.ProductType
    public let purchaseDate: Foundation.Date
    public let originalPurchaseDate: Foundation.Date?
    public let expiresDate: Foundation.Date?
    public let cancellationDate: Foundation.Date?
    public let isInTrialPeriod: Swift.Bool?
    public let isInIntroOfferPeriod: Swift.Bool?
    public let webOrderLineItemId: Swift.Int64?
    public let promotionalOfferIdentifier: Swift.String?
    public static func == (a: RevenueCat.AppleReceipt.InAppPurchase, b: RevenueCat.AppleReceipt.InAppPurchase) -> Swift.Bool
  }
}
extension RevenueCat.AppleReceipt.InAppPurchase {
  public enum ProductType : Swift.Int {
    case unknown
    case nonConsumable
    case consumable
    case nonRenewingSubscription
    case autoRenewableSubscription
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension RevenueCat.AppleReceipt.InAppPurchase.ProductType : Swift.Sendable {
}
extension RevenueCat.AppleReceipt.InAppPurchase : Swift.Sendable {
}
extension RevenueCat.AppleReceipt.InAppPurchase.ProductType : Swift.Codable {
}
extension RevenueCat.AppleReceipt.InAppPurchase : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.AppleReceipt.InAppPurchase : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@objc(RCStore) public enum Store : Swift.Int {
  @objc(RCAppStore) case appStore = 0
  @objc(RCMacAppStore) case macAppStore = 1
  @objc(RCPlayStore) case playStore = 2
  @objc(RCStripe) case stripe = 3
  @objc(RCPromotional) case promotional = 4
  @objc(RCUnknownStore) case unknownStore = 5
  @objc(RCAmazon) case amazon = 6
  @objc(RCBilling) case rcBilling = 7
  @objc(RCExternal) case external = 8
  @objc(RCPaddle) case paddle = 9
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.Store : Swift.CaseIterable {
  public typealias AllCases = [RevenueCat.Store]
  nonisolated public static var allCases: [RevenueCat.Store] {
    get
  }
}
extension RevenueCat.Store : Swift.Sendable {
}
@objc(RCPeriodType) public enum PeriodType : Swift.Int {
  @objc(RCNormal) case normal = 0
  @objc(RCIntro) case intro = 1
  @objc(RCTrial) case trial = 2
  @objc(RCPrepaid) case prepaid = 3
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.PeriodType : Swift.CaseIterable {
  public typealias AllCases = [RevenueCat.PeriodType]
  nonisolated public static var allCases: [RevenueCat.PeriodType] {
    get
  }
}
extension RevenueCat.PeriodType : Swift.Sendable {
}
@_hasMissingDesignatedInitializers @objc(RCEntitlementInfo) final public class EntitlementInfo : ObjectiveC.NSObject {
  @objc final public var identifier: Swift.String {
    @objc get
  }
  @objc final public var isActive: Swift.Bool {
    @objc get
  }
  @objc final public var willRenew: Swift.Bool {
    @objc get
  }
  @objc final public var periodType: RevenueCat.PeriodType {
    @objc get
  }
  @objc final public var latestPurchaseDate: Foundation.Date? {
    @objc get
  }
  @objc final public var originalPurchaseDate: Foundation.Date? {
    @objc get
  }
  @objc final public var expirationDate: Foundation.Date? {
    @objc get
  }
  @objc final public var store: RevenueCat.Store {
    @objc get
  }
  @objc final public var productIdentifier: Swift.String {
    @objc get
  }
  @objc final public var productPlanIdentifier: Swift.String? {
    @objc get
  }
  @objc final public var isSandbox: Swift.Bool {
    @objc get
  }
  @objc final public var unsubscribeDetectedAt: Foundation.Date? {
    @objc get
  }
  @objc final public var billingIssueDetectedAt: Foundation.Date? {
    @objc get
  }
  @objc final public var ownershipType: RevenueCat.PurchaseOwnershipType {
    @objc get
  }
  @objc final public var verification: RevenueCat.VerificationResult {
    @objc get
  }
  @objc final public let rawData: [Swift.String : Any]
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.EntitlementInfo : RevenueCat.RawDataContainer {
  public typealias Content = [Swift.String : Any]
}
extension RevenueCat.EntitlementInfo : @unchecked Swift.Sendable {
}
extension RevenueCat.EntitlementInfo {
  @objc final public var isActiveInCurrentEnvironment: Swift.Bool {
    @objc get
  }
  @objc final public var isActiveInAnyEnvironment: Swift.Bool {
    @objc get
  }
}
extension RevenueCat.EntitlementInfo : Swift.Identifiable {
  final public var id: Swift.String {
    get
  }
  public typealias ID = Swift.String
}
@objc(RCVirtualCurrency) final public class VirtualCurrency : ObjectiveC.NSObject {
  @objc final public let balance: Swift.Int
  @objc final public let name: Swift.String
  @objc final public let code: Swift.String
  @objc final public let serverDescription: Swift.String?
  @objc deinit
}
extension RevenueCat.VirtualCurrency : Swift.Codable {
  final public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.VirtualCurrency : Swift.Sendable {
}
extension RevenueCat.VirtualCurrency {
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
}
public typealias VerboseLogHandler = (_ level: RevenueCat.LogLevel, _ message: Swift.String, _ file: Swift.String?, _ function: Swift.String?, _ line: Swift.UInt) -> Swift.Void
public typealias LogHandler = (_ level: RevenueCat.LogLevel, _ message: Swift.String) -> Swift.Void
extension RevenueCat.LogLevel : Swift.Comparable {
  public static func < (lhs: RevenueCat.LogLevel, rhs: RevenueCat.LogLevel) -> Swift.Bool
}
extension RevenueCat.PurchasesReceiptParser {
  public enum Error : Swift.Error {
    case dataObjectIdentifierMissing
    case asn1ParsingError(description: Swift.String)
    case receiptParsingError
    case inAppPurchaseParsingError
    case failedToDecodeBase64String
    case receiptNotPresent
    case failedToLoadLocalReceipt(any Swift.Error)
    case foundEmptyLocalReceipt
  }
}
extension RevenueCat.PurchasesReceiptParser.Error : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@objc(RCLogLevel) public enum LogLevel : Swift.Int, Swift.CustomStringConvertible, Swift.CaseIterable, Swift.Sendable {
  case verbose = 4
  case debug = 0
  case info = 1
  case warn = 2
  case error = 3
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [RevenueCat.LogLevel]
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [RevenueCat.LogLevel] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc(RCPackageType) public enum PackageType : Swift.Int {
  case unknown = -2, custom, lifetime, annual, sixMonth, threeMonth, twoMonth, monthly, weekly
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.PackageType : Swift.CaseIterable {
  public typealias AllCases = [RevenueCat.PackageType]
  nonisolated public static var allCases: [RevenueCat.PackageType] {
    get
  }
}
extension RevenueCat.PackageType : Swift.Sendable {
}
extension RevenueCat.PackageType : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RevenueCat.PackageType : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers @objc(RCSubscriptionInfo) final public class SubscriptionInfo : ObjectiveC.NSObject {
  @objc final public let productIdentifier: RevenueCat.ProductIdentifier
  @objc final public let purchaseDate: Foundation.Date
  @objc final public let originalPurchaseDate: Foundation.Date?
  @objc final public let expiresDate: Foundation.Date?
  @objc final public let store: RevenueCat.Store
  @objc final public let isSandbox: Swift.Bool
  @objc final public let unsubscribeDetectedAt: Foundation.Date?
  @objc final public let billingIssuesDetectedAt: Foundation.Date?
  @objc final public let gracePeriodExpiresDate: Foundation.Date?
  @objc final public let ownershipType: RevenueCat.PurchaseOwnershipType
  @objc final public let periodType: RevenueCat.PeriodType
  @objc final public let refundedAt: Foundation.Date?
  @objc final public let storeTransactionId: Swift.String?
  @objc final public let isActive: Swift.Bool
  @objc final public let willRenew: Swift.Bool
  @objc final public let price: RevenueCat.ProductPaidPrice?
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.SubscriptionInfo : Swift.Sendable {
}
public enum WebPurchaseRedemptionResult : Swift.Sendable {
  case success(_: RevenueCat.CustomerInfo)
  case error(_: RevenueCat.PublicError)
  case invalidToken
  case purchaseBelongsToOtherUser
  case expired(_: Swift.String)
}
public typealias SK1Transaction = StoreKit.SKPaymentTransaction
@available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
public typealias SK2Transaction = StoreKit.Transaction
@_hasMissingDesignatedInitializers @objc(RCStoreTransaction) final public class StoreTransaction : ObjectiveC.NSObject {
  @objc final public var productIdentifier: Swift.String {
    @objc get
  }
  @objc final public var purchaseDate: Foundation.Date {
    @objc get
  }
  @objc final public var transactionIdentifier: Swift.String {
    @objc get
  }
  @objc final public var quantity: Swift.Int {
    @objc get
  }
  @objc final public var storefront: RevenueCat.Storefront? {
    @objc get
  }
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.StoreTransaction {
  @objc final public var sk1Transaction: RevenueCat.SK1Transaction? {
    @objc get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  final public var sk2Transaction: RevenueCat.SK2Transaction? {
    get
  }
}
extension RevenueCat.StoreTransaction : Swift.Identifiable {
  final public var id: Swift.String {
    get
  }
  public typealias ID = Swift.String
}
extension RevenueCat.PaywallComponent {
  final public class StackComponent : RevenueCat.PaywallComponentBase {
    public enum Overflow : Swift.String, RevenueCat.PaywallComponentBase {
      case `default`
      case scroll
      public init(from decoder: any Swift.Decoder) throws
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    final public let visible: Swift.Bool?
    final public let components: [RevenueCat.PaywallComponent]
    final public let size: RevenueCat.PaywallComponent.Size
    final public let spacing: CoreFoundation.CGFloat?
    final public let backgroundColor: RevenueCat.PaywallComponent.ColorScheme?
    final public let background: RevenueCat.PaywallComponent.Background?
    final public let dimension: RevenueCat.PaywallComponent.Dimension
    final public let padding: RevenueCat.PaywallComponent.Padding
    final public let margin: RevenueCat.PaywallComponent.Padding
    final public let shape: RevenueCat.PaywallComponent.Shape?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    final public let badge: RevenueCat.PaywallComponent.Badge?
    final public let overflow: RevenueCat.PaywallComponent.StackComponent.Overflow?
    final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialStackComponent>?
    public init(visible: Swift.Bool? = nil, components: [RevenueCat.PaywallComponent], dimension: RevenueCat.PaywallComponent.Dimension = .vertical(.center, .start), size: RevenueCat.PaywallComponent.Size = .init(width: .fill, height: .fit), spacing: CoreFoundation.CGFloat? = nil, backgroundColor: RevenueCat.PaywallComponent.ColorScheme? = nil, background: RevenueCat.PaywallComponent.Background? = nil, padding: RevenueCat.PaywallComponent.Padding = .zero, margin: RevenueCat.PaywallComponent.Padding = .zero, shape: RevenueCat.PaywallComponent.Shape? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil, badge: RevenueCat.PaywallComponent.Badge? = nil, overflow: RevenueCat.PaywallComponent.StackComponent.Overflow? = nil, overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialStackComponent>? = nil)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.StackComponent, rhs: RevenueCat.PaywallComponent.StackComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class PartialStackComponent : RevenueCat.PaywallPartialComponent {
    final public let visible: Swift.Bool?
    final public let size: RevenueCat.PaywallComponent.Size?
    final public let spacing: CoreFoundation.CGFloat?
    final public let backgroundColor: RevenueCat.PaywallComponent.ColorScheme?
    final public let background: RevenueCat.PaywallComponent.Background?
    final public let dimension: RevenueCat.PaywallComponent.Dimension?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let shape: RevenueCat.PaywallComponent.Shape?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    final public let overflow: RevenueCat.PaywallComponent.StackComponent.Overflow?
    final public let badge: RevenueCat.PaywallComponent.Badge?
    public init(visible: Swift.Bool? = true, dimension: RevenueCat.PaywallComponent.Dimension? = nil, size: RevenueCat.PaywallComponent.Size? = nil, spacing: CoreFoundation.CGFloat? = nil, backgroundColor: RevenueCat.PaywallComponent.ColorScheme? = nil, background: RevenueCat.PaywallComponent.Background? = nil, padding: RevenueCat.PaywallComponent.Padding? = nil, margin: RevenueCat.PaywallComponent.Padding? = nil, shape: RevenueCat.PaywallComponent.Shape? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil, overflow: RevenueCat.PaywallComponent.StackComponent.Overflow? = nil, badge: RevenueCat.PaywallComponent.Badge? = nil)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PartialStackComponent, rhs: RevenueCat.PaywallComponent.PartialStackComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension RevenueCat.PaywallComponent {
  final public class PackageComponent : RevenueCat.PaywallComponentBase {
    final public let packageID: Swift.String
    final public let isSelectedByDefault: Swift.Bool
    final public let stack: RevenueCat.PaywallComponent.StackComponent
    public init(packageID: Swift.String, isSelectedByDefault: Swift.Bool, applePromoOfferProductCode: Swift.String?, stack: RevenueCat.PaywallComponent.StackComponent)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PackageComponent, rhs: RevenueCat.PaywallComponent.PackageComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
public protocol RawDataContainer {
  associatedtype Content
  var rawData: Self.Content { get }
}
public typealias PurchaseResultData = (transaction: RevenueCat.StoreTransaction?, customerInfo: RevenueCat.CustomerInfo, userCancelled: Swift.Bool)
public typealias PurchaseCompletedBlock = @_Concurrency.MainActor @Sendable (RevenueCat.StoreTransaction?, RevenueCat.CustomerInfo?, RevenueCat.PublicError?, Swift.Bool) -> Swift.Void
@_hasMissingDesignatedInitializers public class A {
  @objc deinit
}
@_hasMissingDesignatedInitializers public class B {
  @objc deinit
}
public typealias GetStorefrontBlock = @_Concurrency.MainActor @Sendable (RevenueCat.Storefront?) -> Swift.Void
public typealias StartPurchaseBlock = (@escaping RevenueCat.PurchaseCompletedBlock) -> Swift.Void
@_hasMissingDesignatedInitializers @objc(RCPurchases) final public class Purchases : ObjectiveC.NSObject, RevenueCat.PurchasesType, RevenueCat.PurchasesSwiftType {
  @objc(sharedPurchases) public static var shared: RevenueCat.Purchases {
    @objc get
  }
  @objc public static var isConfigured: Swift.Bool {
    @objc get
  }
  @objc final public var delegate: (any RevenueCat.PurchasesDelegate)? {
    @objc get
    @objc set
  }
  @objc public static var logLevel: RevenueCat.LogLevel {
    @objc get
    @objc set
  }
  @objc public static var proxyURL: Foundation.URL? {
    @objc get
    @objc set
  }
  @objc public static var forceUniversalAppStore: Swift.Bool {
    @objc get
    @objc set
  }
  @available(iOS 8.0, macOS 10.14, watchOS 6.2, macCatalyst 13.0, *)
  @objc public static var simulatesAskToBuyInSandbox: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public static func canMakePayments() -> Swift.Bool
  @objc public static var logHandler: RevenueCat.LogHandler {
    @objc get
    @objc set
  }
  @objc public static var verboseLogHandler: RevenueCat.VerboseLogHandler {
    @objc get
    @objc set
  }
  @objc public static var verboseLogs: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public static var frameworkVersion: Swift.String {
    @objc get
  }
  @objc final public let attribution: RevenueCat.Attribution
  @objc final public var purchasesAreCompletedBy: RevenueCat.PurchasesAreCompletedBy {
    @objc get
    @objc set
  }
  @objc final public var storeFrontCountryCode: Swift.String? {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.Purchases {
  @objc final public var appUserID: Swift.String {
    @objc get
  }
  @objc final public var isAnonymous: Swift.Bool {
    @objc get
  }
  @objc final public var isSandbox: Swift.Bool {
    @objc get
  }
  @objc final public func getOfferings(completion: @escaping (RevenueCat.Offerings?, RevenueCat.PublicError?) -> Swift.Void)
  @objc final public func offerings() async throws -> RevenueCat.Offerings
  @objc final public var cachedOfferings: RevenueCat.Offerings? {
    @objc get
  }
}
extension RevenueCat.Purchases {
  @available(*, deprecated, message: "The appUserID passed to logIn is a constant string known at compile time.\nThis is likely a programmer error. This ID is used to identify the current user.\nSee https://docs.revenuecat.com/docs/user-ids for more information.")
  final public func logIn(_ appUserID: Swift.StaticString, completion: @escaping (RevenueCat.CustomerInfo?, Swift.Bool, RevenueCat.PublicError?) -> Swift.Void)
  @_disfavoredOverload @objc(logIn:completion:) final public func logIn(_ appUserID: Swift.String, completion: @escaping (RevenueCat.CustomerInfo?, Swift.Bool, RevenueCat.PublicError?) -> Swift.Void)
  final public func logIn(_ appUserID: Swift.StaticString) async throws -> (customerInfo: RevenueCat.CustomerInfo, created: Swift.Bool)
  @_disfavoredOverload @objc final public func logIn(_ appUserID: Swift.String) async throws -> (customerInfo: RevenueCat.CustomerInfo, created: Swift.Bool)
  @objc final public func logOut(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)?)
  @objc final public func logOut() async throws -> RevenueCat.CustomerInfo
  @objc final public func syncAttributesAndOfferingsIfNeeded(completion: @escaping (RevenueCat.Offerings?, RevenueCat.PublicError?) -> Swift.Void)
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  @objc final public func syncAttributesAndOfferingsIfNeeded() async throws -> RevenueCat.Offerings?
  @objc final public func getStorefront(completion: @escaping RevenueCat.GetStorefrontBlock)
  @objc final public func getStorefront() async -> RevenueCat.Storefront?
}
extension RevenueCat.Purchases {
  @objc final public func getCustomerInfo(completion: @escaping (RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)
  @objc final public func getCustomerInfo(fetchPolicy: RevenueCat.CacheFetchPolicy, completion: @escaping (RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)
  @objc final public func customerInfo() async throws -> RevenueCat.CustomerInfo
  @objc final public func customerInfo(fetchPolicy: RevenueCat.CacheFetchPolicy) async throws -> RevenueCat.CustomerInfo
  @objc final public var cachedCustomerInfo: RevenueCat.CustomerInfo? {
    @objc get
  }
  final public var customerInfoStream: _Concurrency.AsyncStream<RevenueCat.CustomerInfo> {
    get
  }
  @objc(getProductsWithIdentifiers:completion:) final public func getProducts(_ productIdentifiers: [Swift.String], completion: @escaping ([RevenueCat.StoreProduct]) -> Swift.Void)
  @objc final public func products(_ productIdentifiers: [Swift.String]) async -> [RevenueCat.StoreProduct]
  @objc(purchaseProduct:withCompletion:) final public func purchase(product: RevenueCat.StoreProduct, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc final public func purchase(product: RevenueCat.StoreProduct) async throws -> RevenueCat.PurchaseResultData
  @objc(purchasePackage:withCompletion:) final public func purchase(package: RevenueCat.Package, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc final public func purchase(package: RevenueCat.Package) async throws -> RevenueCat.PurchaseResultData
  @objc final public func restorePurchases(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)? = nil)
  @objc final public func restorePurchases() async throws -> RevenueCat.CustomerInfo
  @objc(purchaseWithParams:completion:) final public func purchase(_ params: RevenueCat.PurchaseParams, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc final public func purchase(_ params: RevenueCat.PurchaseParams) async throws -> RevenueCat.PurchaseResultData
  @objc(purchaseProduct:withPromotionalOffer:completion:) final public func purchase(product: RevenueCat.StoreProduct, promotionalOffer: RevenueCat.PromotionalOffer, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc final public func purchase(product: RevenueCat.StoreProduct, promotionalOffer: RevenueCat.PromotionalOffer) async throws -> RevenueCat.PurchaseResultData
  @objc(purchasePackage:withPromotionalOffer:completion:) final public func purchase(package: RevenueCat.Package, promotionalOffer: RevenueCat.PromotionalOffer, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc final public func purchase(package: RevenueCat.Package, promotionalOffer: RevenueCat.PromotionalOffer) async throws -> RevenueCat.PurchaseResultData
  @objc final public func invalidateCustomerInfoCache()
  @objc final public func syncPurchases(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)?)
  @objc final public func syncPurchases() async throws -> RevenueCat.CustomerInfo
  @objc(checkTrialOrIntroDiscountEligibility:completion:) final public func checkTrialOrIntroDiscountEligibility(productIdentifiers: [Swift.String], completion: @escaping ([Swift.String : RevenueCat.IntroEligibility]) -> Swift.Void)
  @objc final public func checkTrialOrIntroDiscountEligibility(productIdentifiers: [Swift.String]) async -> [Swift.String : RevenueCat.IntroEligibility]
  final public func checkTrialOrIntroDiscountEligibility(packages: [RevenueCat.Package]) async -> [RevenueCat.Package : RevenueCat.IntroEligibility]
  @objc(checkTrialOrIntroDiscountEligibilityForProduct:completion:) final public func checkTrialOrIntroDiscountEligibility(product: RevenueCat.StoreProduct, completion: @escaping (RevenueCat.IntroEligibilityStatus) -> Swift.Void)
  @objc final public func checkTrialOrIntroDiscountEligibility(product: RevenueCat.StoreProduct) async -> RevenueCat.IntroEligibilityStatus
  @available(iOS 13.4, macCatalyst 13.4, *)
  @objc final public func showPriceConsentIfNeeded()
  @available(iOS 14.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @available(macOS, unavailable)
  @available(macCatalyst, unavailable)
  @objc final public func presentCodeRedemptionSheet()
  @objc(getPromotionalOfferForProductDiscount:withProduct:withCompletion:) final public func getPromotionalOffer(forProductDiscount discount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct, completion: @escaping (RevenueCat.PromotionalOffer?, RevenueCat.PublicError?) -> Swift.Void)
  @objc final public func promotionalOffer(forProductDiscount discount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct) async throws -> RevenueCat.PromotionalOffer
  @objc final public func eligiblePromotionalOffers(forProduct product: RevenueCat.StoreProduct) async -> [RevenueCat.PromotionalOffer]
  @available(iOS 13.0, macOS 10.15, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc final public func showManageSubscriptions(completion: @escaping (RevenueCat.PublicError?) -> Swift.Void)
  @available(iOS 13.0, macOS 10.15, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc final public func showManageSubscriptions() async throws
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForProduct:completion:) final public func beginRefundRequest(forProduct productID: Swift.String) async throws -> RevenueCat.RefundRequestStatus
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForEntitlement:completion:) final public func beginRefundRequest(forEntitlement entitlementID: Swift.String) async throws -> RevenueCat.RefundRequestStatus
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForActiveEntitlementWithCompletion:) final public func beginRefundRequestForActiveEntitlement() async throws -> RevenueCat.RefundRequestStatus
  @available(iOS 16.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  final public func showStoreMessages(for types: Swift.Set<RevenueCat.StoreMessageType> = Set(StoreMessageType.allCases)) async
  @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
  final public func recordPurchase(_ purchaseResult: StoreKit.Product.PurchaseResult) async throws -> RevenueCat.StoreTransaction?
  @objc final public func redeemWebPurchase(webPurchaseRedemption: RevenueCat.WebPurchaseRedemption, completion: @escaping (RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)
  final public func redeemWebPurchase(_ webPurchaseRedemption: RevenueCat.WebPurchaseRedemption) async -> RevenueCat.WebPurchaseRedemptionResult
}
extension RevenueCat.Purchases {
  @objc final public func getVirtualCurrencies(completion: @escaping @Sendable (RevenueCat.VirtualCurrencies?, RevenueCat.PublicError?) -> Swift.Void)
  @objc final public var cachedVirtualCurrencies: RevenueCat.VirtualCurrencies? {
    @objc get
  }
  final public func virtualCurrencies() async throws -> RevenueCat.VirtualCurrencies
  @objc final public func invalidateVirtualCurrenciesCache()
}
@available(iOS 15.0, tvOS 15.0, macOS 12.0, watchOS 8.0, *)
extension RevenueCat.Purchases {
  final public func track(paywallEvent: RevenueCat.PaywallEvent) async
  @available(iOS 15.0, macOS 12.0, watchOS 8.0, tvOS 15.0, *)
  public static let paywallImageDownloadSession: Foundation.URLSession
}
extension RevenueCat.Purchases {
  @discardableResult
  @objc(configureWithConfiguration:) public static func configure(with configuration: RevenueCat.Configuration) -> RevenueCat.Purchases
  @discardableResult
  @objc(configureWithConfigurationBuilder:) public static func configure(with builder: RevenueCat.Configuration.Builder) -> RevenueCat.Purchases
  @discardableResult
  @objc(configureWithAPIKey:) public static func configure(withAPIKey apiKey: Swift.String) -> RevenueCat.Purchases
  @discardableResult
  @_disfavoredOverload @objc(configureWithAPIKey:appUserID:) public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.String?) -> RevenueCat.Purchases
  @available(*, deprecated, message: "The appUserID passed to logIn is a constant string known at compile time.\nThis is likely a programmer error. This ID is used to identify the current user.\nSee https://docs.revenuecat.com/docs/user-ids for more information.")
  @discardableResult
  public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.StaticString) -> RevenueCat.Purchases
  @discardableResult
  @_disfavoredOverload @objc(configureWithAPIKey:appUserID:purchasesAreCompletedBy:storeKitVersion:) public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.String?, purchasesAreCompletedBy: RevenueCat.PurchasesAreCompletedBy, storeKitVersion: RevenueCat.StoreKitVersion) -> RevenueCat.Purchases
  @available(*, deprecated, message: "The appUserID passed to logIn is a constant string known at compile time.\nThis is likely a programmer error. This ID is used to identify the current user.\nSee https://docs.revenuecat.com/docs/user-ids for more information.")
  @discardableResult
  public static func configure(withAPIKey apiKey: Swift.String, appUserID: Swift.StaticString, purchasesAreCompletedBy: RevenueCat.PurchasesAreCompletedBy, storeKitVersion: RevenueCat.StoreKitVersion) -> RevenueCat.Purchases
}
extension RevenueCat.Purchases {
  @available(*, deprecated, message: "use Purchases.logLevel instead")
  @objc public static var debugLogsEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "Configure behavior through the RevenueCat dashboard instead. If you have configured the \"Legacy\" restore\nbehavior in the [RevenueCat Dashboard](app.revenuecat.com) and are currently setting this to `true`, keep\nthis setting active.")
  @objc final public var allowSharingAppStoreAccount: Swift.Bool {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "Use ``purchasesAreCompletedBy`` instead.")
  @objc final public var finishTransactions: Swift.Bool {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "Use the set<NetworkId> functions instead")
  @objc public static func addAttributionData(_ data: [Swift.String : Any], fromNetwork network: RevenueCat.AttributionNetwork)
  @available(*, deprecated, message: "Use the set<NetworkId> functions instead")
  @objc(addAttributionData:fromNetwork:forNetworkUserId:) public static func addAttributionData(_ data: [Swift.String : Any], from network: RevenueCat.AttributionNetwork, forNetworkUserId networkUserId: Swift.String?)
}
extension RevenueCat.Purchases : @unchecked Swift.Sendable {
}
@available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
extension RevenueCat.Purchases {
  final public func eligibleWinBackOffers(forProduct product: RevenueCat.StoreProduct) async throws -> [RevenueCat.WinBackOffer]
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  final public func eligibleWinBackOffers(forPackage package: RevenueCat.Package) async throws -> [RevenueCat.WinBackOffer]
  @objc final public func eligibleWinBackOffers(forProduct product: RevenueCat.StoreProduct, completion: @escaping @Sendable ([RevenueCat.WinBackOffer]?, RevenueCat.PublicError?) -> Swift.Void)
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  @objc final public func eligibleWinBackOffers(forPackage package: RevenueCat.Package, completion: @escaping @Sendable ([RevenueCat.WinBackOffer]?, RevenueCat.PublicError?) -> Swift.Void)
}
@objc(RCSubscriptionPeriod) final public class SubscriptionPeriod : ObjectiveC.NSObject {
  @objc final public let value: Swift.Int
  @objc final public let unit: RevenueCat.SubscriptionPeriod.Unit
  public init(value: Swift.Int, unit: RevenueCat.SubscriptionPeriod.Unit)
  @objc(RCSubscriptionPeriodUnit) public enum Unit : Swift.Int {
    case day = 0
    case week = 1
    case month = 2
    case year = 3
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.SubscriptionPeriod {
  @available(iOS, unavailable, renamed: "value")
  @available(tvOS, unavailable, renamed: "value")
  @available(watchOS, unavailable, renamed: "value")
  @available(macOS, unavailable, renamed: "value")
  @objc final public var numberOfUnits: Swift.Int {
    @objc get
  }
}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.Sendable {
}
extension RevenueCat.SubscriptionPeriod : Swift.Sendable {
}
extension RevenueCat.SubscriptionPeriod {
  final public func numberOfUnitsAs(unit: RevenueCat.SubscriptionPeriod.Unit) -> Foundation.Decimal
}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RevenueCat.SubscriptionPeriod {
  @objc override final public var debugDescription: Swift.String {
    @objc get
  }
}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.Encodable {
}
extension RevenueCat.SubscriptionPeriod : Swift.Encodable {
  final public func encode(to encoder: any Swift.Encoder) throws
}
@objc(RCPurchaseOwnershipType) public enum PurchaseOwnershipType : Swift.Int {
  case purchased = 0
  case familyShared = 1
  case unknown = 2
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.PurchaseOwnershipType : Swift.CaseIterable {
  public typealias AllCases = [RevenueCat.PurchaseOwnershipType]
  nonisolated public static var allCases: [RevenueCat.PurchaseOwnershipType] {
    get
  }
}
extension RevenueCat.PurchaseOwnershipType : Swift.Sendable {
}
@_hasMissingDesignatedInitializers @available(iOS 16.0, *)
@objc(RCDebugViewController) @_Concurrency.MainActor @preconcurrency final public class DebugViewController : UIKit.UIViewController {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc override final public func loadView()
  @_Concurrency.MainActor @preconcurrency @objc override final public func viewWillLayoutSubviews()
  @objc deinit
}
@available(iOS 16.0, *)
extension UIKit.UIViewController {
  @objc(rc_presentDebugRevenueCatOverlayAnimated:) @_Concurrency.MainActor @preconcurrency dynamic public func presentDebugRevenueCatOverlay(animated: Swift.Bool = true)
}
public struct TestStoreProduct {
  public var localizedTitle: Swift.String
  public var price: Foundation.Decimal
  public var localizedPriceString: Swift.String
  public var localizedPricePerDay: Swift.String?
  public var localizedPricePerWeek: Swift.String?
  public var localizedPricePerMonth: Swift.String?
  public var localizedPricePerYear: Swift.String?
  public var productIdentifier: Swift.String
  public var productType: RevenueCat.StoreProduct.ProductType
  public var localizedDescription: Swift.String
  public var subscriptionGroupIdentifier: Swift.String?
  public var subscriptionPeriod: RevenueCat.SubscriptionPeriod?
  public var isFamilyShareable: Swift.Bool
  public var introductoryDiscount: RevenueCat.StoreProductDiscount?
  public var discounts: [RevenueCat.StoreProductDiscount]
  public var locale: Foundation.Locale
  public init(localizedTitle: Swift.String, price: Foundation.Decimal, localizedPriceString: Swift.String, productIdentifier: Swift.String, productType: RevenueCat.StoreProduct.ProductType, localizedDescription: Swift.String, subscriptionGroupIdentifier: Swift.String? = nil, subscriptionPeriod: RevenueCat.SubscriptionPeriod? = nil, isFamilyShareable: Swift.Bool = false, introductoryDiscount: RevenueCat.TestStoreProductDiscount? = nil, discounts: [RevenueCat.TestStoreProductDiscount] = [], locale: Foundation.Locale = .current)
}
extension RevenueCat.TestStoreProduct {
  public func toStoreProduct() -> RevenueCat.StoreProduct
}
extension RevenueCat.PaywallData {
  public var locale: Foundation.Locale? {
    get
  }
  public var localizedConfiguration: RevenueCat.PaywallData.LocalizedConfiguration? {
    get
  }
  public var localizedConfigurationByTier: [Swift.String : RevenueCat.PaywallData.LocalizedConfiguration]? {
    get
  }
}
extension RevenueCat.PaywallComponent {
  final public class PurchaseButtonComponent : RevenueCat.PaywallComponentBase {
    final public let stack: RevenueCat.PaywallComponent.StackComponent
    final public let action: RevenueCat.PaywallComponent.PurchaseButtonComponent.Action?
    final public let method: RevenueCat.PaywallComponent.PurchaseButtonComponent.Method?
    public enum Action : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      case inAppCheckout
      case webCheckout
      case webProductSelection
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public enum Method : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      case inAppCheckout
      case webCheckout(RevenueCat.PaywallComponent.PurchaseButtonComponent.WebCheckout)
      case webProductSelection(RevenueCat.PaywallComponent.PurchaseButtonComponent.WebCheckout)
      case customWebCheckout(RevenueCat.PaywallComponent.PurchaseButtonComponent.CustomWebCheckout)
      case unknown
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
      public static func == (a: RevenueCat.PaywallComponent.PurchaseButtonComponent.Method, b: RevenueCat.PaywallComponent.PurchaseButtonComponent.Method) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public struct WebCheckout : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      public let autoDismiss: Swift.Bool?
      public let openMethod: RevenueCat.PaywallComponent.ButtonComponent.URLMethod?
      public init(autoDismiss: Swift.Bool? = nil, openMethod: RevenueCat.PaywallComponent.ButtonComponent.URLMethod? = nil)
      public static func == (a: RevenueCat.PaywallComponent.PurchaseButtonComponent.WebCheckout, b: RevenueCat.PaywallComponent.PurchaseButtonComponent.WebCheckout) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct CustomWebCheckout : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      public struct CustomURL : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
        public let url: RevenueCat.PaywallComponent.LocalizationKey
        public let packageParam: Swift.String?
        public init(url: RevenueCat.PaywallComponent.LocalizationKey, packageParam: Swift.String? = nil)
        public static func == (a: RevenueCat.PaywallComponent.PurchaseButtonComponent.CustomWebCheckout.CustomURL, b: RevenueCat.PaywallComponent.PurchaseButtonComponent.CustomWebCheckout.CustomURL) -> Swift.Bool
        public func encode(to encoder: any Swift.Encoder) throws
        public func hash(into hasher: inout Swift.Hasher)
        public var hashValue: Swift.Int {
          get
        }
        public init(from decoder: any Swift.Decoder) throws
      }
      public init(customUrl: RevenueCat.PaywallComponent.PurchaseButtonComponent.CustomWebCheckout.CustomURL, autoDismiss: Swift.Bool? = nil, openMethod: RevenueCat.PaywallComponent.ButtonComponent.URLMethod? = nil)
      public let customUrl: RevenueCat.PaywallComponent.PurchaseButtonComponent.CustomWebCheckout.CustomURL
      public let autoDismiss: Swift.Bool?
      public let openMethod: RevenueCat.PaywallComponent.ButtonComponent.URLMethod?
      public static func == (a: RevenueCat.PaywallComponent.PurchaseButtonComponent.CustomWebCheckout, b: RevenueCat.PaywallComponent.PurchaseButtonComponent.CustomWebCheckout) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public init(stack: RevenueCat.PaywallComponent.StackComponent, action: RevenueCat.PaywallComponent.PurchaseButtonComponent.Action?, method: RevenueCat.PaywallComponent.PurchaseButtonComponent.Method?)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PurchaseButtonComponent, rhs: RevenueCat.PaywallComponent.PurchaseButtonComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension RevenueCat.PurchaseOwnershipType : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PurchaseOwnershipType : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension RevenueCat.PeriodType : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PeriodType : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension RevenueCat.PurchasesReceiptParser {
  @objc public static let `default`: RevenueCat.PurchasesReceiptParser
}
public struct AppleReceipt : Swift.Equatable {
  public let environment: RevenueCat.AppleReceipt.Environment
  public let bundleId: Swift.String
  public let applicationVersion: Swift.String
  public let originalApplicationVersion: Swift.String?
  public let opaqueValue: Foundation.Data
  public let sha1Hash: Foundation.Data
  public let creationDate: Foundation.Date
  public let expirationDate: Foundation.Date?
  public let inAppPurchases: [RevenueCat.AppleReceipt.InAppPurchase]
  public static func == (a: RevenueCat.AppleReceipt, b: RevenueCat.AppleReceipt) -> Swift.Bool
}
extension RevenueCat.AppleReceipt {
  public enum Environment : Swift.String {
    case production
    case sandbox
    case xcode
    case unknown
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension RevenueCat.AppleReceipt : Swift.Sendable {
}
extension RevenueCat.AppleReceipt.Environment : Swift.Sendable {
}
extension RevenueCat.AppleReceipt : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.AppleReceipt.Environment : Swift.Codable {
}
extension RevenueCat.AppleReceipt : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Foundation.URL {
  public var asWebPurchaseRedemption: RevenueCat.WebPurchaseRedemption? {
    get
  }
}
@objc(RCProductPaidPrice) final public class ProductPaidPrice : ObjectiveC.NSObject, Swift.Sendable {
  @objc final public let currency: Swift.String
  @objc final public let amount: Swift.Double
  public init(currency: Swift.String, amount: Swift.Double)
  @objc deinit
}
extension RevenueCat.Store : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.Store : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers @objc(RCPurchaseParams) final public class PurchaseParams : ObjectiveC.NSObject, Swift.Sendable {
  @objc(RCPurchaseParamsBuilder) public class Builder : ObjectiveC.NSObject {
    @objc public init(package: RevenueCat.Package)
    @objc public init(product: RevenueCat.StoreProduct)
    @objc public func with(promotionalOffer: RevenueCat.PromotionalOffer) -> Self
    @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    @objc public func with(winBackOffer: RevenueCat.WinBackOffer) -> Self
    @objc public func build() -> RevenueCat.PurchaseParams
    @objc deinit
  }
  @objc deinit
}
public struct UIConfig : Swift.Codable, Swift.Equatable, Swift.Sendable {
  public struct AppConfig : Swift.Codable, Swift.Equatable, Swift.Sendable {
    public var colors: [Swift.String : RevenueCat.PaywallComponent.ColorScheme]
    public var fonts: [Swift.String : RevenueCat.UIConfig.FontsConfig]
    public init(colors: [Swift.String : RevenueCat.PaywallComponent.ColorScheme], fonts: [Swift.String : RevenueCat.UIConfig.FontsConfig])
    public static func == (a: RevenueCat.UIConfig.AppConfig, b: RevenueCat.UIConfig.AppConfig) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct FontsConfig : Swift.Codable, Swift.Equatable, Swift.Sendable {
    public static func == (a: RevenueCat.UIConfig.FontsConfig, b: RevenueCat.UIConfig.FontsConfig) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct VariableConfig : Swift.Codable, Swift.Equatable, Swift.Sendable {
    public var variableCompatibilityMap: [Swift.String : Swift.String]
    public var functionCompatibilityMap: [Swift.String : Swift.String]
    public init(variableCompatibilityMap: [Swift.String : Swift.String], functionCompatibilityMap: [Swift.String : Swift.String])
    public static func == (a: RevenueCat.UIConfig.VariableConfig, b: RevenueCat.UIConfig.VariableConfig) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public var app: RevenueCat.UIConfig.AppConfig
  public var localizations: [Swift.String : [Swift.String : Swift.String]]
  public var variableConfig: RevenueCat.UIConfig.VariableConfig
  public init(app: RevenueCat.UIConfig.AppConfig, localizations: [Swift.String : [Swift.String : Swift.String]], variableConfig: RevenueCat.UIConfig.VariableConfig)
  public static func == (a: RevenueCat.UIConfig, b: RevenueCat.UIConfig) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension RevenueCat.PaywallComponent {
  final public class TimelineComponent : RevenueCat.PaywallComponentBase {
    final public let visible: Swift.Bool?
    final public let iconAlignment: RevenueCat.PaywallComponent.TimelineComponent.IconAlignment?
    final public let itemSpacing: CoreFoundation.CGFloat?
    final public let textSpacing: CoreFoundation.CGFloat?
    final public let columnGutter: CoreFoundation.CGFloat?
    final public let size: RevenueCat.PaywallComponent.Size
    final public let padding: RevenueCat.PaywallComponent.Padding
    final public let margin: RevenueCat.PaywallComponent.Padding
    final public let items: [RevenueCat.PaywallComponent.TimelineComponent.Item]
    final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialTimelineComponent>?
    public init(visible: Swift.Bool? = nil, iconAlignment: RevenueCat.PaywallComponent.TimelineComponent.IconAlignment?, itemSpacing: CoreFoundation.CGFloat?, textSpacing: CoreFoundation.CGFloat?, columnGutter: CoreFoundation.CGFloat?, size: RevenueCat.PaywallComponent.Size, padding: RevenueCat.PaywallComponent.Padding, margin: RevenueCat.PaywallComponent.Padding, items: [RevenueCat.PaywallComponent.TimelineComponent.Item], overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialTimelineComponent>?)
    public static func == (lhs: RevenueCat.PaywallComponent.TimelineComponent, rhs: RevenueCat.PaywallComponent.TimelineComponent) -> Swift.Bool
    final public func hash(into hasher: inout Swift.Hasher)
    final public class Item : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      final public let title: RevenueCat.PaywallComponent.TextComponent
      final public let description: RevenueCat.PaywallComponent.TextComponent?
      final public let icon: RevenueCat.PaywallComponent.IconComponent
      final public let connector: RevenueCat.PaywallComponent.TimelineComponent.Connector?
      final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialTimelineItem>?
      public init(title: RevenueCat.PaywallComponent.TextComponent, description: RevenueCat.PaywallComponent.TextComponent?, icon: RevenueCat.PaywallComponent.IconComponent, connector: RevenueCat.PaywallComponent.TimelineComponent.Connector, overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialTimelineItem>?)
      public static func == (lhs: RevenueCat.PaywallComponent.TimelineComponent.Item, rhs: RevenueCat.PaywallComponent.TimelineComponent.Item) -> Swift.Bool
      final public func hash(into hasher: inout Swift.Hasher)
      @objc deinit
      final public func encode(to encoder: any Swift.Encoder) throws
      final public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    final public class Connector : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      final public let width: CoreFoundation.CGFloat
      final public let color: RevenueCat.PaywallComponent.ColorScheme
      final public let margin: RevenueCat.PaywallComponent.Padding
      public init(width: CoreFoundation.CGFloat, color: RevenueCat.PaywallComponent.ColorScheme, margin: RevenueCat.PaywallComponent.Padding)
      public static func == (lhs: RevenueCat.PaywallComponent.TimelineComponent.Connector, rhs: RevenueCat.PaywallComponent.TimelineComponent.Connector) -> Swift.Bool
      final public func hash(into hasher: inout Swift.Hasher)
      @objc deinit
      final public func encode(to encoder: any Swift.Encoder) throws
      final public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public enum IconAlignment : Swift.String, Swift.Sendable, Swift.Codable, Swift.Equatable, Swift.Hashable {
      case title
      case titleAndDescription
      public init(from decoder: any Swift.Decoder) throws
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class PartialTimelineComponent : RevenueCat.PaywallPartialComponent {
    final public let visible: Swift.Bool?
    final public let iconAlignment: RevenueCat.PaywallComponent.TimelineComponent.IconAlignment?
    final public let itemSpacing: CoreFoundation.CGFloat?
    final public let textSpacing: CoreFoundation.CGFloat?
    final public let columnGutter: CoreFoundation.CGFloat?
    final public let size: RevenueCat.PaywallComponent.Size?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    public init(visible: Swift.Bool? = nil, iconAlignment: RevenueCat.PaywallComponent.TimelineComponent.IconAlignment?, itemSpacing: CoreFoundation.CGFloat?, textSpacing: CoreFoundation.CGFloat?, columnGutter: CoreFoundation.CGFloat?, size: RevenueCat.PaywallComponent.Size?, padding: RevenueCat.PaywallComponent.Padding?, margin: RevenueCat.PaywallComponent.Padding?)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PartialTimelineComponent, rhs: RevenueCat.PaywallComponent.PartialTimelineComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class PartialTimelineItem : RevenueCat.PaywallPartialComponent {
    final public let visible: Swift.Bool?
    final public let connector: RevenueCat.PaywallComponent.TimelineComponent.Connector?
    public init(visible: Swift.Bool?, connector: RevenueCat.PaywallComponent.TimelineComponent.Connector?)
    public static func == (lhs: RevenueCat.PaywallComponent.PartialTimelineItem, rhs: RevenueCat.PaywallComponent.PartialTimelineItem) -> Swift.Bool
    final public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@_hasMissingDesignatedInitializers @objc(RCEntitlementInfos) final public class EntitlementInfos : ObjectiveC.NSObject {
  @objc final public let all: [Swift.String : RevenueCat.EntitlementInfo]
  @objc final public subscript(key: Swift.String) -> RevenueCat.EntitlementInfo? {
    @objc get
  }
  @objc final public var verification: RevenueCat.VerificationResult {
    @objc get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc deinit
}
extension RevenueCat.EntitlementInfos {
  @objc final public var active: [Swift.String : RevenueCat.EntitlementInfo] {
    @objc get
  }
  @objc final public var activeInCurrentEnvironment: [Swift.String : RevenueCat.EntitlementInfo] {
    @objc get
  }
  @objc final public var activeInAnyEnvironment: [Swift.String : RevenueCat.EntitlementInfo] {
    @objc get
  }
}
extension RevenueCat.EntitlementInfos : Swift.Sendable {
}
@objc(RCStoreMessageType) public enum StoreMessageType : Swift.Int, Swift.CaseIterable, Swift.Sendable {
  case billingIssue = 0
  case priceIncreaseConsent
  case generic
  case winBackOffer
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [RevenueCat.StoreMessageType]
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [RevenueCat.StoreMessageType] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc(RCPresentedOfferingContext) final public class PresentedOfferingContext : ObjectiveC.NSObject {
  @objc(RCTargetingContext) final public class TargetingContext : ObjectiveC.NSObject {
    @objc final public let revision: Swift.Int
    @objc final public let ruleId: Swift.String
    @objc public init(revision: Swift.Int, ruleId: Swift.String)
    @objc deinit
  }
  @objc final public let offeringIdentifier: Swift.String
  @objc final public let placementIdentifier: Swift.String?
  @objc final public let targetingContext: RevenueCat.PresentedOfferingContext.TargetingContext?
  @objc public init(offeringIdentifier: Swift.String, placementIdentifier: Swift.String?, targetingContext: RevenueCat.PresentedOfferingContext.TargetingContext?)
  @objc convenience public init(offeringIdentifier: Swift.String)
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
@objc(RCPackage) final public class Package : ObjectiveC.NSObject {
  @objc final public let identifier: Swift.String
  @objc final public let packageType: RevenueCat.PackageType
  @objc final public let storeProduct: RevenueCat.StoreProduct
  @objc final public let presentedOfferingContext: RevenueCat.PresentedOfferingContext
  @objc final public var localizedPriceString: Swift.String {
    @objc get
  }
  @objc final public var localizedIntroductoryPriceString: Swift.String? {
    @objc get
  }
  @objc final public let webCheckoutUrl: Foundation.URL?
  @objc convenience public init(identifier: Swift.String, packageType: RevenueCat.PackageType, storeProduct: RevenueCat.StoreProduct, offeringIdentifier: Swift.String, webCheckoutUrl: Foundation.URL?)
  @objc public init(identifier: Swift.String, packageType: RevenueCat.PackageType, storeProduct: RevenueCat.StoreProduct, presentedOfferingContext: RevenueCat.PresentedOfferingContext, webCheckoutUrl: Foundation.URL?)
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
@objc extension RevenueCat.Package {
  @objc public static func string(from packageType: RevenueCat.PackageType) -> Swift.String?
  @objc public static func packageType(from string: Swift.String) -> RevenueCat.PackageType
  @objc final public var offeringIdentifier: Swift.String {
    @objc get
  }
}
extension RevenueCat.Package : Swift.Identifiable {
  final public var id: Swift.String {
    get
  }
  public typealias ID = Swift.String
}
extension RevenueCat.Package : Swift.Sendable {
}
extension RevenueCat.PresentedOfferingContext : Swift.Sendable {
}
extension RevenueCat.PresentedOfferingContext.TargetingContext : Swift.Sendable {
}
extension RevenueCat.PaywallComponent {
  final public class ButtonComponent : RevenueCat.PaywallComponentBase {
    final public let action: RevenueCat.PaywallComponent.ButtonComponent.Action
    final public let stack: RevenueCat.PaywallComponent.StackComponent
    public init(action: RevenueCat.PaywallComponent.ButtonComponent.Action, stack: RevenueCat.PaywallComponent.StackComponent)
    required public init(from decoder: any Swift.Decoder) throws
    final public func encode(to encoder: any Swift.Encoder) throws
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.ButtonComponent, rhs: RevenueCat.PaywallComponent.ButtonComponent) -> Swift.Bool
    public enum Action : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      case restorePurchases
      case navigateBack
      case navigateTo(destination: RevenueCat.PaywallComponent.ButtonComponent.Destination)
      case unknown
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
      public static func == (a: RevenueCat.PaywallComponent.ButtonComponent.Action, b: RevenueCat.PaywallComponent.ButtonComponent.Action) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Destination : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      case customerCenter
      case offerCode
      case privacyPolicy(urlLid: Swift.String, method: RevenueCat.PaywallComponent.ButtonComponent.URLMethod)
      case sheet(sheet: RevenueCat.PaywallComponent.ButtonComponent.Sheet)
      case terms(urlLid: Swift.String, method: RevenueCat.PaywallComponent.ButtonComponent.URLMethod)
      case webPaywallLink(urlLid: Swift.String, method: RevenueCat.PaywallComponent.ButtonComponent.URLMethod)
      case url(urlLid: Swift.String, method: RevenueCat.PaywallComponent.ButtonComponent.URLMethod)
      case unknown
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
      public static func == (a: RevenueCat.PaywallComponent.ButtonComponent.Destination, b: RevenueCat.PaywallComponent.ButtonComponent.Destination) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum URLMethod : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      case inAppBrowser
      case externalBrowser
      case deepLink
      case unknown
      public init(from decoder: any Swift.Decoder) throws
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public struct Sheet : Swift.Codable, Swift.Hashable, Swift.Sendable {
      public let id: Swift.String
      public let name: Swift.String?
      public let stack: RevenueCat.PaywallComponent.StackComponent
      public let background: RevenueCat.PaywallComponent.Background?
      public let backgroundBlur: Swift.Bool
      public let size: RevenueCat.PaywallComponent.Size?
      public init(id: Swift.String, name: Swift.String?, stack: RevenueCat.PaywallComponent.StackComponent, background: RevenueCat.PaywallComponent.Background?, backgroundBlur: Swift.Bool, size: RevenueCat.PaywallComponent.Size?)
      public static func == (a: RevenueCat.PaywallComponent.ButtonComponent.Sheet, b: RevenueCat.PaywallComponent.ButtonComponent.Sheet) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    @objc deinit
    final public var hashValue: Swift.Int {
      get
    }
  }
}
@_hasMissingDesignatedInitializers @objc(RCConfiguration) final public class Configuration : ObjectiveC.NSObject {
  @objc public static func builder(withAPIKey apiKey: Swift.String) -> RevenueCat.Configuration.Builder
  @objc(RCConfigurationBuilder) public class Builder : ObjectiveC.NSObject {
    @objc public init(withAPIKey apiKey: Swift.String)
    @objc public func with(apiKey: Swift.String) -> RevenueCat.Configuration.Builder
    @_disfavoredOverload @objc public func with(appUserID: Swift.String?) -> RevenueCat.Configuration.Builder
    @available(*, deprecated, message: "The appUserID passed to logIn is a constant string known at compile time.\nThis is likely a programmer error. This ID is used to identify the current user.\nSee https://docs.revenuecat.com/docs/user-ids for more information.")
    public func with(appUserID: Swift.StaticString) -> RevenueCat.Configuration.Builder
    @objc public func with(purchasesAreCompletedBy: RevenueCat.PurchasesAreCompletedBy, storeKitVersion: RevenueCat.StoreKitVersion) -> RevenueCat.Configuration.Builder
    @objc public func with(userDefaults: Foundation.UserDefaults) -> RevenueCat.Configuration.Builder
    @objc public func with(dangerousSettings: RevenueCat.DangerousSettings) -> RevenueCat.Configuration.Builder
    @objc public func with(networkTimeout: Foundation.TimeInterval) -> RevenueCat.Configuration.Builder
    @objc public func with(storeKit1Timeout: Foundation.TimeInterval) -> RevenueCat.Configuration.Builder
    @objc public func with(platformInfo: RevenueCat.Purchases.PlatformInfo) -> RevenueCat.Configuration.Builder
    @objc public func with(showStoreMessagesAutomatically: Swift.Bool) -> RevenueCat.Configuration.Builder
    @objc public func with(entitlementVerificationMode mode: RevenueCat.Configuration.EntitlementVerificationMode) -> RevenueCat.Configuration.Builder
    @available(iOS 15.0, tvOS 15.0, macOS 12.0, watchOS 8.0, *)
    @objc public func with(diagnosticsEnabled: Swift.Bool) -> RevenueCat.Configuration.Builder
    @objc public func with(storeKitVersion version: RevenueCat.StoreKitVersion) -> RevenueCat.Configuration.Builder
    @objc public func build() -> RevenueCat.Configuration
    @objc deinit
  }
  @objc deinit
}
extension RevenueCat.Configuration {
  @objc(RCEntitlementVerificationMode) public enum EntitlementVerificationMode : Swift.Int {
    case disabled = 0
    case informational = 1
    @available(*, unavailable, message: "This will be supported in a future release")
    case enforced = 2
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
public enum PaywallViewMode {
  case fullScreen
  @available(watchOS, unavailable)
  case footer
  @available(watchOS, unavailable)
  case condensedFooter
  public static let `default`: RevenueCat.PaywallViewMode
  public static func == (a: RevenueCat.PaywallViewMode, b: RevenueCat.PaywallViewMode) -> Swift.Bool
}
extension RevenueCat.PaywallViewMode {
  public var isFullScreen: Swift.Bool {
    get
  }
}
extension RevenueCat.PaywallViewMode : Swift.CaseIterable {
  public static var allCases: [RevenueCat.PaywallViewMode] {
    get
  }
  public typealias AllCases = [RevenueCat.PaywallViewMode]
}
extension RevenueCat.PaywallViewMode : Swift.Sendable {
}
extension RevenueCat.PaywallViewMode : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallViewMode : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TestStoreProductDiscount {
  public var identifier: Swift.String
  public var price: Foundation.Decimal
  public var localizedPriceString: Swift.String
  public var paymentMode: RevenueCat.StoreProductDiscount.PaymentMode
  public var subscriptionPeriod: RevenueCat.SubscriptionPeriod
  public var numberOfPeriods: Swift.Int
  public var type: RevenueCat.StoreProductDiscount.DiscountType
  public init(identifier: Swift.String, price: Foundation.Decimal, localizedPriceString: Swift.String, paymentMode: RevenueCat.StoreProductDiscount.PaymentMode, subscriptionPeriod: RevenueCat.SubscriptionPeriod, numberOfPeriods: Swift.Int, type: RevenueCat.StoreProductDiscount.DiscountType)
}
extension RevenueCat.TestStoreProductDiscount {
  public func toStoreProductDiscount() -> RevenueCat.StoreProductDiscount
}
@objc(RCIntroEligibilityStatus) public enum IntroEligibilityStatus : Swift.Int {
  case unknown = 0
  case ineligible
  case eligible
  case noIntroOfferExists
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.IntroEligibilityStatus : Swift.CaseIterable, Swift.Sendable {
  public typealias AllCases = [RevenueCat.IntroEligibilityStatus]
  nonisolated public static var allCases: [RevenueCat.IntroEligibilityStatus] {
    get
  }
}
extension RevenueCat.IntroEligibilityStatus : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension RevenueCat.IntroEligibilityStatus {
  public var isEligible: Swift.Bool {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(RCIntroEligibility) final public class IntroEligibility : ObjectiveC.NSObject {
  @objc final public let status: RevenueCat.IntroEligibilityStatus
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.IntroEligibility {
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc override final public var debugDescription: Swift.String {
    @objc get
  }
}
extension RevenueCat.IntroEligibility : Swift.Sendable {
}
@objc(RCCacheFetchPolicy) public enum CacheFetchPolicy : Swift.Int {
  case fromCacheOnly
  case fetchCurrent
  case notStaleCachedOrFetched
  case cachedOrFetched
  public static let `default`: RevenueCat.CacheFetchPolicy
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.CacheFetchPolicy : Swift.Sendable {
}
@available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
public typealias SK1ProductDiscount = StoreKit.SKProductDiscount
@available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
public typealias SK2ProductDiscount = StoreKit.Product.SubscriptionOffer
@_hasMissingDesignatedInitializers @objc(RCStoreProductDiscount) final public class StoreProductDiscount : ObjectiveC.NSObject {
  @objc(RCPaymentMode) public enum PaymentMode : Swift.Int {
    case payAsYouGo = 0
    case payUpFront = 1
    case freeTrial = 2
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(RCDiscountType) public enum DiscountType : Swift.Int {
    case introductory = 0
    case promotional = 1
    case winBack = 2
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc final public var offerIdentifier: Swift.String? {
    @objc get
  }
  @objc final public var currencyCode: Swift.String? {
    @objc get
  }
  final public var price: Foundation.Decimal {
    get
  }
  @objc final public var localizedPriceString: Swift.String {
    @objc get
  }
  @objc final public var paymentMode: RevenueCat.StoreProductDiscount.PaymentMode {
    @objc get
  }
  @objc final public var subscriptionPeriod: RevenueCat.SubscriptionPeriod {
    @objc get
  }
  @objc final public var numberOfPeriods: Swift.Int {
    @objc get
  }
  @objc final public var type: RevenueCat.StoreProductDiscount.DiscountType {
    @objc get
  }
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.StoreProductDiscount : Swift.Sendable {
}
extension RevenueCat.StoreProductDiscount.PaymentMode : Swift.Sendable {
}
extension RevenueCat.StoreProductDiscount.DiscountType : Swift.Sendable {
}
extension RevenueCat.StoreProductDiscount {
  @objc(price) final public var priceDecimalNumber: Foundation.NSDecimalNumber {
    @objc get
  }
}
extension RevenueCat.StoreProductDiscount {
  public struct Data : Swift.Hashable {
    public static func == (a: RevenueCat.StoreProductDiscount.Data, b: RevenueCat.StoreProductDiscount.Data) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension RevenueCat.StoreProductDiscount {
  @objc final public var sk1Discount: RevenueCat.SK1ProductDiscount? {
    @objc get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  final public var sk2Discount: RevenueCat.SK2ProductDiscount? {
    get
  }
}
extension RevenueCat.StoreProductDiscount : Swift.Encodable {
  final public func encode(to encoder: any Swift.Encoder) throws
}
extension RevenueCat.StoreProductDiscount.PaymentMode : Swift.Encodable {
}
extension RevenueCat.StoreProductDiscount : Swift.Identifiable {
  final public var id: RevenueCat.StoreProductDiscount.Data {
    get
  }
  public typealias ID = RevenueCat.StoreProductDiscount.Data
}
extension RevenueCat.StoreProductDiscount {
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerDay: Foundation.NSDecimalNumber? {
    @objc get
  }
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerWeek: Foundation.NSDecimalNumber? {
    @objc get
  }
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerMonth: Foundation.NSDecimalNumber? {
    @objc get
  }
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerYear: Foundation.NSDecimalNumber? {
    @objc get
  }
}
extension RevenueCat.PaywallComponent {
  final public class TextComponent : RevenueCat.PaywallComponentBase {
    final public let visible: Swift.Bool?
    final public let text: RevenueCat.PaywallComponent.LocalizationKey
    final public let fontName: Swift.String?
    final public let fontWeight: RevenueCat.PaywallComponent.FontWeight
    final public let color: RevenueCat.PaywallComponent.ColorScheme
    final public let fontSize: CoreFoundation.CGFloat
    final public let horizontalAlignment: RevenueCat.PaywallComponent.HorizontalAlignment
    final public let backgroundColor: RevenueCat.PaywallComponent.ColorScheme?
    final public let size: RevenueCat.PaywallComponent.Size
    final public let padding: RevenueCat.PaywallComponent.Padding
    final public let margin: RevenueCat.PaywallComponent.Padding
    final public let fontWeightInt: Swift.Int?
    final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialTextComponent>?
    final public var fontWeightResolved: RevenueCat.PaywallComponent.FontWeight {
      get
    }
    public init(visible: Swift.Bool? = nil, text: Swift.String, fontName: Swift.String? = nil, fontWeight: RevenueCat.PaywallComponent.FontWeight = .regular, color: RevenueCat.PaywallComponent.ColorScheme, backgroundColor: RevenueCat.PaywallComponent.ColorScheme? = nil, size: RevenueCat.PaywallComponent.Size = .init(width: .fill, height: .fit), padding: RevenueCat.PaywallComponent.Padding = .zero, margin: RevenueCat.PaywallComponent.Padding = .zero, fontSize: CoreFoundation.CGFloat = 16, horizontalAlignment: RevenueCat.PaywallComponent.HorizontalAlignment = .center, overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialTextComponent>? = nil, fontWeightInt: Swift.Int? = nil)
    required public init(from decoder: any Swift.Decoder) throws
    final public func encode(to encoder: any Swift.Encoder) throws
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.TextComponent, rhs: RevenueCat.PaywallComponent.TextComponent) -> Swift.Bool
    @objc deinit
    final public var hashValue: Swift.Int {
      get
    }
  }
  final public class PartialTextComponent : RevenueCat.PaywallPartialComponent {
    final public let visible: Swift.Bool?
    final public let text: RevenueCat.PaywallComponent.LocalizationKey?
    final public let fontName: Swift.String?
    final public let fontWeight: RevenueCat.PaywallComponent.FontWeight?
    final public let color: RevenueCat.PaywallComponent.ColorScheme?
    final public let fontSize: CoreFoundation.CGFloat?
    final public let horizontalAlignment: RevenueCat.PaywallComponent.HorizontalAlignment?
    final public let backgroundColor: RevenueCat.PaywallComponent.ColorScheme?
    final public let size: RevenueCat.PaywallComponent.Size?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let fontWeightInt: Swift.Int?
    final public var fontWeightResolved: RevenueCat.PaywallComponent.FontWeight? {
      get
    }
    public init(visible: Swift.Bool? = true, text: RevenueCat.PaywallComponent.LocalizationKey? = nil, fontName: Swift.String? = nil, fontWeight: RevenueCat.PaywallComponent.FontWeight? = nil, color: RevenueCat.PaywallComponent.ColorScheme? = nil, backgroundColor: RevenueCat.PaywallComponent.ColorScheme? = nil, size: RevenueCat.PaywallComponent.Size? = nil, padding: RevenueCat.PaywallComponent.Padding? = nil, margin: RevenueCat.PaywallComponent.Padding? = nil, fontSize: CoreFoundation.CGFloat? = nil, horizontalAlignment: RevenueCat.PaywallComponent.HorizontalAlignment? = nil, fontWeightInt: Swift.Int? = nil)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PartialTextComponent, rhs: RevenueCat.PaywallComponent.PartialTextComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension RevenueCat.PurchasesDiagnostics.SDKHealthError : Foundation.CustomNSError {
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public struct PaywallColor {
  @frozen public enum ColorScheme : Swift.String {
    case light
    case dark
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var stringRepresentation: Swift.String
  public var underlyingColor: SwiftUICore.Color {
    get
  }
}
extension RevenueCat.PaywallColor {
  public init(stringRepresentation: Swift.String) throws
  @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
  public init(light: RevenueCat.PaywallColor, dark: RevenueCat.PaywallColor)
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SwiftUICore.Color {
  public var asPaywallColor: RevenueCat.PaywallColor {
    get
  }
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension UIKit.UIColor {
  public var asPaywallColor: RevenueCat.PaywallColor {
    get
  }
}
extension RevenueCat.PaywallColor.ColorScheme : Swift.Equatable {
}
extension RevenueCat.PaywallColor.ColorScheme : Swift.Sendable {
}
extension RevenueCat.PaywallColor.ColorScheme : Swift.Codable {
}
extension RevenueCat.PaywallColor : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RevenueCat.PaywallColor : Swift.Equatable {
  public static func == (lhs: RevenueCat.PaywallColor, rhs: RevenueCat.PaywallColor) -> Swift.Bool
}
extension RevenueCat.PaywallColor : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallColor : Swift.Sendable {
}
extension RevenueCat.PaywallColor : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@objc(RCPurchasesDelegate) public protocol PurchasesDelegate : ObjectiveC.NSObjectProtocol {
  @available(swift, obsoleted: 1, renamed: "purchases(_:receivedUpdated:)")
  @available(iOS, obsoleted: 1)
  @available(macOS, obsoleted: 1)
  @available(tvOS, obsoleted: 1)
  @available(watchOS, obsoleted: 1)
  @objc(purchases:didReceiveUpdatedPurchaserInfo:) optional func purchases(_ purchases: RevenueCat.Purchases, didReceiveUpdated purchaserInfo: RevenueCat.CustomerInfo)
  @objc(purchases:receivedUpdatedCustomerInfo:) optional func purchases(_ purchases: RevenueCat.Purchases, receivedUpdated customerInfo: RevenueCat.CustomerInfo)
  @objc optional func purchases(_ purchases: RevenueCat.Purchases, readyForPromotedProduct product: RevenueCat.StoreProduct, purchase startPurchase: @escaping RevenueCat.StartPurchaseBlock)
  @available(iOS, obsoleted: 1, renamed: "purchases(_:readyForPromotedProduct:purchase:)")
  @available(tvOS, obsoleted: 1, renamed: "purchases(_:readyForPromotedProduct:purchase:)")
  @available(watchOS, obsoleted: 1, renamed: "purchases(_:readyForPromotedProduct:purchase:)")
  @available(macOS, obsoleted: 1, renamed: "purchases(_:readyForPromotedProduct:purchase:)")
  @available(macCatalyst, obsoleted: 1, renamed: "purchases(_:readyForPromotedProduct:purchase:)")
  @objc optional func purchases(_ purchases: RevenueCat.Purchases, shouldPurchasePromoProduct product: RevenueCat.StoreProduct, defermentBlock makeDeferredPurchase: @escaping RevenueCat.StartPurchaseBlock)
  @available(iOS 13.4, macCatalyst 13.4, *)
  @available(macOS, unavailable)
  @available(tvOS, unavailable)
  @available(watchOS, unavailable)
  @objc optional var shouldShowPriceConsent: Swift.Bool { get }
}
public protocol PaywallPartialComponent : RevenueCat.PaywallComponentBase {
}
extension RevenueCat.PaywallComponent {
  public typealias ComponentOverrides<T> = [RevenueCat.PaywallComponent.ComponentOverride<T>] where T : RevenueCat.PaywallPartialComponent
  public struct ComponentOverride<T> : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable where T : RevenueCat.PaywallPartialComponent {
    public let conditions: [RevenueCat.PaywallComponent.Condition]
    public let properties: T
    public init(conditions: [RevenueCat.PaywallComponent.Condition], properties: T)
    public static func == (a: RevenueCat.PaywallComponent.ComponentOverride<T>, b: RevenueCat.PaywallComponent.ComponentOverride<T>) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum Condition : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case compact
    case medium
    case expanded
    case introOffer
    case promoOffer
    case selected
    case unsupported
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension RevenueCat.PaywallComponent {
  final public class StickyFooterComponent : RevenueCat.PaywallComponentBase {
    final public let stack: RevenueCat.PaywallComponent.StackComponent
    public init(stack: RevenueCat.PaywallComponent.StackComponent)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.StickyFooterComponent, rhs: RevenueCat.PaywallComponent.StickyFooterComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension RevenueCat.PaywallComponent {
  public struct ThemeImageUrls : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public init(light: RevenueCat.PaywallComponent.ImageUrls, dark: RevenueCat.PaywallComponent.ImageUrls? = nil)
    public let light: RevenueCat.PaywallComponent.ImageUrls
    public let dark: RevenueCat.PaywallComponent.ImageUrls?
    public static func == (a: RevenueCat.PaywallComponent.ThemeImageUrls, b: RevenueCat.PaywallComponent.ThemeImageUrls) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ImageUrls : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public init(width: Swift.Int, height: Swift.Int, original: Foundation.URL, heic: Foundation.URL, heicLowRes: Foundation.URL)
    public let width: Swift.Int
    public let height: Swift.Int
    public let original: Foundation.URL
    public let heic: Foundation.URL
    public let heicLowRes: Foundation.URL
    public static func == (a: RevenueCat.PaywallComponent.ImageUrls, b: RevenueCat.PaywallComponent.ImageUrls) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct GradientPoint : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public let color: RevenueCat.PaywallComponent.ColorHex
    public let percent: Swift.Int
    public init(color: RevenueCat.PaywallComponent.ColorHex, percent: Swift.Int)
    public static func == (a: RevenueCat.PaywallComponent.GradientPoint, b: RevenueCat.PaywallComponent.GradientPoint) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ColorScheme : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public init(light: RevenueCat.PaywallComponent.ColorInfo, dark: RevenueCat.PaywallComponent.ColorInfo? = nil)
    public let light: RevenueCat.PaywallComponent.ColorInfo
    public let dark: RevenueCat.PaywallComponent.ColorInfo?
    public static func == (a: RevenueCat.PaywallComponent.ColorScheme, b: RevenueCat.PaywallComponent.ColorScheme) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum ColorInfo : Swift.Codable, Swift.Sendable, Swift.Hashable {
    case hex(RevenueCat.PaywallComponent.ColorHex)
    case alias(Swift.String)
    case linear(Swift.Int, [RevenueCat.PaywallComponent.GradientPoint])
    case radial([RevenueCat.PaywallComponent.GradientPoint])
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public static func == (a: RevenueCat.PaywallComponent.ColorInfo, b: RevenueCat.PaywallComponent.ColorInfo) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Shape : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case rectangle(RevenueCat.PaywallComponent.CornerRadiuses?)
    case pill
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public static func == (a: RevenueCat.PaywallComponent.Shape, b: RevenueCat.PaywallComponent.Shape) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum IconBackgroundShape : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case rectangle(RevenueCat.PaywallComponent.CornerRadiuses?)
    case circle
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public static func == (a: RevenueCat.PaywallComponent.IconBackgroundShape, b: RevenueCat.PaywallComponent.IconBackgroundShape) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum MaskShape : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case rectangle(RevenueCat.PaywallComponent.CornerRadiuses?)
    case circle
    case concave
    case convex
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public static func == (a: RevenueCat.PaywallComponent.MaskShape, b: RevenueCat.PaywallComponent.MaskShape) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Padding : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public init(top: Swift.Double?, bottom: Swift.Double?, leading: Swift.Double?, trailing: Swift.Double?)
    public let top: Swift.Double?
    public let bottom: Swift.Double?
    public let leading: Swift.Double?
    public let trailing: Swift.Double?
    public static let `default`: RevenueCat.PaywallComponent.Padding
    public static let zero: RevenueCat.PaywallComponent.Padding
    public static func == (a: RevenueCat.PaywallComponent.Padding, b: RevenueCat.PaywallComponent.Padding) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct CornerRadiuses : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public init(topLeading: Swift.Double?, topTrailing: Swift.Double?, bottomLeading: Swift.Double?, bottomTrailing: Swift.Double?)
    public let topLeading: Swift.Double?
    public let topTrailing: Swift.Double?
    public let bottomLeading: Swift.Double?
    public let bottomTrailing: Swift.Double?
    public static let `default`: RevenueCat.PaywallComponent.CornerRadiuses
    public static let zero: RevenueCat.PaywallComponent.CornerRadiuses
    public static func == (a: RevenueCat.PaywallComponent.CornerRadiuses, b: RevenueCat.PaywallComponent.CornerRadiuses) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Size : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public let width: RevenueCat.PaywallComponent.SizeConstraint
    public let height: RevenueCat.PaywallComponent.SizeConstraint
    public init(width: RevenueCat.PaywallComponent.SizeConstraint, height: RevenueCat.PaywallComponent.SizeConstraint)
    public static func == (a: RevenueCat.PaywallComponent.Size, b: RevenueCat.PaywallComponent.Size) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum SizeConstraint : Swift.Codable, Swift.Sendable, Swift.Hashable {
    case fit
    case fill
    case fixed(Swift.UInt)
    case relative(Swift.Double)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public static func == (a: RevenueCat.PaywallComponent.SizeConstraint, b: RevenueCat.PaywallComponent.SizeConstraint) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum FlexDistribution : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case start
    case center
    case end
    case spaceBetween
    case spaceAround
    case spaceEvenly
    public init(from decoder: any Swift.Decoder) throws
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum HorizontalAlignment : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case leading
    case center
    case trailing
    public init(from decoder: any Swift.Decoder) throws
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum VerticalAlignment : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case top
    case center
    case bottom
    public init(from decoder: any Swift.Decoder) throws
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum TwoDimensionAlignment : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case center
    case leading
    case trailing
    case top
    case bottom
    case topLeading
    case topTrailing
    case bottomLeading
    case bottomTrailing
    public init(from decoder: any Swift.Decoder) throws
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum FontWeight : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case extraLight
    case thin
    case light
    case regular
    case medium
    case semibold
    case bold
    case extraBold
    case black
    public init(from decoder: any Swift.Decoder) throws
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum FontSize : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case headingXXL
    case headingXL
    case headingL
    case headingM
    case headingS
    case headingXS
    case bodyXL
    case bodyL
    case bodyM
    case bodyS
    public init(from decoder: any Swift.Decoder) throws
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum FitMode : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case fit
    case fill
    public init(from decoder: any Swift.Decoder) throws
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct Shadow : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public let color: RevenueCat.PaywallComponent.ColorScheme
    public let radius: CoreFoundation.CGFloat
    public let x: CoreFoundation.CGFloat
    public let y: CoreFoundation.CGFloat
    public init(color: RevenueCat.PaywallComponent.ColorScheme, radius: CoreFoundation.CGFloat, x: CoreFoundation.CGFloat, y: CoreFoundation.CGFloat)
    public static func == (a: RevenueCat.PaywallComponent.Shadow, b: RevenueCat.PaywallComponent.Shadow) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum BadgeStyle : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    case edgeToEdge
    case overlaid
    case nested
    public init(from decoder: any Swift.Decoder) throws
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  final public class Badge : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    final public let style: RevenueCat.PaywallComponent.BadgeStyle
    final public let alignment: RevenueCat.PaywallComponent.TwoDimensionAlignment
    final public let stack: RevenueCat.PaywallComponent.StackComponent
    public init(style: RevenueCat.PaywallComponent.BadgeStyle, alignment: RevenueCat.PaywallComponent.TwoDimensionAlignment, stack: RevenueCat.PaywallComponent.StackComponent)
    public static func == (lhs: RevenueCat.PaywallComponent.Badge, rhs: RevenueCat.PaywallComponent.Badge) -> Swift.Bool
    final public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension Swift.Dictionary where Key == Swift.String, Value == RevenueCat.PaywallComponentsData.LocalizationData {
  public func string(key: Swift.String) throws -> Swift.String
  public func image(key: Swift.String) throws -> RevenueCat.PaywallComponent.ThemeImageUrls
}
extension RevenueCat.PaywallComponent {
  public struct Border : Swift.Codable, Swift.Sendable, Swift.Hashable {
    public let color: RevenueCat.PaywallComponent.ColorScheme
    public let width: Swift.Double
    public init(color: RevenueCat.PaywallComponent.ColorScheme, width: Swift.Double)
    public static func == (a: RevenueCat.PaywallComponent.Border, b: RevenueCat.PaywallComponent.Border) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension RevenueCat.PaywallComponent {
  public enum Dimension : Swift.Codable, Swift.Sendable, Swift.Hashable {
    case vertical(RevenueCat.PaywallComponent.HorizontalAlignment, RevenueCat.PaywallComponent.FlexDistribution)
    case horizontal(RevenueCat.PaywallComponent.VerticalAlignment, RevenueCat.PaywallComponent.FlexDistribution)
    case zlayer(RevenueCat.PaywallComponent.TwoDimensionAlignment)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public static func horizontal() -> RevenueCat.PaywallComponent.Dimension
    public static func vertical() -> RevenueCat.PaywallComponent.Dimension
    public static func == (a: RevenueCat.PaywallComponent.Dimension, b: RevenueCat.PaywallComponent.Dimension) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol PaywallComponentBase : Swift.Decodable, Swift.Encodable, Swift.Hashable, Swift.Sendable {
}
public enum PaywallComponent : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
  case text(RevenueCat.PaywallComponent.TextComponent)
  case image(RevenueCat.PaywallComponent.ImageComponent)
  case icon(RevenueCat.PaywallComponent.IconComponent)
  case stack(RevenueCat.PaywallComponent.StackComponent)
  case button(RevenueCat.PaywallComponent.ButtonComponent)
  case package(RevenueCat.PaywallComponent.PackageComponent)
  case purchaseButton(RevenueCat.PaywallComponent.PurchaseButtonComponent)
  case stickyFooter(RevenueCat.PaywallComponent.StickyFooterComponent)
  case timeline(RevenueCat.PaywallComponent.TimelineComponent)
  case tabs(RevenueCat.PaywallComponent.TabsComponent)
  case tabControl(RevenueCat.PaywallComponent.TabControlComponent)
  case tabControlButton(RevenueCat.PaywallComponent.TabControlButtonComponent)
  case tabControlToggle(RevenueCat.PaywallComponent.TabControlToggleComponent)
  case carousel(RevenueCat.PaywallComponent.CarouselComponent)
  public enum ComponentType : Swift.String, Swift.Codable, Swift.Sendable {
    case text
    case image
    case icon
    case stack
    case button
    case package
    case purchaseButton
    case stickyFooter
    case timeline
    case tabs
    case tabControl
    case tabControlButton
    case tabControlToggle
    case carousel
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public static func == (a: RevenueCat.PaywallComponent, b: RevenueCat.PaywallComponent) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RevenueCat.PaywallComponent {
  public typealias LocaleID = Swift.String
  public typealias LocalizationDictionary = [Swift.String : RevenueCat.PaywallComponentsData.LocalizationData]
  public typealias LocalizationKey = Swift.String
  public typealias ColorHex = Swift.String
}
extension RevenueCat.PaywallComponent {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, macOS 13.0, *)
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func debugRevenueCatOverlay() -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func debugRevenueCatOverlay(isPresented: SwiftUICore.Binding<Swift.Bool>) -> some SwiftUICore.View
  
}
@objc(RCAttributionNetwork) public enum AttributionNetwork : Swift.Int {
  @available(*, deprecated, message: "use adServices")
  case appleSearchAds = 0
  case adjust = 1
  case appsFlyer = 2
  case branch = 3
  case tenjin = 4
  case facebook = 5
  case mParticle = 6
  case adServices = 7
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.AttributionNetwork : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct PaywallComponentsData : Swift.Codable, Swift.Equatable, Swift.Sendable {
  public struct ComponentsConfig : Swift.Codable, Swift.Equatable, Swift.Sendable {
    public var base: RevenueCat.PaywallComponentsData.PaywallComponentsConfig
    public init(base: RevenueCat.PaywallComponentsData.PaywallComponentsConfig)
    public static func == (a: RevenueCat.PaywallComponentsData.ComponentsConfig, b: RevenueCat.PaywallComponentsData.ComponentsConfig) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct PaywallComponentsConfig : Swift.Codable, Swift.Equatable, Swift.Sendable {
    public var stack: RevenueCat.PaywallComponent.StackComponent
    public let stickyFooter: RevenueCat.PaywallComponent.StickyFooterComponent?
    public var background: RevenueCat.PaywallComponent.Background
    public init(stack: RevenueCat.PaywallComponent.StackComponent, stickyFooter: RevenueCat.PaywallComponent.StickyFooterComponent?, background: RevenueCat.PaywallComponent.Background)
    public static func == (a: RevenueCat.PaywallComponentsData.PaywallComponentsConfig, b: RevenueCat.PaywallComponentsData.PaywallComponentsConfig) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum LocalizationData : Swift.Codable, Swift.Equatable, Swift.Sendable {
    case string(Swift.String), image(RevenueCat.PaywallComponent.ThemeImageUrls)
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public static func == (a: RevenueCat.PaywallComponentsData.LocalizationData, b: RevenueCat.PaywallComponentsData.LocalizationData) -> Swift.Bool
  }
  public var templateName: Swift.String
  public var assetBaseURL: Foundation.URL
  public var revision: Swift.Int {
    get
    set
  }
  public var componentsConfig: RevenueCat.PaywallComponentsData.ComponentsConfig
  public var componentsLocalizations: [RevenueCat.PaywallComponent.LocaleID : RevenueCat.PaywallComponent.LocalizationDictionary]
  public var defaultLocale: Swift.String
  public var errorInfo: [Swift.String : RevenueCat.PaywallComponentsData.EquatableError]?
  public init(templateName: Swift.String, assetBaseURL: Foundation.URL, componentsConfig: RevenueCat.PaywallComponentsData.ComponentsConfig, componentsLocalizations: [RevenueCat.PaywallComponent.LocaleID : RevenueCat.PaywallComponent.LocalizationDictionary], revision: Swift.Int, defaultLocaleIdentifier: Swift.String)
  public static func == (a: RevenueCat.PaywallComponentsData, b: RevenueCat.PaywallComponentsData) -> Swift.Bool
}
extension RevenueCat.PaywallComponentsData {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension RevenueCat.PaywallComponentsData {
  public struct EquatableError : Swift.Equatable, Swift.Sendable {
    public static func == (lhs: RevenueCat.PaywallComponentsData.EquatableError, rhs: RevenueCat.PaywallComponentsData.EquatableError) -> Swift.Bool
  }
}
public typealias PublicError = Foundation.NSError
extension Foundation.NSError {
  public var asErrorCode: RevenueCat.ErrorCode? {
    get
  }
}
@objc(RCPurchasesType) public protocol PurchasesType {
  @objc var appUserID: Swift.String { get }
  @objc var storeFrontCountryCode: Swift.String? { get }
  @objc var isAnonymous: Swift.Bool { get }
  @objc var purchasesAreCompletedBy: RevenueCat.PurchasesAreCompletedBy { get set }
  @objc var delegate: (any RevenueCat.PurchasesDelegate)? { get set }
  @objc func getStorefront(completion: @escaping RevenueCat.GetStorefrontBlock)
  @objc func getStorefront() async -> RevenueCat.Storefront?
  @objc func logIn(_ appUserID: Swift.String, completion: @escaping (RevenueCat.CustomerInfo?, Swift.Bool, RevenueCat.PublicError?) -> Swift.Void)
  @objc func logIn(_ appUserID: Swift.String) async throws -> (customerInfo: RevenueCat.CustomerInfo, created: Swift.Bool)
  @objc func logOut(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)?)
  @objc func logOut() async throws -> RevenueCat.CustomerInfo
  @objc func getCustomerInfo(completion: @escaping (RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)
  @objc func getCustomerInfo(fetchPolicy: RevenueCat.CacheFetchPolicy, completion: @escaping (RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)
  @objc func customerInfo() async throws -> RevenueCat.CustomerInfo
  @objc func customerInfo(fetchPolicy: RevenueCat.CacheFetchPolicy) async throws -> RevenueCat.CustomerInfo
  @objc var cachedCustomerInfo: RevenueCat.CustomerInfo? { get }
  @objc func getOfferings(completion: @escaping (RevenueCat.Offerings?, RevenueCat.PublicError?) -> Swift.Void)
  @objc func offerings() async throws -> RevenueCat.Offerings
  @objc var cachedOfferings: RevenueCat.Offerings? { get }
  @objc(getProductsWithIdentifiers:completion:) func getProducts(_ productIdentifiers: [Swift.String], completion: @escaping ([RevenueCat.StoreProduct]) -> Swift.Void)
  @objc func products(_ productIdentifiers: [Swift.String]) async -> [RevenueCat.StoreProduct]
  @objc(purchaseProduct:withCompletion:) func purchase(product: RevenueCat.StoreProduct, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc func purchase(product: RevenueCat.StoreProduct) async throws -> RevenueCat.PurchaseResultData
  @objc(purchasePackage:withCompletion:) func purchase(package: RevenueCat.Package, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc func purchase(package: RevenueCat.Package) async throws -> RevenueCat.PurchaseResultData
  @objc(purchaseWithParams:completion:) func purchase(_ params: RevenueCat.PurchaseParams, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc func purchase(_ params: RevenueCat.PurchaseParams) async throws -> RevenueCat.PurchaseResultData
  @objc func invalidateCustomerInfoCache()
  @objc func restorePurchases(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)?)
  @objc func restorePurchases() async throws -> RevenueCat.CustomerInfo
  @objc func syncPurchases(completion: ((RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)?)
  @objc func syncPurchases() async throws -> RevenueCat.CustomerInfo
  @objc(purchaseProduct:withPromotionalOffer:completion:) func purchase(product: RevenueCat.StoreProduct, promotionalOffer: RevenueCat.PromotionalOffer, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc func purchase(product: RevenueCat.StoreProduct, promotionalOffer: RevenueCat.PromotionalOffer) async throws -> RevenueCat.PurchaseResultData
  @objc(purchasePackage:withPromotionalOffer:completion:) func purchase(package: RevenueCat.Package, promotionalOffer: RevenueCat.PromotionalOffer, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc func purchase(package: RevenueCat.Package, promotionalOffer: RevenueCat.PromotionalOffer) async throws -> RevenueCat.PurchaseResultData
  @objc(checkTrialOrIntroDiscountEligibility:completion:) func checkTrialOrIntroDiscountEligibility(productIdentifiers: [Swift.String], completion receiveEligibility: @escaping ([Swift.String : RevenueCat.IntroEligibility]) -> Swift.Void)
  @objc func checkTrialOrIntroDiscountEligibility(productIdentifiers: [Swift.String]) async -> [Swift.String : RevenueCat.IntroEligibility]
  @objc(checkTrialOrIntroDiscountEligibilityForProduct:completion:) func checkTrialOrIntroDiscountEligibility(product: RevenueCat.StoreProduct, completion: @escaping (RevenueCat.IntroEligibilityStatus) -> Swift.Void)
  @objc func checkTrialOrIntroDiscountEligibility(product: RevenueCat.StoreProduct) async -> RevenueCat.IntroEligibilityStatus
  @objc(getPromotionalOfferForProductDiscount:withProduct:withCompletion:) func getPromotionalOffer(forProductDiscount discount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct, completion: @escaping (RevenueCat.PromotionalOffer?, RevenueCat.PublicError?) -> Swift.Void)
  @objc func promotionalOffer(forProductDiscount discount: RevenueCat.StoreProductDiscount, product: RevenueCat.StoreProduct) async throws -> RevenueCat.PromotionalOffer
  @objc func eligiblePromotionalOffers(forProduct product: RevenueCat.StoreProduct) async -> [RevenueCat.PromotionalOffer]
  @objc @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  func eligibleWinBackOffers(forProduct product: RevenueCat.StoreProduct, completion: @escaping @Sendable ([RevenueCat.WinBackOffer]?, RevenueCat.PublicError?) -> Swift.Void)
  @objc @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  func eligibleWinBackOffers(forPackage package: RevenueCat.Package, completion: @escaping @Sendable ([RevenueCat.WinBackOffer]?, RevenueCat.PublicError?) -> Swift.Void)
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForProduct:completion:) func beginRefundRequest(forProduct productID: Swift.String) async throws -> RevenueCat.RefundRequestStatus
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForEntitlement:completion:) func beginRefundRequest(forEntitlement entitlementID: Swift.String) async throws -> RevenueCat.RefundRequestStatus
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc(beginRefundRequestForActiveEntitlementWithCompletion:) func beginRefundRequestForActiveEntitlement() async throws -> RevenueCat.RefundRequestStatus
  @objc @available(iOS 14.0, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @available(macOS, unavailable)
  @available(macCatalyst, unavailable)
  func presentCodeRedemptionSheet()
  @available(iOS 13.4, macCatalyst 13.4, *)
  @objc func showPriceConsentIfNeeded()
  @available(iOS 13.0, macOS 10.15, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  @objc func showManageSubscriptions(completion: @escaping (RevenueCat.PublicError?) -> Swift.Void)
  @objc @available(iOS 13.0, macOS 10.15, *)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  func showManageSubscriptions() async throws
  @objc var attribution: RevenueCat.Attribution { get }
  @objc func syncAttributesAndOfferingsIfNeeded(completion: @escaping (RevenueCat.Offerings?, RevenueCat.PublicError?) -> Swift.Void)
  @objc @available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.2, *)
  func syncAttributesAndOfferingsIfNeeded() async throws -> RevenueCat.Offerings?
  @objc func redeemWebPurchase(webPurchaseRedemption: RevenueCat.WebPurchaseRedemption, completion: @escaping (RevenueCat.CustomerInfo?, RevenueCat.PublicError?) -> Swift.Void)
  @objc func getVirtualCurrencies(completion: @escaping @Sendable (RevenueCat.VirtualCurrencies?, RevenueCat.PublicError?) -> Swift.Void)
  @objc var cachedVirtualCurrencies: RevenueCat.VirtualCurrencies? { get }
  @objc func invalidateVirtualCurrenciesCache()
  @objc func setAttributes(_ attributes: [Swift.String : Swift.String])
  @objc @available(*, deprecated)
  var allowSharingAppStoreAccount: Swift.Bool { get set }
  @objc @available(*, deprecated)
  func setEmail(_ email: Swift.String?)
  @objc @available(*, deprecated)
  func setPhoneNumber(_ phoneNumber: Swift.String?)
  @objc @available(*, deprecated)
  func setDisplayName(_ displayName: Swift.String?)
  @objc @available(*, deprecated)
  func setPushToken(_ pushToken: Foundation.Data?)
  @objc @available(*, deprecated)
  func setPushTokenString(_ pushToken: Swift.String?)
  @objc @available(*, deprecated)
  func setAdjustID(_ adjustID: Swift.String?)
  @objc @available(*, deprecated)
  func setAppsflyerID(_ appsflyerID: Swift.String?)
  @objc @available(*, deprecated)
  func setFBAnonymousID(_ fbAnonymousID: Swift.String?)
  @objc @available(*, deprecated)
  func setMparticleID(_ mparticleID: Swift.String?)
  @objc @available(*, deprecated)
  func setOnesignalID(_ onesignalID: Swift.String?)
  @objc @available(*, deprecated)
  func setMediaSource(_ mediaSource: Swift.String?)
  @objc @available(*, deprecated)
  func setCampaign(_ campaign: Swift.String?)
  @objc @available(*, deprecated)
  func setAdGroup(_ adGroup: Swift.String?)
  @objc @available(*, deprecated)
  func setAd(_ value: Swift.String?)
  @objc @available(*, deprecated)
  func setKeyword(_ keyword: Swift.String?)
  @objc @available(*, deprecated)
  func setCreative(_ creative: Swift.String?)
  @objc @available(*, deprecated)
  func setCleverTapID(_ cleverTapID: Swift.String?)
  @objc @available(*, deprecated)
  func setMixpanelDistinctID(_ mixpanelDistinctID: Swift.String?)
  @objc @available(*, deprecated)
  func setFirebaseAppInstanceID(_ firebaseAppInstanceID: Swift.String?)
  @objc @available(*, deprecated)
  func collectDeviceIdentifiers()
  @available(*, deprecated)
  @objc(params:withCompletion:) func purchaseWithParams(_ params: RevenueCat.PurchaseParams, completion: @escaping RevenueCat.PurchaseCompletedBlock)
  @objc @available(*, deprecated, message: "Use purchasesAreCompletedBy instead.")
  var finishTransactions: Swift.Bool { get set }
}
public protocol PurchasesSwiftType : AnyObject {
  var customerInfoStream: _Concurrency.AsyncStream<RevenueCat.CustomerInfo> { get }
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  func beginRefundRequest(forProduct productID: Swift.String, completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  func beginRefundRequest(forEntitlement entitlementID: Swift.String, completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  @available(iOS 15.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  func beginRefundRequestForActiveEntitlement(completion: @escaping (Swift.Result<RevenueCat.RefundRequestStatus, RevenueCat.PublicError>) -> Swift.Void)
  @available(iOS 16.0, *)
  @available(macOS, unavailable)
  @available(watchOS, unavailable)
  @available(tvOS, unavailable)
  func showStoreMessages(for types: Swift.Set<RevenueCat.StoreMessageType>) async
  @available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
  func recordPurchase(_ purchaseResult: StoreKit.Product.PurchaseResult) async throws -> RevenueCat.StoreTransaction?
  func redeemWebPurchase(_ webPurchaseRedemption: RevenueCat.WebPurchaseRedemption) async -> RevenueCat.WebPurchaseRedemptionResult
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  func eligibleWinBackOffers(forProduct product: RevenueCat.StoreProduct) async throws -> [RevenueCat.WinBackOffer]
  @available(iOS 18.0, macOS 15.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
  func eligibleWinBackOffers(forPackage package: RevenueCat.Package) async throws -> [RevenueCat.WinBackOffer]
  func virtualCurrencies() async throws -> RevenueCat.VirtualCurrencies
}
@objc(RCStoreKitVersion) public enum StoreKitVersion : Swift.Int {
  @objc(RCStoreKitVersion1) case storeKit1 = 1
  @objc(RCStoreKitVersion2) case storeKit2 = 2
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension RevenueCat.StoreKitVersion {
  public static let `default`: RevenueCat.StoreKitVersion
}
extension RevenueCat.StoreKitVersion : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RevenueCat.PaywallComponent {
  final public class IconComponent : RevenueCat.PaywallComponentBase {
    final public class Formats : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      final public let svg: Swift.String
      final public let png: Swift.String
      final public let heic: Swift.String
      final public let webp: Swift.String
      public init(svg: Swift.String, png: Swift.String, heic: Swift.String, webp: Swift.String)
      final public func hash(into hasher: inout Swift.Hasher)
      public static func == (lhs: RevenueCat.PaywallComponent.IconComponent.Formats, rhs: RevenueCat.PaywallComponent.IconComponent.Formats) -> Swift.Bool
      @objc deinit
      final public func encode(to encoder: any Swift.Encoder) throws
      final public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    final public class IconBackground : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      final public let color: RevenueCat.PaywallComponent.ColorScheme
      final public let shape: RevenueCat.PaywallComponent.IconBackgroundShape
      final public let border: RevenueCat.PaywallComponent.Border?
      final public let shadow: RevenueCat.PaywallComponent.Shadow?
      public init(color: RevenueCat.PaywallComponent.ColorScheme, shape: RevenueCat.PaywallComponent.IconBackgroundShape, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil)
      final public func hash(into hasher: inout Swift.Hasher)
      public static func == (lhs: RevenueCat.PaywallComponent.IconComponent.IconBackground, rhs: RevenueCat.PaywallComponent.IconComponent.IconBackground) -> Swift.Bool
      @objc deinit
      final public func encode(to encoder: any Swift.Encoder) throws
      final public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    final public let visible: Swift.Bool?
    final public let baseUrl: Swift.String
    final public let iconName: Swift.String
    final public let formats: RevenueCat.PaywallComponent.IconComponent.Formats
    final public let size: RevenueCat.PaywallComponent.Size
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let color: RevenueCat.PaywallComponent.ColorScheme
    final public let iconBackground: RevenueCat.PaywallComponent.IconComponent.IconBackground?
    final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialIconComponent>?
    public init(visible: Swift.Bool? = nil, baseUrl: Swift.String, iconName: Swift.String, formats: RevenueCat.PaywallComponent.IconComponent.Formats, size: RevenueCat.PaywallComponent.Size, padding: RevenueCat.PaywallComponent.Padding?, margin: RevenueCat.PaywallComponent.Padding?, color: RevenueCat.PaywallComponent.ColorScheme, iconBackground: RevenueCat.PaywallComponent.IconComponent.IconBackground?, overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialIconComponent>? = nil)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.IconComponent, rhs: RevenueCat.PaywallComponent.IconComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class PartialIconComponent : RevenueCat.PaywallPartialComponent {
    final public let visible: Swift.Bool?
    final public let baseUrl: Swift.String?
    final public let iconName: Swift.String?
    final public let formats: RevenueCat.PaywallComponent.IconComponent.Formats?
    final public let size: RevenueCat.PaywallComponent.Size?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let color: RevenueCat.PaywallComponent.ColorScheme?
    final public let iconBackground: RevenueCat.PaywallComponent.IconComponent.IconBackground?
    public init(visible: Swift.Bool? = true, baseUrl: Swift.String? = nil, iconName: Swift.String? = nil, formats: RevenueCat.PaywallComponent.IconComponent.Formats? = nil, size: RevenueCat.PaywallComponent.Size? = nil, padding: RevenueCat.PaywallComponent.Padding? = nil, margin: RevenueCat.PaywallComponent.Padding? = nil, color: RevenueCat.PaywallComponent.ColorScheme? = nil, iconBackground: RevenueCat.PaywallComponent.IconComponent.IconBackground? = nil)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PartialIconComponent, rhs: RevenueCat.PaywallComponent.PartialIconComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
public typealias SK1Product = StoreKit.SKProduct
@available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
public typealias SK2Product = StoreKit.Product
@_hasMissingDesignatedInitializers @objc(RCStoreProduct) final public class StoreProduct : ObjectiveC.NSObject {
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc final public var productType: RevenueCat.StoreProduct.ProductType {
    @objc get
  }
  @objc final public var productCategory: RevenueCat.StoreProduct.ProductCategory {
    @objc get
  }
  @objc final public var localizedDescription: Swift.String {
    @objc get
  }
  @objc final public var localizedTitle: Swift.String {
    @objc get
  }
  @objc final public var currencyCode: Swift.String? {
    @objc get
  }
  final public var price: Foundation.Decimal {
    get
  }
  @objc final public var localizedPriceString: Swift.String {
    @objc get
  }
  @objc final public var productIdentifier: Swift.String {
    @objc get
  }
  @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
  @objc final public var isFamilyShareable: Swift.Bool {
    @objc get
  }
  @objc final public var subscriptionGroupIdentifier: Swift.String? {
    @objc get
  }
  @objc final public var priceFormatter: Foundation.NumberFormatter? {
    @objc get
  }
  @objc final public var subscriptionPeriod: RevenueCat.SubscriptionPeriod? {
    @objc get
  }
  @objc final public var introductoryDiscount: RevenueCat.StoreProductDiscount? {
    @objc get
  }
  @objc final public var discounts: [RevenueCat.StoreProductDiscount] {
    @objc get
  }
  @objc deinit
}
extension RevenueCat.StoreProduct {
  @objc(price) final public var priceDecimalNumber: Foundation.NSDecimalNumber {
    @objc get
  }
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerDay: Foundation.NSDecimalNumber? {
    @objc get
  }
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerWeek: Foundation.NSDecimalNumber? {
    @objc get
  }
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerMonth: Foundation.NSDecimalNumber? {
    @objc get
  }
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var pricePerYear: Foundation.NSDecimalNumber? {
    @objc get
  }
  @objc final public var localizedIntroductoryPriceString: Swift.String? {
    @objc get
  }
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var localizedPricePerDay: Swift.String? {
    @objc get
  }
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var localizedPricePerWeek: Swift.String? {
    @objc get
  }
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var localizedPricePerMonth: Swift.String? {
    @objc get
  }
  @available(iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, *)
  @objc final public var localizedPricePerYear: Swift.String? {
    @objc get
  }
}
extension RevenueCat.StoreProduct {
  final public func eligiblePromotionalOffers() async -> [RevenueCat.PromotionalOffer]
}
extension RevenueCat.StoreProduct {
  @objc convenience dynamic public init(sk1Product: RevenueCat.SK1Product)
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  convenience public init(sk2Product: RevenueCat.SK2Product)
  @objc final public var sk1Product: RevenueCat.SK1Product? {
    @objc get
  }
  @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
  final public var sk2Product: RevenueCat.SK2Product? {
    get
  }
}
extension RevenueCat.StoreProduct {
  @available(iOS, unavailable, introduced: 11.2, renamed: "introductoryDiscount", message: "Use StoreProductDiscount instead")
  @available(tvOS, unavailable, introduced: 11.2, renamed: "introductoryDiscount", message: "Use StoreProductDiscount instead")
  @available(watchOS, unavailable, introduced: 6.2, renamed: "introductoryDiscount", message: "Use StoreProductDiscount instead")
  @available(macOS, unavailable, introduced: 10.13.2, renamed: "introductoryDiscount", message: "Use StoreProductDiscount instead")
  @objc final public var introductoryPrice: StoreKit.SKProductDiscount? {
    @objc get
  }
  @available(iOS, unavailable, message: "Use localizedPriceString instead")
  @available(tvOS, unavailable, message: "Use localizedPriceString instead")
  @available(watchOS, unavailable, message: "Use localizedPriceString instead")
  @available(macOS, unavailable, message: "Use localizedPriceString instead")
  @objc final public var priceLocale: Foundation.Locale {
    @objc get
  }
}
extension RevenueCat.PaywallComponent {
  final public class TabControlButtonComponent : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    final public let tabId: Swift.String
    final public let stack: RevenueCat.PaywallComponent.StackComponent
    public init(tabId: Swift.String, stack: RevenueCat.PaywallComponent.StackComponent)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.TabControlButtonComponent, rhs: RevenueCat.PaywallComponent.TabControlButtonComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class TabControlToggleComponent : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    final public let thumbColorOn: RevenueCat.PaywallComponent.ColorScheme
    final public let thumbColorOff: RevenueCat.PaywallComponent.ColorScheme
    final public let trackColorOn: RevenueCat.PaywallComponent.ColorScheme
    final public let trackColorOff: RevenueCat.PaywallComponent.ColorScheme
    public init(defaultValue: Swift.Bool, thumbColorOn: RevenueCat.PaywallComponent.ColorScheme, thumbColorOff: RevenueCat.PaywallComponent.ColorScheme, trackColorOn: RevenueCat.PaywallComponent.ColorScheme, trackColorOff: RevenueCat.PaywallComponent.ColorScheme)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.TabControlToggleComponent, rhs: RevenueCat.PaywallComponent.TabControlToggleComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class TabControlComponent : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public init()
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.TabControlComponent, rhs: RevenueCat.PaywallComponent.TabControlComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class TabsComponent : RevenueCat.PaywallComponentBase {
    final public class Tab : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      final public let id: Swift.String
      final public let stack: RevenueCat.PaywallComponent.StackComponent
      public init(id: Swift.String, stack: RevenueCat.PaywallComponent.StackComponent)
      final public func hash(into hasher: inout Swift.Hasher)
      public static func == (lhs: RevenueCat.PaywallComponent.TabsComponent.Tab, rhs: RevenueCat.PaywallComponent.TabsComponent.Tab) -> Swift.Bool
      @objc deinit
      final public func encode(to encoder: any Swift.Encoder) throws
      final public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    final public class TabControl : Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
      public enum TabControlType : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
        case buttons
        case toggle
        public init?(rawValue: Swift.String)
        public typealias RawValue = Swift.String
        public var rawValue: Swift.String {
          get
        }
      }
      final public let type: RevenueCat.PaywallComponent.TabsComponent.TabControl.TabControlType
      final public let stack: RevenueCat.PaywallComponent.StackComponent
      public init(type: RevenueCat.PaywallComponent.TabsComponent.TabControl.TabControlType, stack: RevenueCat.PaywallComponent.StackComponent)
      final public func hash(into hasher: inout Swift.Hasher)
      public static func == (lhs: RevenueCat.PaywallComponent.TabsComponent.TabControl, rhs: RevenueCat.PaywallComponent.TabsComponent.TabControl) -> Swift.Bool
      @objc deinit
      final public func encode(to encoder: any Swift.Encoder) throws
      final public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    final public let visible: Swift.Bool?
    final public let size: RevenueCat.PaywallComponent.Size
    final public let padding: RevenueCat.PaywallComponent.Padding
    final public let margin: RevenueCat.PaywallComponent.Padding
    final public let background: RevenueCat.PaywallComponent.Background?
    final public let shape: RevenueCat.PaywallComponent.Shape?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    final public let control: RevenueCat.PaywallComponent.TabsComponent.TabControl
    final public let tabs: [RevenueCat.PaywallComponent.TabsComponent.Tab]
    final public let defaultTabId: Swift.String?
    final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialTabsComponent>?
    public init(visible: Swift.Bool? = nil, size: RevenueCat.PaywallComponent.Size = .init(width: .fill, height: .fit), padding: RevenueCat.PaywallComponent.Padding = .zero, margin: RevenueCat.PaywallComponent.Padding = .zero, background: RevenueCat.PaywallComponent.Background? = nil, shape: RevenueCat.PaywallComponent.Shape? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil, control: RevenueCat.PaywallComponent.TabsComponent.TabControl, tabs: [RevenueCat.PaywallComponent.TabsComponent.Tab], defaultTabId: Swift.String? = nil, overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialTabsComponent>? = nil)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.TabsComponent, rhs: RevenueCat.PaywallComponent.TabsComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class PartialTabsComponent : RevenueCat.PaywallPartialComponent {
    final public let visible: Swift.Bool?
    final public let size: RevenueCat.PaywallComponent.Size?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let background: RevenueCat.PaywallComponent.Background?
    final public let shape: RevenueCat.PaywallComponent.Shape?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    public init(visible: Swift.Bool? = true, size: RevenueCat.PaywallComponent.Size? = nil, padding: RevenueCat.PaywallComponent.Padding? = nil, margin: RevenueCat.PaywallComponent.Padding? = nil, background: RevenueCat.PaywallComponent.Background? = nil, shape: RevenueCat.PaywallComponent.Shape? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil)
    final public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: RevenueCat.PaywallComponent.PartialTabsComponent, rhs: RevenueCat.PaywallComponent.PartialTabsComponent) -> Swift.Bool
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension StoreKit.SKRequest : @unchecked @retroactive Swift.Sendable {
}
extension StoreKit.SKProductsRequest : @unchecked @retroactive Swift.Sendable {
}
extension RevenueCat.PaywallComponent {
  final public class CarouselComponent : RevenueCat.PaywallComponentBase {
    public struct AutoAdvanceSlides : RevenueCat.PaywallComponentBase {
      public let msTimePerPage: Swift.Int
      public let msTransitionTime: Swift.Int
      public let transitionType: RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceTransitionType?
      public init(msTimePerPage: Swift.Int, msTransitionTime: Swift.Int, transitionType: RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceTransitionType?)
      public static func == (a: RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceSlides, b: RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceSlides) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public enum AutoAdvanceTransitionType : Swift.String, RevenueCat.PaywallComponentBase {
      case fade
      case slide
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public struct PageControl : RevenueCat.PaywallComponentBase {
      public enum Position : Swift.String, Swift.Codable, Swift.Sendable, Swift.Hashable, Swift.Equatable {
        case top
        case bottom
        public init(from decoder: any Swift.Decoder) throws
        public init?(rawValue: Swift.String)
        public typealias RawValue = Swift.String
        public var rawValue: Swift.String {
          get
        }
      }
      public let position: RevenueCat.PaywallComponent.CarouselComponent.PageControl.Position
      public let padding: RevenueCat.PaywallComponent.Padding?
      public let margin: RevenueCat.PaywallComponent.Padding?
      public let backgroundColor: RevenueCat.PaywallComponent.ColorScheme?
      public let shape: RevenueCat.PaywallComponent.Shape?
      public let border: RevenueCat.PaywallComponent.Border?
      public let shadow: RevenueCat.PaywallComponent.Shadow?
      public let spacing: Swift.Int
      public let `default`: RevenueCat.PaywallComponent.CarouselComponent.PageControlIndicator
      public let active: RevenueCat.PaywallComponent.CarouselComponent.PageControlIndicator
      public init(position: RevenueCat.PaywallComponent.CarouselComponent.PageControl.Position, padding: RevenueCat.PaywallComponent.Padding?, margin: RevenueCat.PaywallComponent.Padding?, backgroundColor: RevenueCat.PaywallComponent.ColorScheme?, shape: RevenueCat.PaywallComponent.Shape?, border: RevenueCat.PaywallComponent.Border?, shadow: RevenueCat.PaywallComponent.Shadow?, spacing: Swift.Int, default: RevenueCat.PaywallComponent.CarouselComponent.PageControlIndicator, active: RevenueCat.PaywallComponent.CarouselComponent.PageControlIndicator)
      public static func == (a: RevenueCat.PaywallComponent.CarouselComponent.PageControl, b: RevenueCat.PaywallComponent.CarouselComponent.PageControl) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct PageControlIndicator : RevenueCat.PaywallComponentBase {
      public let width: Swift.Int
      public let height: Swift.Int
      public let color: RevenueCat.PaywallComponent.ColorScheme
      public let strokeColor: RevenueCat.PaywallComponent.ColorScheme?
      public let strokeWidth: CoreFoundation.CGFloat?
      public init(width: Swift.Int, height: Swift.Int, color: RevenueCat.PaywallComponent.ColorScheme, strokeColor: RevenueCat.PaywallComponent.ColorScheme? = nil, strokeWidth: CoreFoundation.CGFloat? = nil)
      public static func == (a: RevenueCat.PaywallComponent.CarouselComponent.PageControlIndicator, b: RevenueCat.PaywallComponent.CarouselComponent.PageControlIndicator) -> Swift.Bool
      public func encode(to encoder: any Swift.Encoder) throws
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    final public let visible: Swift.Bool?
    final public let size: RevenueCat.PaywallComponent.Size?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let background: RevenueCat.PaywallComponent.Background?
    final public let shape: RevenueCat.PaywallComponent.Shape?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    final public let pages: [RevenueCat.PaywallComponent.StackComponent]
    final public let pageAlignment: RevenueCat.PaywallComponent.VerticalAlignment
    final public let pageSpacing: Swift.Int
    final public let pagePeek: Swift.Int
    final public let initialPageIndex: Swift.Int
    final public let loop: Swift.Bool
    final public let autoAdvance: RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceSlides?
    final public let pageControl: RevenueCat.PaywallComponent.CarouselComponent.PageControl?
    final public let overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialCarouselComponent>?
    public init(visible: Swift.Bool? = nil, size: RevenueCat.PaywallComponent.Size? = nil, padding: RevenueCat.PaywallComponent.Padding? = .zero, margin: RevenueCat.PaywallComponent.Padding? = .zero, background: RevenueCat.PaywallComponent.Background? = nil, shape: RevenueCat.PaywallComponent.Shape? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil, pages: [RevenueCat.PaywallComponent.StackComponent], pageAlignment: RevenueCat.PaywallComponent.VerticalAlignment = .center, pageSpacing: Swift.Int = 0, pagePeek: Swift.Int = 20, initialPageIndex: Swift.Int = 0, loop: Swift.Bool = false, autoAdvance: RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceSlides? = nil, pageControl: RevenueCat.PaywallComponent.CarouselComponent.PageControl? = nil, overrides: RevenueCat.PaywallComponent.ComponentOverrides<RevenueCat.PaywallComponent.PartialCarouselComponent>? = nil)
    public static func == (lhs: RevenueCat.PaywallComponent.CarouselComponent, rhs: RevenueCat.PaywallComponent.CarouselComponent) -> Swift.Bool
    final public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  final public class PartialCarouselComponent : RevenueCat.PaywallPartialComponent {
    final public let visible: Swift.Bool?
    final public let size: RevenueCat.PaywallComponent.Size?
    final public let padding: RevenueCat.PaywallComponent.Padding?
    final public let margin: RevenueCat.PaywallComponent.Padding?
    final public let background: RevenueCat.PaywallComponent.Background?
    final public let shape: RevenueCat.PaywallComponent.Shape?
    final public let border: RevenueCat.PaywallComponent.Border?
    final public let shadow: RevenueCat.PaywallComponent.Shadow?
    final public let pageAlignment: RevenueCat.PaywallComponent.VerticalAlignment?
    final public let pageSpacing: Swift.Int?
    final public let pagePeek: Swift.Int?
    final public let initialPageIndex: Swift.Int?
    final public let loop: Swift.Bool?
    final public let autoAdvance: RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceSlides?
    final public let pageControl: RevenueCat.PaywallComponent.CarouselComponent.PageControl?
    public init(visible: Swift.Bool? = true, size: RevenueCat.PaywallComponent.Size? = nil, padding: RevenueCat.PaywallComponent.Padding? = nil, margin: RevenueCat.PaywallComponent.Padding? = nil, background: RevenueCat.PaywallComponent.Background? = nil, shape: RevenueCat.PaywallComponent.Shape? = nil, border: RevenueCat.PaywallComponent.Border? = nil, shadow: RevenueCat.PaywallComponent.Shadow? = nil, pageAlignment: RevenueCat.PaywallComponent.VerticalAlignment? = nil, pageSpacing: Swift.Int? = nil, pagePeek: Swift.Int? = nil, initialPageIndex: Swift.Int? = nil, loop: Swift.Bool? = nil, autoAdvance: RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceSlides? = nil, pageControl: RevenueCat.PaywallComponent.CarouselComponent.PageControl? = nil)
    public static func == (lhs: RevenueCat.PaywallComponent.PartialCarouselComponent, rhs: RevenueCat.PaywallComponent.PartialCarouselComponent) -> Swift.Bool
    final public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    final public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension RevenueCat.VerificationResult : Swift.Equatable {}
extension RevenueCat.VerificationResult : Swift.Hashable {}
extension RevenueCat.VerificationResult : Swift.RawRepresentable {}
extension RevenueCat.StoreProduct : Swift.Sendable {}
extension RevenueCat.StoreProduct.ProductCategory : Swift.Equatable {}
extension RevenueCat.StoreProduct.ProductCategory : Swift.Hashable {}
extension RevenueCat.StoreProduct.ProductCategory : Swift.RawRepresentable {}
extension RevenueCat.StoreProduct.ProductType : Swift.Equatable {}
extension RevenueCat.StoreProduct.ProductType : Swift.Hashable {}
extension RevenueCat.StoreProduct.ProductType : Swift.RawRepresentable {}
extension RevenueCat.StoreTransaction : Swift.Sendable {}
extension RevenueCat.StoreProductDiscount.PaymentMode : Swift.Equatable {}
extension RevenueCat.StoreProductDiscount.PaymentMode : Swift.Hashable {}
extension RevenueCat.StoreProductDiscount.PaymentMode : Swift.RawRepresentable {}
extension RevenueCat.PurchasesDiagnostics.ProductStatus : Swift.Equatable {}
extension RevenueCat.PurchasesDiagnostics.ProductStatus : Swift.Hashable {}
extension RevenueCat.PurchasesDiagnostics.SDKHealthCheckStatus : Swift.Equatable {}
extension RevenueCat.PurchasesDiagnostics.SDKHealthCheckStatus : Swift.Hashable {}
extension RevenueCat.TestStoreProduct : Swift.Sendable {}
extension RevenueCat.StoreProductDiscount.DiscountType : Swift.Equatable {}
extension RevenueCat.StoreProductDiscount.DiscountType : Swift.Hashable {}
extension RevenueCat.StoreProductDiscount.DiscountType : Swift.RawRepresentable {}
extension RevenueCat.ErrorCode : Swift.Equatable {}
extension RevenueCat.ErrorCode : Swift.Hashable {}
extension RevenueCat.ErrorCode : Swift.RawRepresentable {}
extension RevenueCat.ErrorCode : Swift.CustomStringConvertible {}
extension RevenueCat.PurchasesAreCompletedBy : Swift.Equatable {}
extension RevenueCat.PurchasesAreCompletedBy : Swift.Hashable {}
extension RevenueCat.PurchasesAreCompletedBy : Swift.RawRepresentable {}
extension RevenueCat.RefundRequestStatus : Swift.Equatable {}
extension RevenueCat.RefundRequestStatus : Swift.Hashable {}
extension RevenueCat.RefundRequestStatus : Swift.RawRepresentable {}
extension RevenueCat.CustomerCenterPresentationMode : Swift.Hashable {}
extension RevenueCat.CacheFetchPolicy : Swift.Equatable {}
extension RevenueCat.CacheFetchPolicy : Swift.Hashable {}
extension RevenueCat.CacheFetchPolicy : Swift.RawRepresentable {}
extension RevenueCat.AppleReceipt.InAppPurchase.ProductType : Swift.Equatable {}
extension RevenueCat.AppleReceipt.InAppPurchase.ProductType : Swift.Hashable {}
extension RevenueCat.AppleReceipt.InAppPurchase.ProductType : Swift.RawRepresentable {}
extension RevenueCat.Store : Swift.Equatable {}
extension RevenueCat.Store : Swift.Hashable {}
extension RevenueCat.Store : Swift.RawRepresentable {}
extension RevenueCat.PeriodType : Swift.Equatable {}
extension RevenueCat.PeriodType : Swift.Hashable {}
extension RevenueCat.PeriodType : Swift.RawRepresentable {}
extension RevenueCat.LogLevel : Swift.Hashable {}
extension RevenueCat.LogLevel : Swift.RawRepresentable {}
extension RevenueCat.PackageType : Swift.Equatable {}
extension RevenueCat.PackageType : Swift.Hashable {}
extension RevenueCat.PackageType : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.StackComponent.Overflow : Swift.RawRepresentable {}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.Equatable {}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.Hashable {}
extension RevenueCat.SubscriptionPeriod.Unit : Swift.RawRepresentable {}
extension RevenueCat.PurchaseOwnershipType : Swift.Equatable {}
extension RevenueCat.PurchaseOwnershipType : Swift.Hashable {}
extension RevenueCat.PurchaseOwnershipType : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.PurchaseButtonComponent.Action : Swift.RawRepresentable {}
extension RevenueCat.AppleReceipt.Environment : Swift.Equatable {}
extension RevenueCat.AppleReceipt.Environment : Swift.Hashable {}
extension RevenueCat.AppleReceipt.Environment : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.TimelineComponent.IconAlignment : Swift.RawRepresentable {}
extension RevenueCat.StoreMessageType : Swift.Equatable {}
extension RevenueCat.StoreMessageType : Swift.Hashable {}
extension RevenueCat.StoreMessageType : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.ButtonComponent.URLMethod : Swift.RawRepresentable {}
extension RevenueCat.Configuration.EntitlementVerificationMode : Swift.Equatable {}
extension RevenueCat.Configuration.EntitlementVerificationMode : Swift.Hashable {}
extension RevenueCat.Configuration.EntitlementVerificationMode : Swift.RawRepresentable {}
extension RevenueCat.IntroEligibilityStatus : Swift.Equatable {}
extension RevenueCat.IntroEligibilityStatus : Swift.Hashable {}
extension RevenueCat.IntroEligibilityStatus : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.FontSize : Swift.RawRepresentable {}
extension RevenueCat.PaywallColor.ColorScheme : Swift.Hashable {}
extension RevenueCat.PaywallColor.ColorScheme : Swift.RawRepresentable {}
extension RevenueCat.PaywallColor.ColorScheme : Swift.BitwiseCopyable {}
extension RevenueCat.PaywallComponent.Condition : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.FlexDistribution : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.HorizontalAlignment : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.VerticalAlignment : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.TwoDimensionAlignment : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.FontWeight : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.FitMode : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.BadgeStyle : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.ComponentType : Swift.Equatable {}
extension RevenueCat.PaywallComponent.ComponentType : Swift.Hashable {}
extension RevenueCat.PaywallComponent.ComponentType : Swift.RawRepresentable {}
extension RevenueCat.AttributionNetwork : Swift.Equatable {}
extension RevenueCat.AttributionNetwork : Swift.Hashable {}
extension RevenueCat.AttributionNetwork : Swift.RawRepresentable {}
extension RevenueCat.StoreKitVersion : Swift.Equatable {}
extension RevenueCat.StoreKitVersion : Swift.Hashable {}
extension RevenueCat.StoreKitVersion : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.TabsComponent.TabControl.TabControlType : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.CarouselComponent.AutoAdvanceTransitionType : Swift.RawRepresentable {}
extension RevenueCat.PaywallComponent.CarouselComponent.PageControl.Position : Swift.RawRepresentable {}
